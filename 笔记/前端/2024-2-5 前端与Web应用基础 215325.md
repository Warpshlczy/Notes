C/S架构和B/S架构

C/S架构，特点：需要安装、偶尔更新、不跨平台、开发更具针对性。

B/S架构，特点：无需安装、无需更新、可跨平台、开发更具通用性。

名词解释：C => client（客户端）、B => browser（浏览器）、S => server（服务器）。

服务器 ：为软件提供数据的设备（在背后默默的付出）。

**前端工程师，主要负责编写** **B/S**架构中的网页（呈现界面、实现交互）。

备注：大前端时代，我们可以用前端的技术栈，做出一个C/S架构的应用、甚至搭建一个服务器😎。

## 浏览器

前置知识：[**万维网是如何工作的**](https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/How_the_Web_works)

### 定义

浏览器（Browser）是网页运行的平台，常见的浏览器有： 谷歌(Chrome) 、 Safari 、 IE 、 火狐(Firefox) 、 欧朋(Opera) 等，以上这些是常用的五大浏览器。

它们的主要作用是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置。

### **常见浏览器的内核**

![image-20240120165549939](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20240120165549939.png)

### 浏览器的主要组件

1. 用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。
2. 浏览器引擎 － 用来查询及操作渲染引擎的接口。
3. 渲染引擎 － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。不过我们一般习惯将之称为“浏览器内核”。**负责对网页语法的解释（html、javascript)并渲染（显示）网页**。 所以，通常所谓的浏览器内核也就是浏览器所采用的[渲染引擎](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/10982158)，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。
4. 网络 － 用来完成网络调用，例如http请求（通常由浏览器发出），它具有平台无关的接口，可以在不同平台上工作。
5. UI后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。
6. JS解释器 － 用来解释执行JS代码。html文档内若包含<script>标签，会使用它来解析
7. 数据存储 － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术。

### 浏览器的多进程架构

一个好的程序常常被划分为几个相互独立又彼此配合的模块，浏览器也是如此，以 Chrome 为例，它由多个进程组成，每个进程都有自己核心的职责，负责相应的组件。它们相互配合完成浏览器的整体功能，每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。

是的，仅仅只是一个浏览器，其实就包括了多个在后台运行的进程

![img](https://pic2.zhimg.com/80/v2-f04b3c3b86e76c1f63679d6a93191251_720w.webp)

不同浏览器采用了不同的架构模式，这里并不存在标准，以 Chrome 为例进行说明 ：

Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。

> 具体说来，Chrome 的主要进程及其职责如下：
>
> - Browser Process：
>
> 1. 负责包括地址栏，书签栏，前进后退按钮等部分的工作；
> 2. 负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；
>
> - Renderer Process：
>
>   负责一个 tab 内关于网页呈现的所有事情
>
> - Plugin Process：
>
>   负责控制一个网页用到的所有插件，如 flash
>
> - GPU Process
>
>   负责处理 GPU 相关的任务

![img](https://pic3.zhimg.com/80/v2-6b4e841c652a7a15554e98abce726222_720w.webp)

Chrome 还为我们提供了「任务管理器」，供我们方便的查看当前浏览器中运行的所有进程及每个进程占用的系统资源，右键单击还可以查看更多类别信息。

![img](https://pic3.zhimg.com/80/v2-de9e1fee7f8cd6a7572c280e36e7fb7a_720w.webp)

#### **优点**

1. 某一渲染进程出问题不会影响其他进程
2. 更为安全，在系统层面上限定了不同进程的权限

#### **缺点**

由于不同进程间的内存不共享，不同进程的内存常常需要包含相同的内容。

为了节省内存，Chrome 限制了最多的进程数，最大进程数量由设备的内存和 CPU 能力决定，当达到这一限制时，新打开的 Tab 会共用之前同一个站点的渲染进程。

### 浏览器的工作过程

#### 本地请求

用户直接打开本地储存的html文件，操作系统会直接打开浏览器，对本地html文件中的html语句、js和css进行解析并渲染到页面，渲染的过程见网络请求。

#### 网络请求

#### 1. 在浏览器中输入url

用户输入url，例如[http://www.feng.com](https://link.zhihu.com/?target=http%3A//www.feng.com/)。

其中，http为协议，www.feng.com为请求的服务器的在互联网的域名，以及所要请求的资源位于哪台计算机上

UI thread 需要判断用户输入的是 URL 还是 query；

#### **2. 开始导航**

当用户点击回车键，UI thread 通知 network thread 获取网页内容，并控制 tab 上的 spinner 展现，表示正在加载中。

network thread 会执行 DNS 查询，随后为请求建立 TLS 连接

输入url访问客户端地址，默认发送的是get请求和获取整份文件

![img](https://pic3.zhimg.com/80/v2-1f41f719f2aa59430906a04903cc751e_720w.webp)



#### **3. 读取响应**

当请求响应返回的时候，network thread 会依据 [Content-Type](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) 及 MIME Type sniffing 判断响应内容的格式

![img](https://pic4.zhimg.com/80/v2-4bf024603dc5af3b9b95ae9e8c2ca077_720w.webp)

如果响应内容的格式是 HTML ，下一步将会把这些数据传递给 renderer process，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。

[Safe Browsing](https://link.zhihu.com/?target=https%3A//safebrowsing.google.com/) 检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 [CORB](https://link.zhihu.com/?target=https%3A//www.chromium.org/Home/chromium-security/corb-for-developers) 检测也会触发确保敏感数据不会被传递给渲染进程。

![img](https://pic2.zhimg.com/80/v2-25a53c1db8e5f19aa15c49d1ac801d19_720w.webp)

#### **4. 查找渲染进程**

当上述所有检查完成，network thread 确信浏览器可以导航到请求网页，network thread 会通知 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。

![img](https://pic1.zhimg.com/80/v2-21c38fdae764be7bb8a2b40e2225c2b4_720w.webp)

收到 Network thread 返回的数据后，UI thread 查找相关的渲染进程

> 由于网络请求获取响应需要时间，这里其实还存在着一个加速方案。当 UI thread 发送 URL 请求给 network thread 时，浏览器其实已经知道了将要导航到那个站点。UI thread 会并行的预先查找和启动一个渲染进程，如果一切正常，当 network thread 接收到数据时，渲染进程已经准备就绪了，但是如果遇到重定向，准备好的渲染进程也许就不可用了，这时候就需要重启一个新的渲染进程。

#### **5. 确认导航**

进过了上述过程，数据以及渲染进程都可用了， Browser Process 会给 renderer process 发送 IPC 消息来确认导航，一旦 Browser Process 收到 renderer process 的渲染确认消息，导航过程结束，页面加载过程开始。

此时，地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中。

#### **6. 额外的步骤**

一旦导航被确认，renderer process 会使用相关的资源渲染页面，下文中我们将重点介绍渲染流程。当 renderer process 渲染结束（渲染结束意味着该页面内的所有的页面，包括所有 iframe 都触发了 onload 时），会发送 IPC 信号到 Browser process， UI thread 会停止展示 tab 中的 spinner。

![img](https://pic1.zhimg.com/80/v2-5180a7d523c44543c27059f083c612c8_720w.webp)

Renderer Process 发送 IPC 消息通知 browser process 页面已经加载完成

在这里我们可以明确一点，所有的 JS 代码其实都由 renderer Process 控制的，所以在你浏览网页内容的过程大部分时候不会涉及到其它的进程。不过也许你也曾经监听过 `beforeunload` 事件，这个事件再次涉及到 Browser Process 和 renderer Process 的交互，当当前页面关闭时（关闭 Tab ，刷新等等），Browser Process 需要通知 renderer Process 进行相关的检查，对相关事件进行处理。

![img](https://pic3.zhimg.com/80/v2-fbc3986ab6b19dce7057dbd8aa0149c2_720w.webp)

浏览器进程发送 IPC 消息给渲染进程，通知要离开当前网站了（IPC消息涉及到进程间的通信）

如果导航由 renderer process 触发（比如在用户点击某链接，或者JS执行 `window.location = "[http://newsite.com](https://link.zhihu.com/?target=http%3A//newsite.com/)" ` ） renderer process 会首先检查是否有 `beforeunload` 事件处理器，导航请求由 renderer process 传递给 Browser process

如果导航到新的网站，会启用一个新的 render process 来处理新页面的渲染，老的进程会留下来处理类似 `unload` 等事件。

关于页面的生命周期，更多内容可参考 [Page Lifecycle API](https://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2018/07/page-lifecycle-api%23overview_of_page_lifecycle_states_and_events) 。

![img](https://pic1.zhimg.com/80/v2-8e2938e10ee3a3ba2306c32db64dfca8_720w.webp)

浏览器进程发送 IPC 消息到新的渲染进程通知渲染新的页面，同时通知旧的渲染进程卸载



除了上述流程，有些页面还拥有 Service Worker （服务工作线程），Service Worker 让开发者对本地缓存及判断何时从网络上获取信息有了更多的控制权，如果 Service Worker 被设置为从本地 cache 中加载数据，那么就没有必要从网上获取更多数据了。

值得注意的是 service worker 也是运行在渲染进程中的 JS 代码，因此对于拥有 Service Worker 的页面，上述流程有些许的不同。

当有 Service Worker 被注册时，其作用域会被保存，当有导航时，network thread 会在注册过的 Service Worker 的作用域中检查相关域名，如果存在对应的 Service worker，UI thread 会找到一个 renderer process 来处理相关代码，Service Worker 可能会从 cache 中加载数据，从而终止对网络的请求，也可能从网上请求新的数据。

![img](https://pic3.zhimg.com/80/v2-1d4b1f7412b61857ce014bee605cd77a_720w.webp)

Service Worker 依据具体情形做处理

参考 [The Service Worker Lifecycle](https://link.zhihu.com/?target=https%3A//developers.google.com/web/fundamentals/primers/service-workers/lifecycle)

如果 Service Worker 最终决定通过网上获取数据，Browser 进程 和 renderer 进程的交互其实会延后数据的请求时间 。Navigation Preload 是一种与 Service Worker 并行的加速加载资源的机制，服务端通过请求头可以识别这类请求，而做出相应的处理。

参考Speed up Service Worker with Navigation Preloads](https://link.zhihu.com/?target=https%3A//developers.google.com/web/updates/2017/02/navigation-preload)

#### 7. 解析和渲染

渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。渲染进程中主要包含以下线程：

![img](https://pic3.zhimg.com/80/v2-8cdd6b38861816e4671bb74ff6c6715e_720w.webp)

渲染进程包含的线程

1. 主线程 Main thread
2. 工作线程 Worker thread
3. 排版线程 Compositor thread
4. 光栅线程 Raster thread

后文我们将逐步介绍不同线程的职责，在此之前我们先看看渲染的流程

**构建 DOM**

当渲染进程接收到导航的确认信息，开始接受 HTML 数据时，主线程会在HTML解析器帮助下解析文本字符串为 DOM。

渲染进程在浏览器中创建DOM对象

渲染 html 为 DOM 的方法由 [HTML Standard](https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/) 定义。

读取的方式为一行一行读取并解析

**加载次级的资源**

网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 `<img>` `<link>` 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。

**JS 的下载与执行**

当遇到 `<script>` 标签时，渲染进程会停止解析 HTML，而去加载，解析和执行 JS 代码，停止解析 html 的原因在于 JS 可能会改变 DOM 的结构（使用诸如 `document.write()`等API）。

不过开发者其实也有多种方式来告知浏览器应对如何应对某个资源，比如说如果在`<script>` 标签上添加了 `async` 或 `defer` 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。更多的方法可参考 [Resource Prioritization – Getting the Browser to Help You](https://link.zhihu.com/?target=https%3A//developers.google.com/web/fundamentals/performance/resource-prioritization)

**样式计算**

仅仅渲染 DOM 还不足以获知页面的具体样式，主进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式。

![img](https://pic2.zhimg.com/80/v2-4ab99a16c8f858b136e668b302216ab5_720w.webp)

渲染进程主线程计算每一个元素节点的最终样式值

**获取布局**

想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下：

通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 `display:none` ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。

**浏览器按从上到下，从左到右的顺序，读取DOM树的文档节点**，顺序存放到一条虚拟的传送带上。

传送带上的盒子就是节点，而这条流动的传送带就是[文档流](https://www.zhihu.com/search?q=文档流&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A611326215})。

如果我们读取到的节点是属于另一个节点下的[子节点](https://www.zhihu.com/search?q=子节点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A611326215})，那么在放入传送带的时候，就应该按顺序放到该节点盒子的内部。

![img](https://pic2.zhimg.com/80/v2-244455c869de0a94e2e05fcbc32a0289_720w.webp)

主线程遍历 DOM 及 对应元素的样式，构建出布局树


**绘制各元素**

即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。

![img](https://pic3.zhimg.com/80/v2-b8c211158c041befc9f87d1eed7cf05e_720w.webp)

主线程依据布局树构建绘制记录



**7. 合成帧**

熟悉 PS 等绘图软件对图层这一概念不陌生，现代 Chrome 其实利用了这一概念来组合不同的层。

复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成。

主线程会遍历布局树来创建层树（layer tree），添加了 `will-change` CSS 属性的元素，会被看做单独的一层，

![img](https://pic3.zhimg.com/80/v2-f7fac020e2946e993fdb939e673af596_720w.webp)

主线程遍历布局树生成层树

你可能会想给每一个元素都添加上 `will-change`，不过组合过多的层也许会比在每一帧都栅格化页面中的某些小部分更慢。为了更合理的使用层，可参考 [坚持仅合成器的属性和管理层计数](https://link.zhihu.com/?target=https%3A//developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count) 。

一旦层树被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 显存中。

![img](https://pic4.zhimg.com/80/v2-d4b0ff9ed4cbbfe35d855ce5605c0fdb_720w.webp)

栅格线程会栅格化每一个磁贴并存储在 GPU 显存中

一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。

合成帧随后会通过 IPC 消息传递给浏览器进程，由于浏览器的 UI 改变或者其它拓展的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。

![img](https://pic2.zhimg.com/80/v2-88bc6f8c88578263e9629920b66b6aad_720w.webp)

合成器线程会发送合成帧给 GPU 渲染

合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么[合成器相关的动画](https://link.zhihu.com/?target=https%3A//www.html5rocks.com/en/tutorials/speed/high-performance-animations/) 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。

------

### **浏览器对事件的处理**

浏览器通过对不同事件的处理来满足各种交互需求，这一部分我们一起看看从浏览器的视角，事件是什么，在此我们先主要考虑鼠标事件。

> 在浏览器的看来，用户的所有手势都是输入，鼠标滚动，悬置，点击等等都是。

当用户在屏幕上触发诸如 touch 等手势时，首先收到手势信息的是 Browser process， 不过 Browser process 只会感知到在哪里发生了手势，对 tab 内内容的处理是还是由渲染进程控制的。

事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。

![img](https://pic3.zhimg.com/80/v2-b6ba85501ebfc1dd8f738d913cc3c2d2_720w.webp)

事件从浏览器进程传送给渲染进程

前文中，我们提到过合成器可以独立于主线程之外通过合成栅格化层平滑的处理滚动。如果页面中没有绑定相关事件，组合器线程可以独立于主线程创建组合帧。如果页面绑定了相关事件处理器，主线程就不得不出来工作了。这时候合成器线程会怎么处理呢？

这里涉及到一个专业名词「理解非快速滚动区域（non-fast scrollable region）」由于执行 JS 是主线程的工作，当页面合成时，合成器线程会标记页面中绑定有事件处理器的区域为 non-fast scrollable region ，如果存在这个标注，合成器线程会把发生在此处的事件发送给主线程，如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。

![img](https://pic4.zhimg.com/80/v2-221b2220bf574a91cd57b9d2607299a7_720w.webp)

涉及 non-fast scrollable region 的事件，合成器线程会通知主线程进行相关处理

web 开发中常用的事件处理模式是事件委托，基于事件冒泡，我们常常在最顶层绑定事件：

```js
document.body.addEventListener('touchstart',  event => {
    if (event.target === area) {
        event.preventDefault();
    }
} );
```

上述做法很常见，但是如果从浏览器的角度看，整个页面都成了 non-fast scrollable region 了。

这意味着即使操作的是页面无绑定事件处理器的区域，每次输入时，合成器线程也需要和主线程通信并等待反馈，流畅的合成器独立处理合成帧的模式就失效了。

![img](https://pic2.zhimg.com/80/v2-d321e174021416213a2df00bb44f0e25_720w.webp)

由于事件绑定在最顶部，整个页面都成为了 non-fast scrollable region

为了防止这种情况，我们可以为事件处理器传递 `passive: true` 做为参数，这样写就能让浏览器即监听相关事件，又让组合器线程在等等主线程响应前构建新的组合帧。

```js
document.body.addEventListener('touchstart',  event => {
    if (event.target === area) {
        event.preventDefault()
    }
 }, {passive: true} );
```

不过上述写法可能又会带来另外一个问题，假设某个区域你只想要水平滚动，使用 `passive: true` 可以实现平滑滚动，但是垂直方向的滚动可能会先于`event.preventDefault()`发生，此时可以通过 `event.cancelable` 来防止这种情况。

```js
document.body.addEventListener('pointermove', event => {
    if (event.cancelable) {
        event.preventDefault(); // block the native scroll
        /*
        *  do what you want the application to do here
        */
    } 
}, {passive: true});
```

也可以使用css属性 `touch-action` 来完全消除事件处理器的影响，如：

```css
#area { 
  touch-action: pan-x; 
}
```

**查找到事件对象**

当组合器线程发送输入事件给主线程时，主线程首先会进行命中测试（hit test）来查找对应的事件目标，命中测试会基于渲染过程中生成的绘制记录（ paint records ）查找事件发生坐标下存在的元素。

![img](https://pic2.zhimg.com/80/v2-3d99287b49fde9d34d45132143608269_720w.webp)

主线程依据绘制记录查找事件相关元素

**事件的优化**

一般我们屏幕的刷新速率为 60fps，但是某些事件的触发量会不止这个值，出于优化的目的，Chrome 会合并连续的事件(如 wheel, mousewheel, mousemove, pointermove, touchmove )，并延迟到下一帧渲染时候执行 。

而如 keydown, keyup, mouseup, mousedown, touchstart, 和 touchend 等非连续性事件则会立即被触发。

![img](https://pic2.zhimg.com/80/v2-ae412ef9519d8dc5d37b0b81b648eab5_720w.webp)

Chrome 会合并连续事件到下一帧触发

合并事件虽然能提示性能，但是如果你的应用是绘画等，则很难绘制一条平滑的曲线了，此时可以使用 `getCoalescedEvents` API 来获取组合的事件。示例代码如下：

```js
window.addEventListener('pointermove', event => {
    const events = event.getCoalescedEvents();
    for (let event of events) {
        const x = event.pageX;
        const y = event.pageY;
        // draw a line using x and y coordinates.
    }
});
```

![img](https://pic1.zhimg.com/80/v2-609b56d3372da59b9183c50a8814d330_720w.webp)

通过 getCoalescedEvents API 获取到每一个事件

## HTML

![image-20230731100932505](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230731100932505.png)

### 定义

1. 超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。

   > 超文本：暂且简单理解为 “超级的文本”，和普通文本比，内容更丰富。
   >
   > 标 记：文本要变成超文本，就需要用到各种标记符号。
   >
   > 语 言：每一个标记的写法、读音、使用规则，组成了一个标记语言
   >
   > 

2. 它包括一系列[标签](https://baike.baidu.com/item/标签/2440469?fromModule=lemma_inlink)，通过这些标签可以将网络上的[文档](https://baike.baidu.com/item/文档/1009768?fromModule=lemma_inlink)格式统一，使分散的[Internet](https://baike.baidu.com/item/Internet/272794?fromModule=lemma_inlink)资源（通过网络连接，即url超文本）连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性[文本](https://baike.baidu.com/item/文本/5443630?fromModule=lemma_inlink)，HTML命令可以说明[文字](https://baike.baidu.com/item/文字/612910?fromModule=lemma_inlink)，[图形](https://baike.baidu.com/item/图形/773307?fromModule=lemma_inlink)、[动画](https://baike.baidu.com/item/动画/206564?fromModule=lemma_inlink)、[声音](https://baike.baidu.com/item/声音/33686?fromModule=lemma_inlink)、[表格](https://baike.baidu.com/item/表格/3371820?fromModule=lemma_inlink)、[链接](https://baike.baidu.com/item/链接/2665501?fromModule=lemma_inlink)等。 [1] 

3. 它并不是图灵完备的一种语言

### **相关国际组织（了解）**

**1. IETF**

全称：Internet Engineering Task Force（国际互联网工程任务组），成立于1985年底，是一个权威

的互联网技术标准化组织，主要负责互联网相关技术规范的研发和制定，当前绝大多数国际互联网

技术标准均出自IETF。官网：**https://www.ietf.org**

**2. W3C**

全称：World Wide Web Consortium（万维网联盟），创建于1994年，是目前Web技术领域，最具影

响力的技术标准机构。共计发布了200多项技术标准和实施指南，对互联网技术的发展和应用起到

了基础性和根本性的支撑作用，官网：**https://www.w3.org**

**3. WHATWF**

全称：Web Hypertext Application Technology Working Group（网页超文本应用技术工作小组）成立

于2004年，是一个以推动网络HTML 5 标准为目的而成立的组织。由Opera、Mozilla基金会、苹果，

等这些浏览器厂商组成。官网：**https://whatwg.org**

![image-20230903124404516](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230903124404516.png)

### 特点

1. 是可以被各大浏览器读取并解析的语言之一（另外两种是js和css）
2. 网页文件本身是一种[文本文件](https://baike.baidu.com/item/文本文件/747597?fromModule=lemma_inlink)，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（如：文字如何处理，画面如何安排，图片如何显示等）
3. 在普通文档的后缀名更改为html或htm，表示这个文件可以被浏览器编译为页面文档文件（document），也就是DOM,并按照文档节点的排布和包含顺序依次展现在浏览器的显示界面上

### DOM

在HTML代码被浏览器解析时，HTML标签会首先先被浏览器的HTML解释器读取并翻译为机器码，cpu一行行将机器码加载到浏览器渲染的进程中，并在进程的堆内存（由操作系统分配）中创建DOM对象，这个对象，全称“Document Object Model（文档对象模型）”，它是由W3C组织定义的一个标准

> 事实上，一个 web 页面是一个文档。这个文档可以在浏览器窗口或作为 HTML 源码显示出来。但上述两个情况中都是同一份文档。文档对象模型（DOM）提供了对同一份文档的另一种表现，存储和操作的方式。DOM 是 web 页面的完全的面向对象表述，它能够使用如 JavaScript 等脚本语言进行修改。

DOM下的子对象，又被称为DOM结点，DOM元素

说白了，DOM就是一个接口，我们可以通过DOM来操作页面中各种元素，例如添加元素、删除元素、替换元素等。

通常来说，一对HTML标签就可以被解析为一个DOM下的子对象

渲染进程会根据DOM内的结点信息来进行页面的渲染

DOM采用树形结构作为分层结构，以树节点形式表示页面中各种元素或内容。

在DOM中，每一个节点就是一个“对象”。也就是我们在操作元素时，把每一个元素节点看成一个对象，然后使用这个对象的属性和方法进行相关操作。

#### 节点

由html标签解析生成的DOM对象，也叫DOM节点。

1、根节点

在HTML文档中，html就是根节点。

2、父节点

一个节点之上的节点就是该节点的父节点，例如h1的父节点就是body，body的父节点就是html。

3、子节点

一个节点之下的节点就是该节点的子节点，例如h1就是body的子节点。

4、兄弟节点

如果多个节点在同一层次，并拥有相同的父节点，那么这几个节点就是兄弟节点。

例如h1和p就是兄弟节点，因为他们拥有相同的父节点body。

#### HTML 标签

**标签** 又称 **元素**，是HTML的基本组成单位

![image-20230731101400338](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230731101400338.png)

HTML 标记标签通常被称为 HTML 标签 (HTML tag)。

- HTML 标签是由*尖括号*包围的关键词，比如 <html>

- HTML 标签通常是*成对出现*的，比如 <b> 和 </b>，这种标签叫**双标签**

- 部分元素仅由单标签组成，如<input>，这种标签叫这种标签叫**单标签**

- HTML 元素以**开始标签**起始

- 标签名不区分大小写，但推荐小写，因为小写更规范。

- HTML 元素以**结束标签**终止

- **元素的内容**是开始标签与结束标签之间的内容

- 某些 HTML 元素具有**空内容（empty content）**

- 空元素**在开始标签中进行关闭**（以开始标签的结束而结束）

- 大多数 HTML 元素可拥有**属性**

- 标签对中的第一个标签是*开始标签*，第二个标签是*结束标签*

- 开始和结束标签也被称为*开放标签*和*闭合标签*

  > 1. 一些标签的使用，切记所有标签都需要闭合，不管是单体标签还是成对标签。（尽管目前浏览器是识别有些标签不闭合的情况，但是取的最好的保证兼容性，使用闭合）
  >
  > 2. 标签写法要用小写字母（有些版本对大小写可认为相同，而xhtml中强制使用小写）

一个标签被解析后，对应一个带有一定样式的DOM元素对象

![image-20240123172658299](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20240123172658299.png)

标签之间的关系：**并列**和**嵌套**

![image-20240123172848007](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20240123172848007.png)

#### HTML 空元素

没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。

<br> 就是没有关闭标签的空元素（<br> 标签定义换行）。

在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。

在开始标签中添加斜杠，比如 <br />，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。

即使 <br> 在所有浏览器中都是有效的，但使用 <br />其实是更长远的保障。

#### HTML 注释

可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。

注释写法如下:

```
<!-- 这是一个注释 -->
```

注意：注释不能嵌套！

```
<!-- 这是一个注释 <!-- --> -->
invalid！
```

#### HTML 属性

- HTML 元素可以设置**属性**

-  可以写在：起始标签 或 单标签中

- 属性可以在元素中添加**附加信息**

  ![img](https://upload-images.jianshu.io/upload_images/28917406-516193df3fa9ae6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 属性一般描述于**开始标签**

- 属性于标签上被解析后，生成的DOM对象上就会带有相应的属性和属性值，渲染时，DOM对象构建的HTML元素也会带有相应的属性和属性值

- 属性总是以名称/值对的形式出现，**比如：name="value"**。

- **值一定为字符串，以字符串的形式传值**

- 部分属性名由于属性值由true和false控制，所以在定义时只写属性名则表示默认开启为true，不写则表示false，如

  disabled属性

  ![img](https://upload-images.jianshu.io/upload_images/28917406-a42ba116ef9c942e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- | 属性  | 描述                                                         |
  | :---- | :----------------------------------------------------------- |
  | class | 为html元素定义一个或多个类名（classname）(类名从样式文件引入) |
  | id    | 定义元素的唯一id                                             |
  | style | 规定元素的行内样式（inline style）                           |
  | title | 描述了元素的额外信息 (作为工具条使用)                        |

  > #### DOM元素的属性
  >
  > 随HTML标签解析得到的DOM元素的创建被一并分配
  >
  > 常见的有：class、id、style、name、href、innerHTML等等，由html标签相应设置的属性映射得到

![image-20230903115546387](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230903115546387.png)

> 注意:
>
> 1. 不同的标签，有不同的属性；也有一些通用属性（在任何标签内都能写，后面会详细总结）。
>
> 2. 属性名、属性值不能乱写，都是W3C规定好的。
>
> 3. 属性名、属性值，都不区分大小写，但推荐小写。
>
> 4. 双引号，也可以写成单引号，甚至不写都行，但还是推荐写**双引号**。
> 5. 标签中不要出现同名属性，否则后写的会失效，例如：<input type="text" type="password">

![image-20240123222549735](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20240123222549735.png)

**全局属性**

适用对象：所有html元素

1. [`accesskey`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/accesskey)
2. [`autocapitalize`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/autocapitalize)
3. [`autofocus`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/autofocus) 是否自动聚焦
4. [`class`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/class) 类名
5. [`contenteditable`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contenteditable)
6. [`contextmenu`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contextmenu)非标准已弃用
7. [`data-*`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/data-*)
8. [`dir`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/dir)
9. [`draggable`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/draggable)
10. [`enterkeyhint`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/enterkeyhint)
11. [`exportparts`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/exportparts)
12. [`hidden`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/hidden)
13. [`id`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/id)
14. [`inert`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/inert)
15. [`inputmode`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/inputmode)
16. [`is`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/is)
17. [`itemid`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/itemid)
18. [`itemprop`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/itemprop)
19. [`itemref`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/itemref)
20. [`itemscope`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/itemscope)
21. [`itemtype`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/itemtype)
22. [`lang`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang)
23. [`nonce`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/nonce)
24. [`part`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/part)
25. [`popover`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/popover)
26. [`slot`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/slot)
27. [`spellcheck`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/spellcheck)
28. [`style`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/style)
29. [`tabindex`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/tabindex)
30. [`title`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/title)
31. [`translate`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/translate)
32. [`virtualkeyboardpolicy`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/virtualkeyboardpolicy)

#### 头部元素标签

- **<!DOCTYPE html>** 声明为 HTML5 文档,告诉浏览器目前的版本当前网页的版本是html5，浏览器才能正确根据html的版本进行渲染。

  ```
  <!DOCTYPE>声明有助于浏览器中正确显示网页。
  
  网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。
  
  doctype 声明是不区分大小写的，以下方式均可：
  
  <!DOCTYPE html>
  
  <!DOCTYPE HTML>
  
  <!doctype html>
  
  <!Doctype Html>
  通用声明
  HTML5
  <!DOCTYPE html>
  HTML 4.01
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">
  XHTML 1.0
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  ```

- **<html>** 元素是 HTML 页面的根元素，浏览器识别到该元素后，以此创建DOM。它的属性为**lang**，意思为语言，可以通过"zh-CN"等来设置页面的初始定义语言（即浏览器的翻译功能识别语言）

- **<head>** 元素包含了文档的元（meta）数据，如 **<meta charset="utf-8">** 定义网页编码格式为 **utf-8**。

> <head> 元素包含了所有的头部标签元素。在 <head>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。
> 可以添加在头部区域的元素标签为: <title>, <style>, <meta>, <link>, <script>, <noscript> 和 <base>。
>  所有头部标签作用整理如下：
> 1.<base> 
>  描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接，即baseURL
>  如：
>  <head>
> <base href="http://www.runoob.com/images/" target="_blank">
> </head>
> 2.<link> 
> <link> 标签定义了文档与外部资源之间的关系。
>  其中rel决定渲染类型，type决定获取类型(MIME)，href决定目标资源的地址
> <link> 标签通常用于链接到样式表:
>
>  <head>
> <link rel="stylesheet" type="text/css" href="mystyle.css">
> </head>
>
> 3.<style>
>
> <style> 标签定义了HTML文档的样式文件引用地址.
> 在<style> 元素中你也可以直接添加样式来渲染 HTML 文档,如：
>  <head>
> <style type="text/css">
> body {
>  background-color:yellow;
> }
> p {
>  color:blue
> }
> </style>
> </head>
> 4.<meta> 属性主要用于定义网页的各种元数据，方便浏览器更好的解析和展示数据。
>
> 元数据是**定义页面数据在万维网上如何被查找和浏览器展示的关键数据**，它有助于搜索引擎优化（SEO），使得网页在搜索结果中更容易被用户发现和点击。大多数搜索引擎都优先考虑meta标签中的信息。
>
> 以description为例，它的实现原理是：当用户访问网页时，浏览器会自动检测页面上存在的元数据，并将这些信息发送给浏览器。搜索引擎是通过爬虫程序来抓取网页上的元数据，从而获取网页的信息。
>
> meta标签可以提高网页在搜索结果中的可见性和准确性。通过提供清晰的描述信息，用户可以更快地了解网页的内容，从而提高点击率。
>
> 尽管 description meta标签对于SEO非常重要，但它不是唯一的影响因素。其他因素，如网页的标题（title）、URL（域名）、内容质量（由网页的内容和结构决定）等，也会影响到网页在搜索结果中的排名。
>
> - 如果设置了 [`name`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#name) 属性，`<meta>` 元素提供的是文档级别（*document-level*）的元数据，应用于整个页面。
> - 如果设置了 [`http-equiv`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#http-equiv) 属性，`<meta>` 元素则是编译指令，提供的信息与类似命名的 HTTP 头部相同。
> - 如果设置了 [`charset`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#charset) 属性，`<meta>` 元素是一个字符集声明，告诉文档使用哪种字符编码。
> - 如果设置了 [`itemprop`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#itemprop) 属性，`<meta>` 元素提供用户定义的元数据。
>
> **http-equiv属性**
>
> HTTP-EQUIV类似于HTTP的头部协议，它回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。常用的HTTP-EQUIV类型有：Content-Type、Refresh 、Expires 、Pragma 、Set-Cookie、Page-Enter、Page-Exit等
>
> ## 1、Content-Type和Content-Language (显示字符集的设定)
>
> 说明：设定页面使用的字符集，用以说明主页制作所使用的文字语言，浏览器会根据此来调用相应的字符集显示page内容。
>
> 用法：
>
> ```html
> <meta http-equiv="content-type" content="text/html; charset=utf-8" />
> <meta http-equiv="content-language" content="zh-CN" />
> ```
>
> 注意：该META标签定义了HTML页面所使用的字符集为utf-8，就是国标汉字码。如果将其中的“charset=utf-8”替换成“BIG5”，则该页面所用的字符集就是繁体中文Big5码。
>
> - Content-Type的Content还可以是：text/xml等文档类型；Charset选项：ISO-8859-1(英文)、BIG5、UTF-8、SHIFT-Jis、Euc等字符集；
> - Content-Language的Content还可以是：EN、FR等语言代码。
>
> ## 2、Refresh (自动刷新页面)
>
> 说明：让网页多长时间（秒）刷新自己，或在多长时间后让网页自动链接到其它网页。
>
> 用法：
>
> ```html
> <meta http-equiv="Refresh" content="30" />
> <meta http-equiv="Refresh" content="5; url=https://cnblogs.com/caiduping" />
> ```
>
> 注意：其中的5是指停留5秒钟后自动刷新到URL网址。
>
> ## 3、Expires (期限)
>
> 说明：指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调阅。
>
> 用法：
>
> ```html
> <meta http-equiv="Expires" content="0" />
> <meta http-equiv="Expires" content="Wed, 26 Feb 1997 08:21:57 GMT" />
> ```
>
> 注意：必须使用GMT的时间格式，或直接设为0(数字表示多少时间后过期)。
>
> ## 4、Pragma (cach模式)
>
> 说明：禁止浏览器从本地机的缓存中调阅页面内容。
>
> 用法：
>
> ```html
> <meta http-equiv="Pragma" content="No-cach"/>
> ```
>
> 注意：网页不保存在缓存中，每次访问都刷新页面。这样设定，访问者将无法脱机浏览。
>
> ## 5、Set-Cookie (cookie设定)
>
> 说明：浏览器访问某个页面时会将它存在缓存中，下次再次访问时就可从缓存中读取，以提高速度。当你希望访问者每次都刷新你广告的图标，或每次都 刷新你的计数器，就要禁用缓存了。通常HTML文件没有必要禁用缓存，对于ASP等页面，就可以使用禁用缓存，因为每次看到的页面都是在服务器动态生成 的，缓存就失去意义。如果网页过期，那么存盘的cookie将被删除。
>
> 用法：
>
> ```html
> <meta http-equiv="Set-Cookie" content="cookievalue=xxx; expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/"/>
> ```
>
> ## 6、Window-target (显示窗口的设定)
>
> 说明：强制页面在当前窗口以独立页面显示。
>
> 用法：
>
> ```html
> <meta http-equiv="Widow-target" content="_top"/>
> ```
>
> 注意：这个属性是用来防止别人在框架里调用你的页面。Content选项：_blank、_top、_self、_parent。
>
> ## 7、Content-Script-Type (脚本相关)
>
> 说明：这是近来W3C的规范，指明页面中脚本的类型。
>
> 用法：
>
> ``
>
> ```html
> <meta http-equiv="content-script-type" content=``"text/javascript">
> ```
>
> IE浏览器下：
>
> - Page-Enter、Page-Exit 页面进入和离开是的特效
> - Site-Enter、Site-Exit 站点进入和离开是的特效
>
> 用法：
>
> ``
>
> ```html
> <meta http-equiv="Page-Enter" content=``"blendTrans(Duration=0.5)"` `/>`
> `<meta http-equiv=``"Page-Exit"` `content=``"blendTrans(Duration=0.5)"` `/>`
> `<meta http-equiv=``"Site-Enter"` `content=``"blendTrans(Duration=0.5)"` `/>`
> `<meta http-equiv=``"Site-Exit"` `content=``"blendTrans(Duration=0.5)"` `/>
> ```
>
> 注意：blendTrans是动态滤镜的一种，产生渐隐效果。
>
> 另一种动态滤镜RevealTrans也可以用于页面进入与退出效果:
>
> ``
>
> ```html
> <meta http-equiv=``"Page-Enter"` `content=``"revealTrans(duration=x, transition=y)"` `/>`
> `<meta http-equiv=``"Page-Exit"` `content=``"revealTrans(duration=x, transition=y)"` `/>`
> `<meta http-equiv=``"Site-Enter"` `content=``"revealTrans(duration=x, transition=y)"` `/>`
> `<meta http-equiv=``"Site-Exit"` `content=``"revealTrans(duration=x, transition=y)"` `/>
> ```
>
> - Duration 表示滤镜特效的持续时间(单位：秒)
> - Transition 滤镜类型。表示使用哪种特效，取值为0-23。
>
> 其取值意思如下表所示：
>
> | 0    | 盒状收缩       | 12   | 随意溶解             |
> | ---- | -------------- | ---- | -------------------- |
> | 1    | 盒状放射       | 13   | 从左右两端向中间展开 |
> | 2    | 圆形收缩       | 14   | 从中间向左右两端展开 |
> | 3    | 圆形放射       | 15   | 从上下两端向中间展开 |
> | 4    | 由下往上       | 16   | 从中间向上下两端展开 |
> | 5    | 由上往下       | 17   | 从右上角向左下角展开 |
> | 6    | 从左至右       | 18   | 从右下角向左上角展开 |
> | 7    | 从右至左       | 19   | 从左上角向右下角展开 |
> | 8    | 垂直百叶窗     | 20   | 从左下角向右上角展开 |
> | 9    | 水平百叶窗     | 21   | 水平线状展开         |
> | 10   | 水平格状百叶窗 | 22   | 垂直线状展开         |
> | 11   | 垂直格状百叶窗 | 23   | 随机产生一种过渡方式 |
>
> 当我们点击网页上的链接时，浏览器页面就会转到链接指向的新的页面，我们想在页面转换时加上过渡效果。
> 打开这个页面的原代码，在<head>与</head>插入代码：
>
> ```html
> <meta http-equiv=``"Page-Exit"` `content=``"revealTrans(Duration=3,Transition=5)"``>
> ```
>
> 这样这个过渡效果就完成了，很简单吧。现在我们来测试一下效果如何，打开这个页面，然后点击页面上的链接，页面在转到下一个页面的过程中，我们看到页面是从上到下慢慢的转换到第二个页面的。
>
> ## 8、关键词、描述
>
> 说明：META也常用来描述网页,以供某些搜索站台机器人的使用。大家知道,搜索站台分为两大类,一类为完全人工登录,比如Yahoo；另一类 为机器人搜索,以机器人搜索的搜索站台会包含更多的内容。机器人会搜索网页META标签中所设置的描述关键字,把它们加入到搜索数据库中,用来索引你的网 页。而这个标签很少有人注意到。在格式中,Content列出了你所设置的关键字,这其中的内容可以自行设置,其间用逗号相隔。这里有个技巧,你可以重复 某一个单词,这样可以提高自己网站的排行位置
>
> 用法：
>
> ``
>
> ```html
> <meta name=``"keywords"` `content=``"这里是关键词"` `/>`
> `<meta name=``"description"` `content=``"这里是描述"` `/>
> ```
>
> ## 9、控制页面缓冲
>
> 说明：META可以设置网页到期的时间,也就是说,当你在Internet Explorer 4.0浏览器中设置浏览网页时首先查看本地缓冲里的页面,那么当浏览某一网页,而本地缓冲又有时,那么浏览器会自动浏览缓冲区里的页面,直到META中设 置的时间到期,这时候,浏览器才会去取得新页面
>
> 用法：
>
> ``
>
> ```html
> <meta http-equiv=``"expires"` `content=``"TUE,11.NOV 1998 00:00 GMT"` `/>`
> `<meta http-equiv=``"pragma"` `content=``"no-cache"` `/>
> ```
>
> 设置浏览器为不缓存当前网页
>
> ```html
> <meta http-equiv=``"cache-control"` `content=``"no-cache"` `/>
> ```
>
> 设置浏览器网页是否过期
>
> ```html
> <meta http-equiv=``"expires"` `content=``"0"` `/>
> ```
>
> 设置网页过期，0表示永不过期或设置-1。
>
> 这段代码是用于设置浏览器兼容性的。它的目的是在确保网站在不同的浏览器（如Internet Explorer和Chrome）中都能正常工作。
>
> **10.控制网页自适应浏览器**
>
> 1. <meta http-equiv="X-UA-Compatible"`： 这个标签用于设置浏览器的首选用户代理（UA）和渲染模式。它是一个特殊的meta标签，通常不会显示在网页上。
>
> - `content`属性： 这个属性用于指定用户代理和渲染模式的内容。
> - `IE=edge`： 这个值表示网站应该使用Internet Explorer的最新版本（Edge模式）来支持IPv4和IPv6。
>   - `chrome=1`： 这个值表示网站应该使用旧版本的渲染引擎（Chrome 1）而不是新版本（Chrome 2）。这对于要求Internet Explorer渲染的网站非常有用，因为新版本的渲染引擎有一些限制，无法正确支持旧版本的浏览器。
>
> 2. `content="IE=edge,chrome=1"`： 这个是`content`属性的值，指定了网站的首选用户代理和渲染模式。
>
> 注意事项：
>
> - 虽然使用这段代码可以提高网站在特定浏览器中的兼容性，但请记住，这并不能保证网站在所有浏览器中都完美兼容。在实际开发中，建议同时测试不同浏览器以确保网站的兼容性。
> - 这段代码只能影响到浏览器的行为，不能直接修复浏览器本身的兼容性问题。要完全解决这个问题，还需要对网站的代码进行相应的调整和优化。
>
> 除此之外，meta一般由name和content组成的键值对属性定义，如为搜索引擎定义关键词:
>
> <meta name="keywords" content="HTML, CSS, XML, XHTML, JavaScript">
> 为网页定义描述内容:
> <meta name="description" content="免费 Web & 编程 教程">
> 定义网页作者:
> <meta name="author" content="Runoob">
>
> 5.<script>
>
> <script>标签用于加载脚本文件，如： JavaScript。

![image-20230731101605007](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230731101605007.png)

- **<title>** 元素描述了文档的标题

- **<body>** 元素包含了可见的页面内容

> 注：
>
> 1.在浏览器的页面上使用键盘上的 F12 按键开启调试模式，就可以看到组成标签。
>
> ##### 中文编码：
>
> 2.目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。
>
> 3.平时在编写代码时，统一采用UTF-8最稳妥
>
> 4.为了让浏览器在渲染html文件时不犯错误，可以通过meta标签配合charset属性指定字符编码。
>
> **设置语言：**在<html>标签后可以设定属性lang="xx"，来表示可供浏览器解析的语言。
>
> zh-CN表示简体中文
>
> en表示英文

![img](https://upload-images.jianshu.io/upload_images/28917406-cfbd4b5753c4e212.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### **HTML标准结构**

![image-20230924193002685](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230924193002685.png)

![img](https://www.runoob.com/wp-content/uploads/2013/06/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg)

#### **HTML字符编码**

1. 计算机对数据的操作：

存储时，对数据进行：**编码**。

读取时，对数据进行：**解码**。

2. 编码、解码，会遵循一定的规范 —— **字符集**。

3. 字符集有很多中，常见的有（了解）：

> ASCII ：大写字母、小写字母、数字、一些符号，共计128个。
>
> ISO 8859-1 ：在 ASCII 基础上，扩充了一些希腊字符等，共计是256个。
>
> GB2312 ：继续扩充，收录了 6763 个常用汉字、682个字符。
>
> GBK ：收录了的汉字和符号达到 20000+ ，支持繁体中文。
>
> UTF-8 ：包含世界上所有语言的：所有文字与符号。—— 很常用。

4.使用原则是怎样的？

原则1：存储时，务必采用合适的字符编码 。

否则：无法存储，数据会丢失！

原则2：存储时采用哪种方式编码 ，读取时就采用哪种方式解码。

否则：数据错乱（乱码）！

若使用 ISO8859-1 编码存储，在存入的那一刻，就出问题了，因为 ISO8859-1 仅支持英文！

为保证所有的输入，都能正常存储和读取，现在几乎全都采用： UFT-8 编码。

所以我们编写 html 文件时，也都统一用 UFT-8 编码。

5. 总结：

平时编写代码时，统一采用 UTF-8 编码（最稳妥）。

为了让浏览器在渲染 html 文件时，不犯错误，可以通过 meta 标签配合 charset 属性指定字符编码。

#### **HTML排版标签**

指<h1>-<h6>、<p>以及<div>等基本文字标签

当使用上述标签时，标签会对其区域内的字符进行排版形式的显示，效果如下：

这些标签本质上是**预设了css样式的块级元素**

![image-20230924234540000](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230924234540000.png)

> 注意：<p>和<hx>等排版标签无法进行嵌套
>
> <d-iv>标签不受限制
>
> <-p>标签中不能写块元素

![img](https://upload-images.jianshu.io/upload_images/28917406-76afa6a5231bdf10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### **HTML文本标签**

用于包裹：词汇、短语等

通常写在排版标签里

<sp-an>、<str-ong>、<em>

#### HTML图片标签

![image-20231109202108821](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202108821.png)

#### 常见图片格式

.jpg 有损

![image-20231109202329700](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202329700.png)

.png无损

![image-20231109202338847](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202338847.png)

.bmp最大程度保留细节

![image-20231109202355088](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202355088.png)

.gif支持动态图

![image-20231109202417981](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202417981.png)

.webp由谷歌推出，具备上述几种颜色的特点，但兼容性不好

![image-20231109202459283](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202459283.png)

base64转码 用字符表示图片的三维数组

![image-20231109202304784](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202304784.png)

#### 相对路径和绝对路径

![image-20231109202123384](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202123384.png)

![image-20231109202151819](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109202151819.png)

注意，当全局的baseURL没有经过修改时，路径是以浏览器目前显示的网址栏里的url为基准，如https://www.mokie.com,如下方有路径表示为./error，则实际请求路径为https://www.mokie.com/error

#### HTML超链接/唤起指定应用

标签<a-> 行内元素

![image-20231109203315201](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109203315201.png)

![image-20231109203718347](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109203718347.png)

![image-20231109203800085](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20231109203800085.png)

![img](https://upload-images.jianshu.io/upload_images/28917406-0b4d1badc20f720b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 超文本

是一种组织信息的方式，通过超链接将不同的文字、图片等各种信息组织在一起，能从当前阅读的内容，跳转到超链接所指向的内容。

#### HTML列表

<ol-></ol->有序列表 侧重顺序

<ul-><ul->无序列表 不侧重顺序

 	<li-></li->列表项

<dl-></dl->自定义列表

  <dd->和<dt->自定义列表项标签

注意：

1.<li->必须被包括在有序列表和无序列表内，列表内会默认给列表向前增添一定的css样式，列表内不鼓励额外增加除了<li->标签

2.<dd->属于自定义列表的描述标签

<dt->属于标题标签

3.<li->内部可以继续嵌套列表项

![img](https://upload-images.jianshu.io/upload_images/28917406-7e79e616f31f5bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### HTML表格

**基本结构:**

最外层：<table>

表格标题：<caption>

表格头部：<thead>

主体：<tbody>

​				<tr></tr>表示单元行

​				<td></td>和<th></th>表示单元格

（备注：表格头部中用 th ，表格主体、表格脚注中用： td ）

表格脚注:<tfoot>

**属性：**

[table标签]

1.border:边框长度（粗细）

2.width:宽度

3.height:高度

4.cellspacing: 设置单元格之间的间距

![img](https://upload-images.jianshu.io/upload_images/28917406-43e6c6562b38c83e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[thead标签]

height ：设置表格头部高度。

align ： 设置单元格的**水平**对齐方式，可选值如下：

1. left ：左对齐

2. center ：中间对齐

3. right ：右对齐

valign ：设置单元格的**垂直**对齐方式，可选值如下：

1. top ：顶部对齐

2. middle ：中间对齐

3. bottom ：底部对齐

[tbody]、[tr]、[tfoot]属性与thead相同

[td、th标签]

![img](https://upload-images.jianshu.io/upload_images/28917406-48ab1f051ec77122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

注意点：

1.  border 属性可以控制表格边框，但 border 值的大小，并不控制单元格边框的宽度，只能控制表格最外侧边框的宽度，这个问题如何解决？—— 后期靠 CSS 控制。

2. 默认情况下，每列的宽度，得看这一列单元格最长的那个文字。

3. 给某个 th 或 td 设置了宽度之后，他们所在的那一列的宽度就确定了。

4. 给某个 th 或 td 设置了高度之后，他们所在的那一行的高度就确定了。

#### HTML语义化 

概念：用特定的标签，去表达特定的含义。 

原则：标签的默认效果不重要（后期可以通过 CSS 随便控制效果），语义最重要！ 

举例：对于 h1 标签，效果是文字很大（不重要），语义是网页主要内容（很重要）。

用特义的标签名字表示相关的标签内容，叫做HTML语义化

如想要显示标题，最好用<hx>代替<div>

> 优点：
>
> 1.搜索引擎优化SEO
>
> 2.代码可读性强
>
> 3.方便设备解析

####  HTML块级元素

大多数 HTML 元素被定义为**块级元素**。

- 块级元素在浏览器显示时，通常会以新行来开始（和结束）。
- 块级元素可以自由定义高度和宽度
- 一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。
- 不同的块级元素标签可以创建带有一定样式的DOM元素
- 排版标签都是块级元素

```html
<address>
联系方式信息。
<article>
文章内容。
<aside>
伴随内容。
<blockquote>
块引用。
<dd>
定义列表中定义条目描述。
<div>
文档分区。
<dl>
定义列表。
<fieldset>
表单元素分组。
<figcaption>
图文信息组标题
<figure>
图文信息组 (参照 <figcaption>)。
<footer>
区段尾或页尾。
<form>
表单。
<h1> (en-US), <h2> (en-US), <h3> (en-US), <h4> (en-US), <h5> (en-US), <h6> (en-US)
标题级别 1-6.
<header>
区段头或页头。
<hgroup>
标题组。
<hr>
水平分割线。
<ol>
有序列表。
<ul>
无序列表。
<p>
行。
<pre>
预格式化文本。
<section>
一个页面区段。
<table>
表格。
#属性
##border 定义边框的粗细
#<tr>伴随块状元素，定义表格有多少行，在不添加其他样式的情况下，有多少个就由多少行，并占满整个表格的高度
#<td>伴随块状元素，定义表格有多少列，在不添加其他样式的情况下，有多少个就由多少列，并占满整个表格的宽度
#<th>伴随块状元素，表示表头，元素内文字加粗居中，与<td>并列
<iframe>
通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。
#属性
##loading
##src 要显示资源的url地址
##width 宽度
##height 高度
```

#### HTML内联元素

- [行内元素](https://so.csdn.net/so/search?q=行内元素&spm=1001.2101.3001.7020)也可以叫做内联元素（inline element），
- 行内元素与其他元素在一行上，
- 一般情况下高、边距和宽度不可以改变，但某些空元素标签可以
- 内联元素只能容纳文本或者其他内联元素

```html
<span>...</span>定义文本内区块
<abbr>缩写
<a>...</a>链接
#属性
##href 描述链接的地址。
默认情况下，链接将以以下形式出现在浏览器中：
一个未访问过的链接显示为蓝色字体并带有下划线,访问过的链接显示为紫色并带有下划线,点击链接时，链接显示为红色并带有下划线。
注意：如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示。
#属性
##href 访问资源的url
##id 可用于创建一个 HTML 文档书签
<br>换行
<b>...</b>加粗
<cite>...</cite>作品标题
<strong>...</strong>加粗
<img >图片
#属性
##src 访问资源的url
##alt 替换文本，在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。
##weight 无需style，可以直接指定宽度
##height 无需style，可以直接指定高度
<sup>...</sup>上标
<sub>...</sub>下标
<i>...</i>斜体
<em>...</em>斜体
<del>...</del>删除线
<u>...</u>下划线
<input>...</input>文本框
<textarea>...</textarea>多行文本
<select>...</select>下拉列表
```

> 块级元素和内联元素本质上都是渲染成一个本身带有（默认具有一定css样式）包装盒子（容器），盒子里可以装着其它容器。
>
> 元素的样式由属性style决定
>
> 一般情况下，非空元素的内联元素的宽高以内部的HTML为主
>
> 没有标签的文字一般视为无样式的内联元素（span）
>
> 内联元素本身就为渲染html文字而存在，又称文字容器，而块状元素为布局和页面分区而存在
>
> 内联元素对应的DOM对象只有一个链接属性字符串，而块状元素链接属性只有包含的对象

#### 特殊标签/元素补充

![img](https://upload-images.jianshu.io/upload_images/28917406-007e1ed70066dc3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### HTML表单

概念：一个包含交互的区域，用于收集用户提供的数据。

#####  **常用表单控件**

**① 文本输入框**

```html
<input type="text">
```

常用属性如下：

name 属性：数据的名称。

value 属性：输入框的默认输入值。

maxlength 属性：输入框最大可输入长度。

**② 密码输入框**

```html
<input type="password">
```

常用属性如下：

name 属性：数据的名称。

value 属性：输入框的默认输入值（一般不用，无意义）。

maxlength 属性：输入框最大可输入长度。

**③ 单选框**

```html
<input type="radio" name="sex" value="female">女
<input type="radio" name="sex" value="male">男
```

常用属性如下：

name 属性：数据的名称，注意：想要单选效果，多个 radio 的 name 属性值要保持一致。

value 属性：提交的数据值。

checked 属性：让该单选按钮默认选中。

**④ 复选框**

常用属性如下：

name 属性：数据的名称。

value 属性：提交的数据值。

checked 属性：让该复选框默认选中。

```html
<input type="checkbox" name="hobby" value="smoke" checked>抽烟

<input type="checkbox" name="hobby" value="drink">喝酒

<input type="checkbox" name="hobby" value="perm">烫头
```

**⑤ 隐藏域**

```html
<input type="hidden" name="tag" value="100">
```

用户不可见的一个输入区域，作用是： 提交表单的时候，携带一些固定的数据。

name 属性：指定数据的名称。

value 属性：指定的是真正提交的数据。

**⑥ 提交按钮**

```html
<input type="hidden" name="tag" value="100">
```

注意：

1. button 标签 type 属性的默认值是 submit 。

2. button 不要指定 name 属性

3. input 标签编写的按钮，使用 value 属性指定按钮文字。

**⑦ 重置按钮**

```html
<input type="reset" value="点我重置"><button type="reset">点我重置</button>
```

注意点：

1. button 不要指定 name 属性

2. input 标签编写的按钮，使用 value 属性指定按钮文字。

**⑧ 普通按钮**

```html
<input type="button" value="普通按钮">
<button type="button">普通按钮</button>
```

注意点：普通按钮的 type 值为 button ，若不写 type 值是 submit 会引起表单的提交。

**⑨文本域**

```html
<textarea name="msg" rows="22" cols="3">我是文本域</textarea>
```

常用属性如下：

1. rows 属性：指定默认显示的行数，会影响文本域的高度。

2. cols 属性：指定默认显示的列数，会影响文本域的宽度。

3. 不能编写 type 属性，其他属性，与普通文本输入框一致。

**⑩ 下拉框**

```html
<select name="from">
<option value="黑">黑龙江</option>
<option value="辽">辽宁</option>
<option value="吉">吉林</option>
<option value="粤" selected>广东</option>
</select>
```

1. name 属性：指定数据的名称。

2. option 标签设置 value 属性， 如果没有 value 属性，提交的数据是 option 中间的文字；如果设置了 value 属性，提交的数据就是 value 的值（建议设置 value 属性）

3. option 标签设置了 selected 属性，表示默认选中。

**总结各种input类型**：

```html
<input type="button">
<input type="checkbox">
<input type="color">
<input type="date">
<input type="datetime-local">
<input type="email">
<input type="file">
<input type="hidden">
<input type="image">
<input type="month">
<input type="number">
<input type="password">
<input type="radio">
<input type="range">
<input type="reset">
<input type="search">
<input type="submit">
<input type="tel">
<input type="text">
<input type="time">
<input type="url">
<input type="week">
```

##### **禁用表单控件**

给表单控件的标签设置 disabled 可禁用表单控件。

input 、 textarea 、 button 、 select 、 option 都可以设置 disabled 属性

##### **label** **标签**

label 标签可与表单控件相关联，关联之后点击文字，与之对应的表单控件就会获取焦点。

两种与 label 关联方式如下：

1. 让 label 标签的 for 属性的值等于表单控件的 id 。

2. 把表单控件套在 label 标签的里面。

![img](https://upload-images.jianshu.io/upload_images/28917406-b9e3dcb16199fbfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 总结

![img](https://upload-images.jianshu.io/upload_images/28917406-d465d39287cee59c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### HTML框架

![img](https://upload-images.jianshu.io/upload_images/28917406-ad3e17dad6d5b0c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### HTML实体

在 HTML 中我们可以用一种**特殊的形式**的内容，来表示某个**符号**，这种特殊形式的内容，就是 HTML 实

体。比如小于号 < 用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须

在 HTML 源码中插入字符实体。

**字符实体**由三部分组成：一个 & 和 一个实体名称（或者一个 # 和 一个实体编号），最后加上一个分号 **;** 

常见字符实体总结：

![img](https://upload-images.jianshu.io/upload_images/28917406-d5f92d95c0d911cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### HTML颜色

| 颜色名                                                       | HEX                                                        | Color |
| :----------------------------------------------------------- | :--------------------------------------------------------- | :---- |
| [AliceBlue](https://www.runoob.com/try/color.php?color=AliceBlue) | [#F0F8FF](https://www.runoob.com/try/color.php?hex=F0F8FF) |       |
| [AntiqueWhite](https://www.runoob.com/try/color.php?color=AntiqueWhite) | [#FAEBD7](https://www.runoob.com/try/color.php?hex=FAEBD7) |       |
| [Aqua](https://www.runoob.com/try/color.php?color=Aqua)      | [#00FFFF](https://www.runoob.com/try/color.php?hex=00FFFF) |       |
| [Aquamarine](https://www.runoob.com/try/color.php?color=Aquamarine) | [#7FFFD4](https://www.runoob.com/try/color.php?hex=7FFFD4) |       |
| [Azure](https://www.runoob.com/try/color.php?color=Azure)    | [#F0FFFF](https://www.runoob.com/try/color.php?hex=F0FFFF) |       |
| [Beige](https://www.runoob.com/try/color.php?color=Beige)    | [#F5F5DC](https://www.runoob.com/try/color.php?hex=F5F5DC) |       |
| [Bisque](https://www.runoob.com/try/color.php?color=Bisque)  | [#FFE4C4](https://www.runoob.com/try/color.php?hex=FFE4C4) |       |
| [Black](https://www.runoob.com/try/color.php?color=Black)    | [#000000](https://www.runoob.com/try/color.php?hex=000000) |       |
| [BlanchedAlmond](https://www.runoob.com/try/color.php?color=BlanchedAlmond) | [#FFEBCD](https://www.runoob.com/try/color.php?hex=FFEBCD) |       |
| [Blue](https://www.runoob.com/try/color.php?color=Blue)      | [#0000FF](https://www.runoob.com/try/color.php?hex=0000FF) |       |
| [BlueViolet](https://www.runoob.com/try/color.php?color=BlueViolet) | [#8A2BE2](https://www.runoob.com/try/color.php?hex=8A2BE2) |       |
| [Brown](https://www.runoob.com/try/color.php?color=Brown)    | [#A52A2A](https://www.runoob.com/try/color.php?hex=A52A2A) |       |
| [BurlyWood](https://www.runoob.com/try/color.php?color=BurlyWood) | [#DEB887](https://www.runoob.com/try/color.php?hex=DEB887) |       |
| [CadetBlue](https://www.runoob.com/try/color.php?color=CadetBlue) | [#5F9EA0](https://www.runoob.com/try/color.php?hex=5F9EA0) |       |
| [Chartreuse](https://www.runoob.com/try/color.php?color=Chartreuse) | [#7FFF00](https://www.runoob.com/try/color.php?hex=7FFF00) |       |
| [Chocolate](https://www.runoob.com/try/color.php?color=Chocolate) | [#D2691E](https://www.runoob.com/try/color.php?hex=D2691E) |       |
| [Coral](https://www.runoob.com/try/color.php?color=Coral)    | [#FF7F50](https://www.runoob.com/try/color.php?hex=FF7F50) |       |
| [CornflowerBlue](https://www.runoob.com/try/color.php?color=CornflowerBlue) | [#6495ED](https://www.runoob.com/try/color.php?hex=6495ED) |       |
| [Cornsilk](https://www.runoob.com/try/color.php?color=Cornsilk) | [#FFF8DC](https://www.runoob.com/try/color.php?hex=FFF8DC) |       |
| [Crimson](https://www.runoob.com/try/color.php?color=Crimson) | [#DC143C](https://www.runoob.com/try/color.php?hex=DC143C) |       |
| [Cyan](https://www.runoob.com/try/color.php?color=Cyan)      | [#00FFFF](https://www.runoob.com/try/color.php?hex=00FFFF) |       |
| [DarkBlue](https://www.runoob.com/try/color.php?color=DarkBlue) | [#00008B](https://www.runoob.com/try/color.php?hex=00008B) |       |
| [DarkCyan](https://www.runoob.com/try/color.php?color=DarkCyan) | [#008B8B](https://www.runoob.com/try/color.php?hex=008B8B) |       |
| [DarkGoldenRod](https://www.runoob.com/try/color.php?color=DarkGoldenRod) | [#B8860B](https://www.runoob.com/try/color.php?hex=B8860B) |       |
| [DarkGray](https://www.runoob.com/try/color.php?color=DarkGray) | [#A9A9A9](https://www.runoob.com/try/color.php?hex=A9A9A9) |       |
| [DarkGreen](https://www.runoob.com/try/color.php?color=DarkGreen) | [#006400](https://www.runoob.com/try/color.php?hex=006400) |       |
| [DarkKhaki](https://www.runoob.com/try/color.php?color=DarkKhaki) | [#BDB76B](https://www.runoob.com/try/color.php?hex=BDB76B) |       |
| [DarkMagenta](https://www.runoob.com/try/color.php?color=DarkMagenta) | [#8B008B](https://www.runoob.com/try/color.php?hex=8B008B) |       |
| [DarkOliveGreen](https://www.runoob.com/try/color.php?color=DarkOliveGreen) | [#556B2F](https://www.runoob.com/try/color.php?hex=556B2F) |       |
| [DarkOrange](https://www.runoob.com/try/color.php?color=DarkOrange) | [#FF8C00](https://www.runoob.com/try/color.php?hex=FF8C00) |       |
| [DarkOrchid](https://www.runoob.com/try/color.php?color=DarkOrchid) | [#9932CC](https://www.runoob.com/try/color.php?hex=9932CC) |       |
| [DarkRed](https://www.runoob.com/try/color.php?color=DarkRed) | [#8B0000](https://www.runoob.com/try/color.php?hex=8B0000) |       |
| [DarkSalmon](https://www.runoob.com/try/color.php?color=DarkSalmon) | [#E9967A](https://www.runoob.com/try/color.php?hex=E9967A) |       |
| [DarkSeaGreen](https://www.runoob.com/try/color.php?color=DarkSeaGreen) | [#8FBC8F](https://www.runoob.com/try/color.php?hex=8FBC8F) |       |
| [DarkSlateBlue](https://www.runoob.com/try/color.php?color=DarkSlateBlue) | [#483D8B](https://www.runoob.com/try/color.php?hex=483D8B) |       |
| [DarkSlateGray](https://www.runoob.com/try/color.php?color=DarkSlateGray) | [#2F4F4F](https://www.runoob.com/try/color.php?hex=2F4F4F) |       |
| [DarkTurquoise](https://www.runoob.com/try/color.php?color=DarkTurquoise) | [#00CED1](https://www.runoob.com/try/color.php?hex=00CED1) |       |
| [DarkViolet](https://www.runoob.com/try/color.php?color=DarkViolet) | [#9400D3](https://www.runoob.com/try/color.php?hex=9400D3) |       |
| [DeepPink](https://www.runoob.com/try/color.php?color=DeepPink) | [#FF1493](https://www.runoob.com/try/color.php?hex=FF1493) |       |
| [DeepSkyBlue](https://www.runoob.com/try/color.php?color=DeepSkyBlue) | [#00BFFF](https://www.runoob.com/try/color.php?hex=00BFFF) |       |
| [DimGray](https://www.runoob.com/try/color.php?color=DimGray) | [#696969](https://www.runoob.com/try/color.php?hex=696969) |       |
| [DodgerBlue](https://www.runoob.com/try/color.php?color=DodgerBlue) | [#1E90FF](https://www.runoob.com/try/color.php?hex=1E90FF) |       |
| [FireBrick](https://www.runoob.com/try/color.php?color=FireBrick) | [#B22222](https://www.runoob.com/try/color.php?hex=B22222) |       |
| [FloralWhite](https://www.runoob.com/try/color.php?color=FloralWhite) | [#FFFAF0](https://www.runoob.com/try/color.php?hex=FFFAF0) |       |
| [ForestGreen](https://www.runoob.com/try/color.php?color=ForestGreen) | [#228B22](https://www.runoob.com/try/color.php?hex=228B22) |       |
| [Fuchsia](https://www.runoob.com/try/color.php?color=Fuchsia) | [#FF00FF](https://www.runoob.com/try/color.php?hex=FF00FF) |       |
| [Gainsboro](https://www.runoob.com/try/color.php?color=Gainsboro) | [#DCDCDC](https://www.runoob.com/try/color.php?hex=DCDCDC) |       |
| [GhostWhite](https://www.runoob.com/try/color.php?color=GhostWhite) | [#F8F8FF](https://www.runoob.com/try/color.php?hex=F8F8FF) |       |
| [Gold](https://www.runoob.com/try/color.php?color=Gold)      | [#FFD700](https://www.runoob.com/try/color.php?hex=FFD700) |       |
| [GoldenRod](https://www.runoob.com/try/color.php?color=GoldenRod) | [#DAA520](https://www.runoob.com/try/color.php?hex=DAA520) |       |
| [Gray](https://www.runoob.com/try/color.php?color=Gray)      | [#808080](https://www.runoob.com/try/color.php?hex=808080) |       |
| [Green](https://www.runoob.com/try/color.php?color=Green)    | [#008000](https://www.runoob.com/try/color.php?hex=008000) |       |
| [GreenYellow](https://www.runoob.com/try/color.php?color=GreenYellow) | [#ADFF2F](https://www.runoob.com/try/color.php?hex=ADFF2F) |       |
| [HoneyDew](https://www.runoob.com/try/color.php?color=HoneyDew) | [#F0FFF0](https://www.runoob.com/try/color.php?hex=F0FFF0) |       |
| [HotPink](https://www.runoob.com/try/color.php?color=HotPink) | [#FF69B4](https://www.runoob.com/try/color.php?hex=FF69B4) |       |
| [IndianRed ](https://www.runoob.com/try/color.php?color=IndianRed) | [#CD5C5C](https://www.runoob.com/try/color.php?hex=CD5C5C) |       |
| [Indigo ](https://www.runoob.com/try/color.php?color=Indigo) | [#4B0082](https://www.runoob.com/try/color.php?hex=4B0082) |       |
| [Ivory](https://www.runoob.com/try/color.php?color=Ivory)    | [#FFFFF0](https://www.runoob.com/try/color.php?hex=FFFFF0) |       |
| [Khaki](https://www.runoob.com/try/color.php?color=Khaki)    | [#F0E68C](https://www.runoob.com/try/color.php?hex=F0E68C) |       |
| [Lavender](https://www.runoob.com/try/color.php?color=Lavender) | [#E6E6FA](https://www.runoob.com/try/color.php?hex=E6E6FA) |       |
| [LavenderBlush](https://www.runoob.com/try/color.php?color=LavenderBlush) | [#FFF0F5](https://www.runoob.com/try/color.php?hex=FFF0F5) |       |
| [LawnGreen](https://www.runoob.com/try/color.php?color=LawnGreen) | [#7CFC00](https://www.runoob.com/try/color.php?hex=7CFC00) |       |
| [LemonChiffon](https://www.runoob.com/try/color.php?color=LemonChiffon) | [#FFFACD](https://www.runoob.com/try/color.php?hex=FFFACD) |       |
| [LightBlue](https://www.runoob.com/try/color.php?color=LightBlue) | [#ADD8E6](https://www.runoob.com/try/color.php?hex=ADD8E6) |       |
| [LightCoral](https://www.runoob.com/try/color.php?color=LightCoral) | [#F08080](https://www.runoob.com/try/color.php?hex=F08080) |       |
| [LightCyan](https://www.runoob.com/try/color.php?color=LightCyan) | [#E0FFFF](https://www.runoob.com/try/color.php?hex=E0FFFF) |       |
| [LightGoldenRodYellow](https://www.runoob.com/try/color.php?color=LightGoldenRodYellow) | [#FAFAD2](https://www.runoob.com/try/color.php?hex=FAFAD2) |       |
| [LightGray](https://www.runoob.com/try/color.php?color=LightGray) | [#D3D3D3](https://www.runoob.com/try/color.php?hex=D3D3D3) |       |
| [LightGreen](https://www.runoob.com/try/color.php?color=LightGreen) | [#90EE90](https://www.runoob.com/try/color.php?hex=90EE90) |       |
| [LightPink](https://www.runoob.com/try/color.php?color=LightPink) | [#FFB6C1](https://www.runoob.com/try/color.php?hex=FFB6C1) |       |
| [LightSalmon](https://www.runoob.com/try/color.php?color=LightSalmon) | [#FFA07A](https://www.runoob.com/try/color.php?hex=FFA07A) |       |
| [LightSeaGreen](https://www.runoob.com/try/color.php?color=LightSeaGreen) | [#20B2AA](https://www.runoob.com/try/color.php?hex=20B2AA) |       |
| [LightSkyBlue](https://www.runoob.com/try/color.php?color=LightSkyBlue) | [#87CEFA](https://www.runoob.com/try/color.php?hex=87CEFA) |       |
| [LightSlateGray](https://www.runoob.com/try/color.php?color=LightSlateGray) | [#778899](https://www.runoob.com/try/color.php?hex=778899) |       |
| [LightSteelBlue](https://www.runoob.com/try/color.php?color=LightSteelBlue) | [#B0C4DE](https://www.runoob.com/try/color.php?hex=B0C4DE) |       |
| [LightYellow](https://www.runoob.com/try/color.php?color=LightYellow) | [#FFFFE0](https://www.runoob.com/try/color.php?hex=FFFFE0) |       |
| [Lime](https://www.runoob.com/try/color.php?color=Lime)      | [#00FF00](https://www.runoob.com/try/color.php?hex=00FF00) |       |
| [LimeGreen](https://www.runoob.com/try/color.php?color=LimeGreen) | [#32CD32](https://www.runoob.com/try/color.php?hex=32CD32) |       |
| [Linen](https://www.runoob.com/try/color.php?color=Linen)    | [#FAF0E6](https://www.runoob.com/try/color.php?hex=FAF0E6) |       |
| [Magenta](https://www.runoob.com/try/color.php?color=Magenta) | [#FF00FF](https://www.runoob.com/try/color.php?hex=FF00FF) |       |
| [Maroon](https://www.runoob.com/try/color.php?color=Maroon)  | [#800000](https://www.runoob.com/try/color.php?hex=800000) |       |
| [MediumAquaMarine](https://www.runoob.com/try/color.php?color=MediumAquaMarine) | [#66CDAA](https://www.runoob.com/try/color.php?hex=66CDAA) |       |
| [MediumBlue](https://www.runoob.com/try/color.php?color=MediumBlue) | [#0000CD](https://www.runoob.com/try/color.php?hex=0000CD) |       |
| [MediumOrchid](https://www.runoob.com/try/color.php?color=MediumOrchid) | [#BA55D3](https://www.runoob.com/try/color.php?hex=BA55D3) |       |
| [MediumPurple](https://www.runoob.com/try/color.php?color=MediumPurple) | [#9370DB](https://www.runoob.com/try/color.php?hex=9370DB) |       |
| [MediumSeaGreen](https://www.runoob.com/try/color.php?color=MediumSeaGreen) | [#3CB371](https://www.runoob.com/try/color.php?hex=3CB371) |       |
| [MediumSlateBlue](https://www.runoob.com/try/color.php?color=MediumSlateBlue) | [#7B68EE](https://www.runoob.com/try/color.php?hex=7B68EE) |       |
| [MediumSpringGreen](https://www.runoob.com/try/color.php?color=MediumSpringGreen) | [#00FA9A](https://www.runoob.com/try/color.php?hex=00FA9A) |       |
| [MediumTurquoise](https://www.runoob.com/try/color.php?color=MediumTurquoise) | [#48D1CC](https://www.runoob.com/try/color.php?hex=48D1CC) |       |
| [MediumVioletRed](https://www.runoob.com/try/color.php?color=MediumVioletRed) | [#C71585](https://www.runoob.com/try/color.php?hex=C71585) |       |
| [MidnightBlue](https://www.runoob.com/try/color.php?color=MidnightBlue) | [#191970](https://www.runoob.com/try/color.php?hex=191970) |       |
| [MintCream](https://www.runoob.com/try/color.php?color=MintCream) | [#F5FFFA](https://www.runoob.com/try/color.php?hex=F5FFFA) |       |
| [MistyRose](https://www.runoob.com/try/color.php?color=MistyRose) | [#FFE4E1](https://www.runoob.com/try/color.php?hex=FFE4E1) |       |
| [Moccasin](https://www.runoob.com/try/color.php?color=Moccasin) | [#FFE4B5](https://www.runoob.com/try/color.php?hex=FFE4B5) |       |
| [NavajoWhite](https://www.runoob.com/try/color.php?color=NavajoWhite) | [#FFDEAD](https://www.runoob.com/try/color.php?hex=FFDEAD) |       |
| [Navy](https://www.runoob.com/try/color.php?color=Navy)      | [#000080](https://www.runoob.com/try/color.php?hex=000080) |       |
| [OldLace](https://www.runoob.com/try/color.php?color=OldLace) | [#FDF5E6](https://www.runoob.com/try/color.php?hex=FDF5E6) |       |
| [Olive](https://www.runoob.com/try/color.php?color=Olive)    | [#808000](https://www.runoob.com/try/color.php?hex=808000) |       |
| [OliveDrab](https://www.runoob.com/try/color.php?color=OliveDrab) | [#6B8E23](https://www.runoob.com/try/color.php?hex=6B8E23) |       |
| [Orange](https://www.runoob.com/try/color.php?color=Orange)  | [#FFA500](https://www.runoob.com/try/color.php?hex=FFA500) |       |
| [OrangeRed](https://www.runoob.com/try/color.php?color=OrangeRed) | [#FF4500](https://www.runoob.com/try/color.php?hex=FF4500) |       |
| [Orchid](https://www.runoob.com/try/color.php?color=Orchid)  | [#DA70D6](https://www.runoob.com/try/color.php?hex=DA70D6) |       |
| [PaleGoldenRod](https://www.runoob.com/try/color.php?color=PaleGoldenRod) | [#EEE8AA](https://www.runoob.com/try/color.php?hex=EEE8AA) |       |
| [PaleGreen](https://www.runoob.com/try/color.php?color=PaleGreen) | [#98FB98](https://www.runoob.com/try/color.php?hex=98FB98) |       |
| [PaleTurquoise](https://www.runoob.com/try/color.php?color=PaleTurquoise) | [#AFEEEE](https://www.runoob.com/try/color.php?hex=AFEEEE) |       |
| [PaleVioletRed](https://www.runoob.com/try/color.php?color=PaleVioletRed) | [#DB7093](https://www.runoob.com/try/color.php?hex=DB7093) |       |
| [PapayaWhip](https://www.runoob.com/try/color.php?color=PapayaWhip) | [#FFEFD5](https://www.runoob.com/try/color.php?hex=FFEFD5) |       |
| [PeachPuff](https://www.runoob.com/try/color.php?color=PeachPuff) | [#FFDAB9](https://www.runoob.com/try/color.php?hex=FFDAB9) |       |
| [Peru](https://www.runoob.com/try/color.php?color=Peru)      | [#CD853F](https://www.runoob.com/try/color.php?hex=CD853F) |       |
| [Pink](https://www.runoob.com/try/color.php?color=Pink)      | [#FFC0CB](https://www.runoob.com/try/color.php?hex=FFC0CB) |       |
| [Plum](https://www.runoob.com/try/color.php?color=Plum)      | [#DDA0DD](https://www.runoob.com/try/color.php?hex=DDA0DD) |       |
| [PowderBlue](https://www.runoob.com/try/color.php?color=PowderBlue) | [#B0E0E6](https://www.runoob.com/try/color.php?hex=B0E0E6) |       |
| [Purple](https://www.runoob.com/try/color.php?color=Purple)  | [#800080](https://www.runoob.com/try/color.php?hex=800080) |       |
| [Red](https://www.runoob.com/try/color.php?color=Red)        | [#FF0000](https://www.runoob.com/try/color.php?hex=FF0000) |       |
| [RosyBrown](https://www.runoob.com/try/color.php?color=RosyBrown) | [#BC8F8F](https://www.runoob.com/try/color.php?hex=BC8F8F) |       |
| [RoyalBlue](https://www.runoob.com/try/color.php?color=RoyalBlue) | [#4169E1](https://www.runoob.com/try/color.php?hex=4169E1) |       |
| [SaddleBrown](https://www.runoob.com/try/color.php?color=SaddleBrown) | [#8B4513](https://www.runoob.com/try/color.php?hex=8B4513) |       |
| [Salmon](https://www.runoob.com/try/color.php?color=Salmon)  | [#FA8072](https://www.runoob.com/try/color.php?hex=FA8072) |       |
| [SandyBrown](https://www.runoob.com/try/color.php?color=SandyBrown) | [#F4A460](https://www.runoob.com/try/color.php?hex=F4A460) |       |
| [SeaGreen](https://www.runoob.com/try/color.php?color=SeaGreen) | [#2E8B57](https://www.runoob.com/try/color.php?hex=2E8B57) |       |
| [SeaShell](https://www.runoob.com/try/color.php?color=SeaShell) | [#FFF5EE](https://www.runoob.com/try/color.php?hex=FFF5EE) |       |
| [Sienna](https://www.runoob.com/try/color.php?color=Sienna)  | [#A0522D](https://www.runoob.com/try/color.php?hex=A0522D) |       |
| [Silver](https://www.runoob.com/try/color.php?color=Silver)  | [#C0C0C0](https://www.runoob.com/try/color.php?hex=C0C0C0) |       |
| [SkyBlue](https://www.runoob.com/try/color.php?color=SkyBlue) | [#87CEEB](https://www.runoob.com/try/color.php?hex=87CEEB) |       |
| [SlateBlue](https://www.runoob.com/try/color.php?color=SlateBlue) | [#6A5ACD](https://www.runoob.com/try/color.php?hex=6A5ACD) |       |
| [SlateGray](https://www.runoob.com/try/color.php?color=SlateGray) | [#708090](https://www.runoob.com/try/color.php?hex=708090) |       |
| [Snow](https://www.runoob.com/try/color.php?color=Snow)      | [#FFFAFA](https://www.runoob.com/try/color.php?hex=FFFAFA) |       |
| [SpringGreen](https://www.runoob.com/try/color.php?color=SpringGreen) | [#00FF7F](https://www.runoob.com/try/color.php?hex=00FF7F) |       |
| [SteelBlue](https://www.runoob.com/try/color.php?color=SteelBlue) | [#4682B4](https://www.runoob.com/try/color.php?hex=4682B4) |       |
| [Tan](https://www.runoob.com/try/color.php?color=Tan)        | [#D2B48C](https://www.runoob.com/try/color.php?hex=D2B48C) |       |
| [Teal](https://www.runoob.com/try/color.php?color=Teal)      | [#008080](https://www.runoob.com/try/color.php?hex=008080) |       |
| [Thistle](https://www.runoob.com/try/color.php?color=Thistle) | [#D8BFD8](https://www.runoob.com/try/color.php?hex=D8BFD8) |       |
| [Tomato](https://www.runoob.com/try/color.php?color=Tomato)  | [#FF6347](https://www.runoob.com/try/color.php?hex=FF6347) |       |
| [Turquoise](https://www.runoob.com/try/color.php?color=Turquoise) | [#40E0D0](https://www.runoob.com/try/color.php?hex=40E0D0) |       |
| [Violet](https://www.runoob.com/try/color.php?color=Violet)  | [#EE82EE](https://www.runoob.com/try/color.php?hex=EE82EE) |       |
| [Wheat](https://www.runoob.com/try/color.php?color=Wheat)    | [#F5DEB3](https://www.runoob.com/try/color.php?hex=F5DEB3) |       |
| [White](https://www.runoob.com/try/color.php?color=White)    | [#FFFFFF](https://www.runoob.com/try/color.php?hex=FFFFFF) |       |
| [WhiteSmoke](https://www.runoob.com/try/color.php?color=WhiteSmoke) | [#F5F5F5](https://www.runoob.com/try/color.php?hex=F5F5F5) |       |
| [Yellow](https://www.runoob.com/try/color.php?color=Yellow)  | [#FFFF00](https://www.runoob.com/try/color.php?hex=FFFF00) |       |
| [YellowGreen](https://www.runoob.com/try/color.php?color=YellowGreen) | [#9ACD32](https://www.runoob.com/try/color.php?hex=9ACD32) |       |

### HTML5

HTML5 是新一代的 HTML 标准，2014年10月由万维网联盟（ W3C ）完成标准制定。

官网地址：

W3C 提供： **https://www.w3.org/TR/html/index.html**

WHATWG 提供：**https://whatwg-cn.github.io/html/multipage**

HTML5 在狭义上是指新一代的 HTML 标准，在广义上是指：整个前端。

#### **HTML5** **优势**

1. 针对 JavaScript ，新增了很多可操作的接口。

2. 新增了一些语义化标签、全局属性。

3. 新增了多媒体标签，可以很好的替代 flash 。

4. 更加侧重语义化，对于 SEO 更友好。

5. 可移植性好，可以大量应用在移动设备上。

#### 新增标签

##### 布局标签

![img](https://upload-images.jianshu.io/upload_images/28917406-1f67c8cc74cb332d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 关于 article 和 section ：
>
> 1. artical 里面可以有多个 section 。
>
> 2. section 强调的是分段或分块，如果你想将一块内容分成几段的时候，可使用 section 元素。
>
> 3. article 比 section 更强调独立性，一块内容如果比较独立、比较完整，应该使用article 元素。

##### <-meter>

语义：定义已知范围内的标量测量。也被称为 gauge （尺度），双标签，例如：电量、磁盘用量等。

常用属性:

![img](https://upload-images.jianshu.io/upload_images/28917406-37dba183404bc031.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### <**progress**>

语义：显示某个任务完成的进度的指示器，一般用于表示进度条，双标签，例如：工作完成进度等

常用属性如下：

![img](https://upload-images.jianshu.io/upload_images/28917406-9d9265be9f366cd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 列表标签

![img](https://upload-images.jianshu.io/upload_images/28917406-306b76707e90ae24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### **文本标签**

![img](https://upload-images.jianshu.io/upload_images/28917406-2d3ab30218901166.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 视频标签

<-video> 标签用来定义视频，它是双标签。

**属性**

![img](https://upload-images.jianshu.io/upload_images/28917406-4523267cdb49ce0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 音频标签

<-audio> 标签用来定义音频，它是双标签。

**属性**

![img](https://upload-images.jianshu.io/upload_images/28917406-18cfbab0b49f19c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 新增属性

##### 全局属性

![img](https://upload-images.jianshu.io/upload_images/28917406-ef7e9b6cc3d4973a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 所有表单控件

![img](https://upload-images.jianshu.io/upload_images/28917406-f20581e7fc004895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### <-input>独占

![img](https://upload-images.jianshu.io/upload_images/28917406-9ce21a1c6ed4063c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### <-form>独占

![img](https://upload-images.jianshu.io/upload_images/28917406-0bba4b724679153e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 兼容性处理

![img](https://upload-images.jianshu.io/upload_images/28917406-42b0c20af0e3bb40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

示例：

```html
<!--设置IE总是使用最新的文档模式进行渲染-->

<meta http-equiv="X-UA-Compatible" content="IE=Edge">

<!--优先使用 webkit ( Chromium ) 内核进行渲染, 针对360等壳浏览器-->

<meta name="renderer" content="webkit">

<!--[if lt ie 9]>

<script src="../sources/js/html5shiv.js"></script>

<![endif]--><!--[if IE 8]>仅IE8可见<![endif]-->

<!--[if gt IE 8]>仅IE8以上可见<![endif]—>

<!--[if lt IE 8]>仅IE8以下可见<![endif]—>

<!--[if gte IE 8]>IE8及以上可见<![endif]—>

<!--[if lte IE 8]>IE8及以下可见<![endif]—>

<!--[if !IE 8]>非IE8的IE可见<![endif]-->
```

## CSS

### 定义

CSS 的全称为：层叠样式表 ( Cascading Style Sheets ) 。

CSS 也是一种标记语言，用于给 HTML 结构设置样式，例如：文字大小、颜色、元素宽高等等。

简单理解： CSS 可以美化 HTML , 让 HTML 更漂亮。

核心思想： HTML 搭建结构， CSS 添加样式，实现了：结构与样式的分离。

### CSS的编写位置

#### **行内样式**

写在标签的 style 属性中，（又称：内联样式）。

```html
<h1 style="color:red;font-size:60px;">欢迎来到福州大学</h1>
```

> 注意点：
>
> 1. style 属性的值不能随便写，写要符合 CSS 语法规范，是 名:值; 的形式。
>
> 2. 行内样式表，只能控制当前标签的样式，对其他标签无效。

存在的问题：

书写繁琐、样式不能复用、并且没有体现出：**结构与样式分离** 的思想，不推荐大量使用，只有对当前元素添加简单样式时，才偶尔使用。

#### **内部样式**

写在 html 页面内部，将所有的 CSS 代码提取出来，单独放在 <style> 标签中。

语法：

```css
<style>
h1 {
color: red;
font-size: 40px;
}
</style>
```

1.  <-style> 标签理论上可以放在 HTML 文档的任何地方，但一般都放在 <-head> 标签中。
2. 此种写法：样式可以复用、代码结构清晰。

存在的问题：

1. 并没有实现：结构与样式**完全分离**。

2. 多个 HTML 页面无法复用样式。

#### **外部样式**

写在单独的 .css 文件中，随后在 HTML 文件中引入使用。

语法：

1. 新建一个扩展名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。

   ```css
   h1{
   color: red;
   font-size: 40px;
   }
   ```

2. 在 HTML 文件中引入 .css 文件。

   ```html
   <link rel="stylesheet" href="./xxx.css">
   ```

> 注意点：
>
> 1. <-link> 标签要写在 <-head> 标签中。
>
> 2. <-link> 标签属性说明：
>
> href ：引入的文档来自于哪里。
>
> rel ：( relation ：关系）说明引入的文档与当前文档之间的关系。
>
> 3. 外部样式的优势：样式可以复用、结构清晰、可触发浏览器的缓存机制，提高访问速度 ，实现了结构与样式的完全分离。
>
> 4. 实际开发中，几乎都使用外部样式，这是最推荐的使用方式

**3.** **样式表的优先级**

优先级规则：**行内样式** > **内部样式** = **外部样式**

1. 内部样式、外部样式，这二者的优先级相同，且：后面的 会覆盖 前面的（简记：“后来者居上”）。
2. 同一个样式表中，优先级也和编写顺序有关，且：后面的 会覆盖 前面的（简记：“后来者居上”）。

![img](https://upload-images.jianshu.io/upload_images/28917406-517d69c763733f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 语法规范

CSS 语法规范由两部分构成：

**选择器**：找到要添加样式的元素。

**声明块**：设置具体的样式（**声明块**是由一个或多个**声明**组成的），声明的格式为： **属性名: 属性值;**

> 备注1：最后一个声明后的分号理论上能省略，但最好还是写上。
>
> 备注2：选择器与声明块之间，属性名与属性值之间，均有一个空格，理论上能省略，但最好还是写上。

![img](https://upload-images.jianshu.io/upload_images/28917406-ea5f6d8f58211000.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

注释的写法：

```css
/* 给h1元素添加样式 */

h1 {

/* 设置文字颜色为红色 */

color: red;

/* 设置文字大小为40px */

font-size: 40px

}
```

#### 代码风格

**展开风格** —— 开发时推荐，便于维护和调试。

```css
h1 {
color: red;
font-size: 40px;
}
```

**紧凑风格** —— 项目上线时推荐，可减小文件体积。

```css
h1{color:red;font-size:40px;}
```

项目上线时，我们会通过工具将【展开风格】的代码，变成【紧凑风格】，这样可以减小文件体积，节约网络流量，同时也能让用户打开网页时速度更快。

#### 选择器

##### **通配选择器**

作用：可以选中所有的 HTML 元素。

语法：

```css
* {
属性名: 属性值;
}
```

举例：

```css
/* 选中所有元素 */
* {
color: orange;
font-size: 40px;
}
```

##### 元素选择器

作用：为页面中 **某种元素** 统一设置样式。

语法：

```
标签名 {
属性名: 属性值;
}
```

举例：

```css
/* 选中所有h1元素 */
h1 {
color: orange;
font-size: 40px;
}
/* 选中所有p元素 */
p {
color: blue;
font-size: 60px;
}
```

备注：元素选择器无法实现**差异化设置**，例如上面的代码中，所有的 p 元素效果都一样。

##### **类选择器**

作用：根据元素的 class 值，来选中某些元素。

```
.类名 {
属性名: 属性值;
}
```

举例：

```css
/* 选中所有class值为speak的元素 */
.speak {
color: red;
}
/* 选中所有class值为answer的元素 */
.answer {
color: blue;
}
```

元素的 class 属性值不带 . ，但 CSS 的类选择器要带 . 。

class 值，是我们自定义的，按照标准：不要使用纯数字、不要使用中文、尽量使用

英文与数字的组合，若由多个单词组成，使用 - 做连接，例如： left-menu ，且命名要有意义，做到 “见名知意”。

一个元素不能写多个 class 属性，下面是 错误示例：

```html
<!-- 该写法错误，元素的属性不能重复，后写的会失效 -->
<h1 class="speak" class="big">你好啊</h1>
```

一个元素的 class 属性，能写多个值，要用空格隔开，例如：

```html
<!-- 该写法正确，class属性，能写多个值 -->
<h1 class="speak big">你好啊</h1>
```

##### ID选择器

作用：根据元素的 id 属性值，来**精准的**选中**某个**元素。

语法：

```css
#id值 {
属性名: 属性值;
}
```

举例：

```css
/* 选中id值为earthy的那个元素 */
#earthy {
color: red;
font-size: 60px;
}
```

> 注意：
>
> id 属性值：尽量由**字母、数字、下划线(_ )、短杠(** - **)**组成，最好以字母开头、不要包含空格、区分大小写。
>
> 一个元素只能拥有一个 id 属性，多个元素的 id 属性值不能相同。
>
> 一个元素可以同时拥有 id 和 class 属性。

#### 复合选择器

##### **交集选择器**

作用：选中同时符合多个条件的元素

语法：选择器1选择器2...选择器n{}

举例：

```css
/* 选中：类名为beauty的p元素，为此种写法用的非常多！！！！ */
p.beauty {
color: blue;
}
/* 选中：类名包含rich和beauty的元素 */
.rich.beauty {
color: green;
}
```

> 1. 有标签名，标签名必须写在前面。
>
> 2. id 选择器、通配选择器，理论上可以作为交集的条件，但实际应用中几乎不用 —— 因为没有意义。
>
> 3. 交集选择器中**不可能**出现**两个元素选择器**，因为一个元素，不可能即是 p 元素又是 span 元素。
>
> 4. 用的最多的交集选择器是：元素选择器配合类名选择器，例如： p.beauty 。

##### **并集选择器**

作用：选中多个选择器对应的元素，又称：**分组选择器**。

语法：选择器1,选择器2,...,选择器n{}

举例：

```css
/* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */
#peiqi,
.rich,
.beauty {
font-size: 40px;
background-color: skyblue;
width: 200px;
}
```

##### **后代选择器**

作用：选中指定元素中，符合要求的后代元素

语法：选择器1 选择器2 选择器3 ...... 选择器n {} （先写祖先，再写后代，中间含**空格**）

举例：

```css
/* 选中ul中的所有li */
ul li {
color: red;
}
/* 选中ul中所有li中的a */
ul li a {
color: orange;
}
/* 选中类名为subject元素中的所有li */
.subject li {
color: blue;
}
/* 选中类名为subject元素中的所有类名为front-end的li */
.subject li.front-end {
color: blue;
}
```

> 注意：
>
> 1. 后代选择器，最终选择的是后代，不选中祖先。
>
> 2. 儿子、孙子、重孙子，都算是后代。
>
> 3. 结构一定要符合之前讲的 HTML 嵌套要求，例如：不能 p 中写 h1 ~ h6 。

##### **子代选择器**

作用：选中指定元素中，符合要求的**子**元素（**儿子元素**）。（先写父，再写子）

子代选择器又称：子元素选择器、子选择器。

语法：选择器1 > 选择器2 > 选择器3 > ...... 选择器n {}

选择器之间，用 > 隔开， > 可以理解为：" xxx 的子代"，其实就是儿子的意思。

选择器 1234....n ，可以是我们之前学的任何一种选择器。

```css
/* div中的子代a元素 */
div>a {
color: red;
}
/* 类名为persons的元素中的子代a元素 */
.persons>a{
color: red;
}
```

> 注意：
>
> 1. 子代选择器，最终选择的是子代，不是父级。
>
> 2. 子、孙子、重孙子、重重孙子 ...... 统称后代！，**子**就是指**儿子**。

##### 兄弟选择器

###### 相邻兄弟选择器

作用：选中指定元素后，符合条件的**相邻兄弟**元素。

所谓相邻，就是**紧挨着**他的下一个。

语法： 选择器1+选择器2 {} 。

示例：

```css
/* 选中div后相邻的兄弟p元素 */
div+p {
color:red;
}
```

###### 通用兄弟选择器

作用：选中指定元素后，符合条件的**所有兄弟**元素。（简记：睡在我下铺的所有兄弟）

语法： 选择器1~选择器2 {} 。

实例：

```css
/* 选中div后的所有的兄弟p元素 */
div~p {
color:red;
}
```

注意：两种兄弟选择器，选择的是**下面**的兄弟

##### **属性选择器**

作用：选中属性值符合一定要求的元素。

语法：

1. [属性名] 选中**具有**某个属性的元素。

2. [属性名="值"] 选中包含某个属性，且属性值**等于**指定值的元素。

3. [属性名^="值"] 选中包含某个属性，且属性值以指定的值**开头**的元素。

4. [属性名$="值"] 选中包含某个属性，且属性值以指定的值**结尾**的元素。

5. [属性名*=“值”] 选择包含某个属性，属性值**包含**指定值的元素。

举例：

```css
/* 选中具有title属性的元素 */
div[title]{color:red;}
/* 选中title属性值为atguigu的元素 */
div[title="atguigu"]{color:red;}
/* 选中title属性值以a开头的元素 */
div[title^="a"]{color:red;}
/* 选中title属性值以u结尾的元素 */
div[title$="u"]{color:red;}
/* 选中title属性值包含g的元素 */
div[title*="g"]{color:red;}
```

##### **伪类选择器**

作用：选中特殊状态的元素。

如何理解“伪” ? — 虚假的，不是真的。

如何理解“伪类”？ — 像类( class )，但不是类，是元素的一种特殊状态。

常用的伪类选择器：

###### 动态伪类

1. :link 超链接**未被访问**的状态。

2. :visited 超链接**访问过**的状态。

3. :hover 鼠标**悬停**在元素上的状态。

4. :active 元素**激活**的状态。

> 什么是激活？—— 按下鼠标不松开。
>
> 注意点：遵循 LVHA 的顺序，即： link 、 visited 、 hover 、 active 。

5.:focus 获取焦点的元素。

> 表单类元素才能使用 :focus 伪类。
>
> 当用户：点击元素、触摸元素、或通过键盘的 “ tab ” 键等方式，选择元素时，就是获得焦点。

###### **结构伪类**

**常用的：**

1. :first-child 所有兄弟元素中的**第一个**。

2. :last-child 所有兄弟元素中的**最后一个**。

3. :nth-child(n) 所有兄弟元素中的**第** **n** **个**。

4. :first-of-type 所有**同类型**兄弟元素中的**第一个**。

5. :last-of-type 所有**同类型**兄弟元素中的**最后一个**。

6. :nth-of-type(n) 所有**同类型**兄弟元素中的 **第n个** 。

关于 n 的值：

1. 0 或 不写 ：什么都选不中 —— 几乎不用。

2. n ：选中所有子元素 —— 几乎不用。

3. 1~正无穷的整数 ：选中对应序号的子元素。

4. 2n 或 even ：选中序号为偶数的子元素。

5. 2n+1 或 odd ：选中序号为奇数的子元素。

6. -n+3 ：选中的是前 3 个。

**了解即可：**

1. :nth-last-child(n) 所有兄弟元素中的**倒数第** **n** **个**。

2. :nth-last-of-type(n) 所有**同类型**兄弟元素中的 **倒数第****n****个** 。

3. :only-child 选择没有兄弟的元素（独生子女）。

4. :only-of-type 选择没有**同类型**兄弟的元素。

5. :root 根元素。

6. :empty 内容为空元素（空格也算内容）。

###### **否定伪类**

:not(选择器) 排除满足括号中条件的元素。

###### **UI伪类**

1. :checked 被选中的复选框或单选按钮。

2. :enable 可用的表单元素（没有 disabled 属性）。

3. :disabled 不可用的表单元素（有 disabled 属性）。

###### **目标伪类（了解）**

:target 选中锚点指向的元素。

###### **语言伪类（了解）**

:lang() 根据指定的语言选择元素（本质是看 lang 属性的值）。

##### **伪元素选择器**

作用：选中元素中的一些特殊位置。

常用伪元素：

::first-letter 选中元素中的**第一个文字**。

::first-line 选中元素中的**第一行文字**。

::selection 选中**被鼠标选中的**内容。

::placeholder 选中输入框的**提示文字**。

::before 在元素**最开始**的位置，创建一个子元素（必须用 content 属性指定内容）。

```css
/* Add a heart before links */
a::before {
  content: "♥";
}
```

::after 在元素**最后**的位置，创建一个子元素（必须用 content 属性指定内容）。

#### **选择器的优先级（权重）**

通过**不同的选择器**，选中**相同的元素** ，并且为**相同的样式名**设置**不同的值**时，就发生了样式的冲突。

到底应用哪个样式，此时就需要看**优先级**了。

简单描述：

**行内样式** > **ID****选择器** > **类选择器** > **元素选择器** > **通配选择器**。

详细描述：

1. 计算方式：每个选择器，都可计算出一组权重，格式为： (a,b,c)

a : **ID** 选择器的个数。

b : **类、伪类、属性** 选择器的个数。

c : **元素、伪元素** 选择器的个数。

例如：

| **选择器**         | **权重** |
| ------------------ | -------- |
| ul>li              | (0,0,2)  |
| div ul>li p a span | (0,0,6)  |
| \#atguigu .slogan  | (1,1,0)  |

2. 比较规则：按照**从左到右**的顺序，依次比较大小，当前位胜出后，后面的不再对比，例如：

(1,0,0) > (0,2,2)

(1,1,0) > (1,0,3)

(1,1,3) > (1,1,2)

3. 特殊规则：

1. **行内样式**权重大于**所有选择器**。

2. !important 的权重，大于**行内样式**，大于**所有选择器**，**权重最高！**

#### CSS的三大特性

##### **层叠性**

概念：如果发生了样式冲突，那就会根据一定的规则（选择器优先级），进行样式的层叠（覆盖）。

什么是样式冲突？ ——— 元素的**同一个样式名**，被设置了**不同的值**，这就是冲突。

##### **继承性**

概念：元素会自动拥有**其父元素**、或**其祖先元素**上所设置的**某些样式**。

规则：优先继承**离得近**的。

常见的可继承属性：

text-?? ， font-?? ， line-?? 、 color ......备注：参照**MDN**网站，可查询属性是否可被继承。

##### **优先级**

简单聊： !important > **行内样式** > **ID****选择器** > **类选择器** > **元素选择器** > ***** > **继承的样式。**

详细聊：需要计算权重。

计算权重时需要注意：**并集选择器的每一个部分是分开算的！**

#### CSS常用属性

##### **像素的概念**

概念：我们的电脑屏幕是，是由一个一个“小点”组成的，每个“小点”，就是一个像素（px）。

规律：像素点越小，呈现的内容就越清晰、越细腻。

##### **颜色的表示**

**表示方式一：颜色名**

编写方式：直接使用颜色对应的英文单词，编写比较简单，例如：

1. **红色：****red**
2. **绿色：****green**
3. **蓝色：****blue**
4. **紫色：****purple**
5. **橙色：****orange**
6. **灰色：****gray**

**表示方式二：rgb 或 rgba**

编写方式：使用 **红、黄、蓝** 这三种光的三原色进行组合。

**r** 表示 **红色**

**g** 表示 **绿色**

**b** 表示 **蓝色**

**a** 表示 **透明度**

举例：

```css
/* 使用 0~255 之间的数字表示一种颜色 */
color: rgb(255, 0, 0);/* 红色 */
color: rgb(0, 255, 0);/* 绿色 */
color: rgb(0, 0, 255);/* 蓝色 */
color: rgb(0, 0, 0);/* 黑色 */
color: rgb(255, 255, 255);/* 白色 */
/* 混合出任意一种颜色 */
color:rgb(138, 43, 226) /* 紫罗兰色 */
color:rgba(255, 0, 0, 0.5);/* 半透明的红色 */
/* 也可以使用百分比表示一种颜色（用的少） */
color: rgb(100%, 0%, 0%);/* 红色 */
color: rgba(100%, 0%, 0%,50%);/* 半透明的红色 */
```

小规律：

1. 若三种颜色值相同，呈现的是灰色，值越大，灰色越浅。

2. rgb(0, 0, 0) 是黑色， rgb(255, 255,255) 是白色。

3. 对于 rbga 来说，前三位的 rgb 形式要保持一致，要么都是 0~255 的数字，要么都是百分比 

**表示方式三：HEX 或 HEXA**

HEX 的原理同与 rgb 一样，依然是通过：**红**、**绿**、**蓝色** 进行组合，只不过要用 **6**位（分成**3**组）来表达，

格式为：**#** **rrggbb**

每一位数字的取值范围是： 0 ~ f ，即：（ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c,d, e, f ）即16进制数

所以每一种光的最小值是： 00 ，最大值是： ff

```css
color: #ff0000;/* 红色 */
color: #00ff00;/* 绿色 */
color: #0000ff;/* 蓝色 */
color: #000000;/* 黑色 */
color: #ffffff;/* 白色 */
/* 如果每种颜色的两位都是相同的，就可以简写*/
color: #ff9988;/* 可简为：#f98 */
/* 但要注意前三位简写了，那么透明度就也要简写 */
color: #ff998866;/* 可简为：#f986 */
```

**表示方式四：**HSL**或 **HSLA

HSL 是通过：色相、饱和度、亮度，来表示一个颜色的，格式为： hsl(色相,饱和度,亮度)

色相：取值范围是 0~360 度，具体度数对应的颜色如下图：

饱和度：取值范围是 0%~100% 。（向色相中对应颜色中添加灰色， 0% 全灰， 100% 没有灰）

亮度：取值范围是 0%~100% 。（ 0% 亮度没了，所以就是黑色。 100% 亮度太强，所以就是白色了）

HSLA 其实就是在 HSL 的基础上，添加了透明度。

![img](https://upload-images.jianshu.io/upload_images/28917406-4ac3418f9bf9651f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### CSS字体属性（font）

font主要控制块状或行内元素内文字的大小和字体形态。

##### **字体大小**（font-size)

属性名： font-size

作用：控制字体的大小。

> 注意点：
>
> 1. Chrome 浏览器支持的最小文字为 12px ，默认的文字大小为 16px ，并且 0px 会自动消失。
>
> 2. 不同浏览器默认的字体大小可能不一致，所以最好给一个明确的值，不要用默认大小。
>
> 3. 通常以给 body 设置 font-size 属性，这样 body 中的其他元素就都可以继承了。

```css
div {

font-size: 40px;

}
```

##### **字体族**(font-family)

属性名： font-family

作用：控制字体类型。

语法：

```css
div {

font-family: "STCaiyun","Microsoft YaHei",sans-serif

}
```

注意：

1. 使用字体的英文名字兼容性会更好，具体的英文名可以自行查询，或在电脑的设置里去寻找。

2. 如果字体名包含空格，必须使用引号包裹起来。

3. 可以设置多个字体，按照从左到右的顺序逐个查找，找到就用，没有找到就使用后面的，且通常在最后写上 serif （衬线字体）或 sans-serif （非衬线字体）。

4. windows 系统中，默认的字体就是微软雅黑

##### **字体风格**(font-size)

属性名： font-style

作用：控制字体是否为斜体。

常用值：

1. normal ：正常（默认值）

2. italic ：斜体（使用字体自带的斜体效果）

3. oblique ：斜体（强制倾斜产生的斜体效果）

实现斜体时，更推荐使用 italic 。

```css
div {

font-size: 40px;

}

div {

font-family: "STCaiyun","Microsoft YaHei",sans-serif

}
```

语法：

```css
div {
font-style: italic;
}
```

##### **字体粗细**(font-weight)

属性名： font-weight

作用：控制字体的粗细。

常用值：

关键词

1. lighter ：细

2. normal ： 正常

3. bold ：粗

4. bolder ：很粗 （多数字体不支持）

数值：

1. 100~1000 且无单位，数值越大，字体越粗 （或一样粗，具体得看字体设计时的精确程度）。

2. 100~300 等同于 lighter ， 400~500 等同于 normal ， 600 及以上等同于bold 。

```css
div {

font-weight: bold;

}

div {

font-weight: 600;

}
```

##### **字体复合写法**(font)

属性名： font ，可以把上述字体样式合并成一个属性。

作用：将上述所有字体相关的属性复合在一起编写。

编写规则：

1. 字体大小、字体族必须都写上。

2. 字体族必须是最后一位、字体大小必须是倒数第二位。

3. 各个属性间用空格隔开。

实际开发中更推荐复合写法，但这也不是绝对的，比如只想设置字体大小，那就直接用 font-size 属性。

##### 外部引入字体（@font-face）



#### **CSS文本属性**(text)

text属性主要用于控制块状元素或行内元素内文字的排版和形态

##### **文本颜色**（color）

属性名： color

作用：控制文字的颜色。

可选值：

1. 颜色名

2. rgb 或 rgba

3. HEX 或 HEXA （十六进制）

4. HSL 或 HSLA

开发中常用的是： rgb/rgba 或 HEX/HEXA （十六进制）。

举例：

```css
div {

color: rgb(112,45,78);

}
```

##### **文本间距**（letter-spacing)(word-spacing)

字母间距： letter-spacing

单词间距： word-spacing （通过空格识别词）

属性值为像素（ px ），正值让间距增大，负值让间距缩小。

##### **文本修饰**(text-decoration)

属性名： text-decoration

作用：控制文本的各种装饰线。

可选值：

1. none ： 无装饰线（常用）

2. underline ：下划线（常用）

3. overline ： 上划线

4. line-through ： 删除线

可搭配如下值使用：

1. dotted ：虚线

2. wavy ：波浪线

3. 也可以指定颜色

举例：

```css

a {

text-decoration: none;

}
```

##### **文本缩进**(text-indent)

属性名： text-indent 。

作用：控制文本首字母的缩进。

属性值： css 中的长度单位，例如： px

举例：

```css
div {

text-indent:40px;

}
```

后面我们会学习 css 中一些新的长度单位，目前我们只知道像素( px )。

##### **文本对齐水平**(text-align)

属性名： text-align 。

作用：控制文本的水平对齐方式。

常用值：

1. left ：左对齐（默认值）

2. right ：右对齐

3. center ：居中对齐

注意，该属性只能对元素内部的行内元素内的文本起作用

举例：

```css
div {

text-align: center;

}
```

**细说** **font-size**

1. 由于字体设计原因，文字最终呈现的大小，并不一定与 font-size 的值一致，可能大，也可能小。

例如： font-size 设为 40px ，最终呈现的文字，可能比 40px 大，也可能比 40px小。

2. 通常情况下，文字相对字体设计框，并不是垂直居中的，通常都靠下 一些。

##### **行高**(line-height)

属性名： line-height

作用：控制一行文字的高度。

可选值：

1. normal ：由浏览器根据文字大小决定的一个默认值。

2. 像素( px )。

3. 数字：参考自身 font-size 的倍数（很常用）。

4. 百分比：参考自身 font-size 的百分比。

备注：由于字体设计原因，文字在一行中，并不是绝对垂直居中，若一行中都是文字，不会太影响观感。

举例：

```css
div {

line-height: 60px;

line-height: 1.5;

line-height: 150%;

}
```

> 行高注意事项：
>
> 1. line-height 过小会怎样？—— 文字产生重叠，且最小值是 0 ，不能为负数。
>
> 2. line-height 是可以继承的，且为了能更好的呈现文字，最好写数值。
>
> 3. line-height 和 height 是什么关系？
>
> 设置了 height ，那么高度就是 height 的值。
>
> 不设置 height 的时候，会根据 line-height 计算高度。

##### **文本对齐垂直**

1. **顶部：**无需任何属性，在垂直方向上，默认就是顶部对齐。

2. **居中：**对于单行文字，让 height = line-height 即可。

问题：多行文字**垂直居中**怎么办？—— 后面我们用定位去做。

3. **底部：**对于单行文字，目前一个临时的方式：

让 line-height = ( height × 2 ) - font-size - x 。

备注： x 是根据字体族，动态决定的一个值。

问题：垂直方向上的底部对齐，更好的解决办法是什么？—— 后面我们用定位去做。

##### 行内元素文本对齐垂直（**vertical-align**）

属性名： vertical-align 

**`vertical-align`** 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。

常用值：

1. baseline （默认值）：使元素的基线与父元素的基线对齐。

2. top ：使元素的**顶部**与其**所在行的顶部**对齐。

3. middle ：使元素的**中部**与**父元素的基线**加上父元素**字母** x **的一半**对齐。

4. bottom ：使元素的**底部**与其**所在行的底部**对齐。

特别注意： vertical-align 不能控制块元素。

![img](https://upload-images.jianshu.io/upload_images/28917406-4dff74155675f728.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

只对行内元素、行内块元素和表格单元格元素生效

#### **CSS列表属性**（list）

列表相关的属性，可以作用在 ul 、 ol 、 li 元素上。

![img](https://upload-images.jianshu.io/upload_images/28917406-1f894abb5c62e964.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### CSS边框属性（border）

![img](https://upload-images.jianshu.io/upload_images/28917406-75a9f1538edeb5ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### CSS表格属性（Table）

![img](https://upload-images.jianshu.io/upload_images/28917406-fe0f025735c0759b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

以上 5 个属性，只有表格才能使用，即： <table> 标签。

#### CSS背景属性（background）

![img](https://upload-images.jianshu.io/upload_images/28917406-5cc214ca377f6acb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### **CSS**鼠标属性（cursor）

![img](https://upload-images.jianshu.io/upload_images/28917406-a172d29a6e0628eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 

#### **CSS** **长度单位**（px、em、rem、%）

1. px ：像素。

2. em ：相对父元素 font-size 的倍数。 1 个 `em` 等于**父元素**中设置的**字体大小**

3. rem ：相对根字体大小，html标签就是根。

4. % ：相对父元素计算。

注意： CSS 中设置长度，必须加单位，否则样式无效！

[深入探究长度单位的关系1-细说rem与em]([细说 rem 与 em - 掘金 (juejin.cn)](https://juejin.cn/post/7195080829746774074))

#### **CSS元素的显示模式**

**块元素（**block）

又称：块级元素

```
1. 主体结构标签： <html> 、 <body>
2. 排版标签： <h1> ~ <h6> 、 <hr> 、 <p> 、 <pre> 、 <div>
3. 列表标签： <ul> 、 <ol> 、 <li> 、 <dl> 、 <dt> 、 <dd>
4. 表格相关标签： <table> 、 <tbody> 、 <thead> 、 <tfoot> 、 <tr> 、
<caption>
5. <form> 与 <option>
```

特点：

1. 在页面中**独占一行**，不会与任何元素共用一行，是从上到下排列的。

2. 默认宽度：撑满**父元素**。

3. 默认高度：由**内容**撑开。

4. **可以**通过 CSS 设置宽高。

**行内元素（inline）**

又称：内联元素

```
1. 文本标签： <br> 、 <em> 、 <strong> 、 <sup> 、 <sub> 、 <del> 、 <ins>
2. <a> 与 <label>
```

特点:

1. 在页面中**不独占一行**，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。

2. 默认宽度：由**内容**撑开。

3. 默认高度：由**内容**撑开。

4. **无法**通过 CSS 设置宽高。

**行内块元素（*inline-block**）**

又称：内联块元素

特点：

1. 在页面中**不独占一行**，一行中不能容纳下的行内元素，会在下一行继续从左到右排列。

2. 默认宽度：由**内容**撑开。

3. 默认高度：由**内容**撑开。

4. **可以**通过 CSS 设置宽高。

**注意：**元素早期只分为：**行内元素**、**块级元素**，区分条件也只有一条："是否独占一行"，如果按照这种分类方式，行内块元素应该算作行内元素。

```
1. 图片： <img>

2. 单元格： <td> 、 <th>

3. 表单控件： <input> 、 <textarea> 、 <select> 、 <button>

4. 框架标签： <iframe>
```

#### CSS修改元素的显示模式（display）

通过 CSS 中的 display 属性可以修改元素的默认显示模式，常用值如下：

| 值           | 描述                           |
| ------------ | ------------------------------ |
| none         | 元素会被**隐藏**。             |
| block        | 元素将作为**块级元素**显示     |
| inline       | 元素将作为**内联元素**显示     |
| inline-block | 元素将作为**行内块元素**显示。 |

#### CSS盒模型

CSS 会把所有的 HTML 元素都看成一个**盒子**，所有的样式也都是基于这个盒子。

1. **margin**（外边距）： 盒子与外界的距离。

2. **border**（边框）： 盒子的边框。

3. **padding**（内边距）：紧贴内容的补白区域。

4. **content**（内容）：元素中的文本或后代元素都是它的内容。

![img](https://upload-images.jianshu.io/upload_images/28917406-b43d8248a6cc2b1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 内容区(content)

![img](https://upload-images.jianshu.io/upload_images/28917406-5491d390eb254c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### **默认宽度**

所谓的默认宽度，就是**不设置** width **属性时**，元素所呈现出来的宽度。

**总宽度** = 父的 content — 自身的左右 margin 。

**内容区的宽度** = 父的 content — 自身的左右 margin — 自身的左右 border — 自身的左右padding 

##### 内边距（padding）

![img](https://upload-images.jianshu.io/upload_images/28917406-b65d90ba2a287bd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### **盒子边框（border）**

![img](https://upload-images.jianshu.io/upload_images/28917406-ab0cd30e4fd38aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### **盒子外边距（margin）**

![img](https://upload-images.jianshu.io/upload_images/28917406-ed4ef23af824694a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**margin** **注意事项**

1. 子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着子元素）

2. 上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素的位置。

3. 块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右margin 可以完美设置，上下 margin 设置无效。

4. margin 的值也可以是 auto ，如果给一个**块级元素**设置左右 margin 都为 auto ，该块级元素会在父元素中水平居中。

5. margin 的值可以是负值。

######  margin **塌陷问题**

**什么是** margin **塌陷？**

第一个子元素的**上** margin 会作用在父元素上，最后一个子元素的**下** margin 会作用在父元素上。

**如何解决** margin **塌陷？**

方案一： 给父元素设置不为 0 的 padding 。

方案二： 给父元素设置宽度不为 0 的 border 。

方案三：给父元素设置 css 样式 overflow:hidden

![img](https://upload-images.jianshu.io/upload_images/28917406-d7074a220356b1c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###### margin 合并问题

**什么是** margin **合并？**

上面兄弟元素的**下外边距**和下面兄弟元素的**上外边距**会合并，取一个最大的值，而不是相加。

**如何解决** margin **塌陷？**

无需解决，布局的时候上下的兄弟元素，只给一个设置上下外边距就可以了。

#####  **处理内容溢出**（overflow）

![img](https://upload-images.jianshu.io/upload_images/28917406-d943438537618f1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> **注意：**
>
> 1. overflow-x 、 overflow-y 不能一个是 hidden ，一个是 visible ，是实验性属性，不建议使用。
>
> 2. overflow 常用的值是 hidden 和 auto ，除了能处理溢出的显示方式，还可以解决很多疑难杂症。

#### **隐藏元素的方式**

**方式一：visibility属性**

visibility 属性默认值是 show ，如果设置为 hidden ，元素会隐藏。

元素看不见了，还占有原来的位置（元素的大小依然保持）。

**方式二：** **display** **属性**

设置 display:none ，就可以让元素隐藏。

彻底地隐藏，不但看不见，也不占用任何位置，没有大小宽高。

#### **样式的继承**

有些样式会继承，元素如果本身设置了某个样式，就使用本身设置的样式；但如果本身没有设置某个样式，会从父元素开始一级一级继承（优先继承离得近的祖先元素）。

**会继承的** **css** **属性**

边框、背景、内边距、外边距、宽高、溢出方式 等

**不会继承的** **css** **属性**

字体属性、文本属性（除了vertical-align）、文字颜色 等。

一个规律：能继承的属性，都是不影响布局的，简单说：都是和盒子模型没关系的。

**默认样式**

```css
元素一般都些默认的样式，例如：

1. <a> 元素：下划线、字体颜色、鼠标小手。

2. <h1> ~ <h6> 元素： 文字加粗、文字大小、上下外边距。

3. <p> 元素：上下外边距

4. <ul> 、 ol 元素：左内边距

5. body 元素： 8px 外边距（4个方向）
```

......

优先级：**元素的默认样式** **>** **继承的样式**，所以如果要重置元素的默认样式，选择器一定要直接选择器到该元素。

**布局小技巧**

1. 行内元素、行内块元素，可以被父元素当做文本处理。

即：可以像处理文本对齐一样，去处理：行内、行内块在父元素中的对齐。

例如： text-align 、 line-height 、 text-indent 等。

2. 如何让子元素，在父亲中 **水平居中**：

若子元素为**块元素**，给父元素加上： margin:0 auto; 。

若子元素为**行内元素**、**行内块元素**，给父元素加上： text-align:center 。

3. 如何让子元素，在父亲中 **垂直居中**：

若子元素为**块元素**，给子元素加上： margin-top ，值为：(父元素 content －子元素盒子总高) / 2。

若子元素为**行内元素**、**行内块元素**：

让父元素的 height = line-height ，每个子元素都加上： vertical-align:middle; 。

补充：若想绝对垂直居中，父元素 font-size 设置为 0 。

#### **元素之间的空白问题**

**产生的原因：**

行内元素、行内块元素，彼此之间的换行会被浏览器解析为一个空白字符。

**解决方案：**

1. **方案一：** 去掉换行和空格（不推荐）。

2. **方案二：** 给父元素设置 font-size:0 ，再给需要显示文字的元素，单独设置字体大小（推

荐）。

**行内块的幽灵空白问题**

**产生原因：**

行内块元素与文本的基线对齐，而文本的基线与文本最底端之间是有一定距离的。

**解决方案：**

 **方案一：** 给行行内块设置 vertical ，值不为 baseline 即可，设置为 middel 、 bottom 、top 均可。

 **方案二：** 若父元素中只有一张图片，设置图片为 display:block 。

**方案三：** 给父元素设置 font-size: 0 。如果该行内块内部还有文本，则需单独设置 font-size 。

#### **CSS浮动**（float）

![img](https://upload-images.jianshu.io/upload_images/28917406-c5e2d17158d31469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**浮动的简介**

在最初，浮动是用来实现文字环绕图片效果的，现在浮动是主流的页面布局方式之一。

**元素浮动后的特点**

1. 🤢脱离文档流。

2. 😊不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽s高。

3. 😊不会独占一行，可以与其他元素共用一行。

4. 😊不会 margin 合并，也不会 margin 塌陷，能够完美的设置四个方向的 margin 和 padding 。

5. 😊不会像行内块一样被当做文本处理（没有行内块的空白问题）。

**解决浮动产生的影响**

**元素浮动后会有哪些影响**

**对兄弟元素的影响：** 后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。

**对父元素的影响：** 不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽度依然束缚浮动的元素。

**解决浮动产生的影响（清除浮动）**

**解决方案：**

1. 方案一： 给父元素指定高度。

2. 方案二： 给父元素也设置浮动，带来其他影响。

3. 方案三： 给父元素设置 overflow:hidden 。

4. 方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both 。

5. **方案五**： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。===> 推荐使用

布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动。

**浮动相关属性**

![img](https://upload-images.jianshu.io/upload_images/28917406-e1ff838b4808e408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[CSS之float和clear_css float clear-CSDN博客](https://blog.csdn.net/m0_48796380/article/details/123552920)

#### **CSS定位**（postition)

##### **相对定位**(relative)

**如何设置相对定位？**

给元素设置 position:relative 即可实现相对定位。

可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。

**相对定位的参考点在哪里？**

相对自己原来的位置

**相对定位的特点：**

1. 不会脱离文档流，元素位置的变化，只是视觉效果上的变化，不会对其他元素产生任何影响。

2. 定位元素的显示**层级**比普通元素高，无论什么定位，显示层级都是一样的。

默认规则是：

定位的元素会盖在普通元素之上。都发生定位的两个元素，后写的元素会盖在先写的元素之上。

3. left 不能和 right 一起设置， top 和 bottom 不能一起设置。

4. 相对定位的元素，也能继续浮动，但不推荐这样做。

5. 相对行为的元素，也能通过 margin 调整位置，但不推荐这样做。

注意：绝大多数情况下，相对定位，会与绝对定位配合使用。

##### **绝对定位**(absolute)

**如何设置绝对定位？**

给元素设置 position: absolute 即可实现绝对定位。

可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。

** **绝对定位的参考点在哪里？**

参考它的**包含块**。

什么是包含块？

1. 对于没有脱离文档流的元素：包含块就是父元素；

2. 对于脱离文档流的元素：包含块是第一个拥有定位属性的祖先元素（如果所有祖先都

没定位，那包含块就是整个页面）。

**绝对定位元素的特点：**

1. 脱离文档流，会对后面的兄弟元素、父元素有影响。

2. left 不能和 right 一起设置， top 和 bottom 不能一起设置。

3. 绝对定位、浮动不能同时设置，如果同时设置，浮动失效，以定位为主。

4. 绝对定位的元素，也能通过 margin 调整位置，但不推荐这样做。

5. 无论是什么元素（行内、行内块、块级）设置为绝对定位之后，都变成了定位元素。

何为定位元素？ —— 默认宽、高都被内容所撑开，且能自由设置宽高。

##### **固定定位**(fixed)

**如何设置为固定定位？**

给元素设置 position: fixed 即可实现固定定位。

可以使用 left 、 right 、 top 、 bottom 四个属性调整位置。

**固定定位的参考点在哪里？**

参考它的**视口**

什么是视口？—— 对于 PC 浏览器来说，视口就是我们看网页的那扇“窗户”。

**固定定位元素的特点**

1. 脱离文档流，会对后面的兄弟元素、父元素有影响。

2. left 不能和 right 一起设置， top 和 bottom 不能一起设置。

3. 固定定位和浮动不能同时设置，如果同时设置，浮动失效，以固定定位为主。4. 固定定位的元素，也能通过 margin 调整位置，但不推荐这样做。

5. 无论是什么元素（行内、行内块、块级）设置为固定定位之后，都变成了定位元素。

##### **粘性定位**(sticky)

 **如何设置为粘性定位？**

给元素设置 position:sticky 即可实现粘性定位。

可以使用 left 、 right 、 top 、 bottom 四个属性调整位置，不过最常用的是 top 值。

**粘性定位的参考点在哪里？**

离它最近的一个拥有“滚动机制”的祖先元素，即便这个祖先不是最近的真实可滚动祖先。

**粘性定位元素的特点**

不会脱离文档流，它是一种专门用于窗口滚动时的新的定位方式。

最常用的值是 top 值。

粘性定位和浮动可以同时设置，但不推荐这样做。

粘性定位的元素，也能通过 margin 调整位置，但不推荐这样做。

粘性定位和相对定位的特点基本一致，不同的是：粘性定位可以在元素到达某个位置时将其固定。

**定位层级**

1. 定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。

2. 如果位置发生重叠，默认情况是：后面的元素，会显示在前面元素之上。

3. 可以通过 css 属性 z-index 调整元素的显示层级。

4. z-index 的属性值是数字，没有单位，值越大显示层级越高。

5. 只有定位的元素设置 z-index 才有效。

6. 如果 z-index 值大的元素，依然没有覆盖掉 z-index 值小的元素，那么请检查其包含块的层级。

**6.** **定位的特殊应用**

注意：

1. 发生固定定位、绝对定位后，元素都变成了定位元素，默认宽高被内容撑开，且依然可以设置宽高。

2. 发生相对定位后，元素依然是之前的显示模式。

3. 以下所说的特殊应用，只针对 **绝对定位** 和 **固定定位** 的元素，不包括相对定位的元素。

**让定位元素的宽充满包含块**

1. 块宽想与包含块一致，可以给定位元素同时设置 left 和 right 为 0 。

2. 高度想与包含块一致， top 和 bottom 设置为 0 。

**让定位元素在包含块中居中**

方案一：

```
left:0;

right:0;

top:0;

bottom:0;

margin:auto;
```

方案二：

```
left: 50%;

top: 50%;

margin-left: 负的宽度一半;

margin-top: 负的高度一半;
```

注意：该定位的元素必须设置宽高！！！

#### **布局**

**版心**

在 PC 端网页中，一般都会有一个固定宽度且水平居中的盒子，来显示网页的主要内容，这是网页的**版心**。

版心的宽度一般是 960 ~ 1200 像素之间。

版心可以是一个，也可以是多个。

**常用布局名词**

left:0;

right:0;

top:0;

bottom:0;

margin:auto;

left: 50%;

top: 50%;

margin-left: 负的宽度一半;

margin-top: 负的高度一半;**位置**

顶部导航条 

topbar

页头 

header 、 page-header

导航 

nav 、 navigator 、 navbar

搜索框 

search 、 search-box

横幅、广告、宣传图 

banner

主要内容 

content 、 main

侧边栏 

aside 、 sidebar

页脚 

footer 、 page-footer

**重置默认样式**

很多元素都有默认样式，比如：

1. p 元素有默认的上下 margin 。

2. h1~h6 标题也有上下 margin ，且字体加粗。

3. body 元素有默认的 8px 外边距。

4. 超链接有默认的文字颜色和下划线。

5. ul 元素有默认的左 pading 。

6. .......

在早期，元素默认样式，能够让我们快速的绘制网页，但如今网页的设计越来越复杂，内容越来越多，而且很精细，这些默认样式会给我们绘制页面带来麻烦；而且这些默认样式，在不同的浏览器上呈现出来的效果也不一样，所以我们需要重置这些默认样式。

**方案一：使用全局选择器**

此种方法，在简单案例中可以用一下，但实际开发中不会使用，因为 * 选择的是所有元素，而并

不是所有的元素都有默认样式；而且我们重置时，有时候是需要做特定处理的，比如：想让 a 元

素的文字是灰色，其他元素文字是蓝色。

**方案二：****reset.css**

选择到具有默认样式的元素，清空其默认的样式。

经过 reset 后的网页，好似“一张白纸”，开发人员可根据设计稿，精细的去添加具体的样式。

\*

```css
 {

margin: 0;

padding: 0;

......

}
```

**方案三：****Normalize.css**

Normalize.css 是一种最新方案，它在清除默认样式的基础上，保留了一些有价值的默认样式。

官网地址：**http://necolas.github.io/normalize.css/**

相对于 reset.css ， Normalize.css 有如下优点：

1. 保护了有价值的默认样式，而不是完全去掉它们。

2. 为大部分HTML元素提供一般化的样式。

3. 新增对 HTML5 元素的设置。

4. 对并集选择器的使用比较谨慎，有效避免调试工具杂乱。

备注： Normalize.css 的重置，和 reset.css 相比，更加的温和，开发时可根据实际情况进行选择。

### CSS3

#### CSS3**概述**

CSS3 是 CSS2 的升级版本，它在 CSS2 的基础上，新增了很多强大的新功能，从而解决一些实际面临的问题。

CSS3 在未来会按照**模块化**的方式去发展： **https://www.w3.org/Style/CSS/current-work.html**

CSS3 的新特性如下：

新增了**更加实用的选择器**，例如：动态伪类选择器、目标伪类选择器、伪元素选择器等等。

新增了**更好的视觉效果**，例如：圆角、阴影、渐变等。

新增了**丰富的背景效果**，例如：支持多个背景图片，同时新增了若干个背景相关的属性。

新增了**全新的布局方案** —— 弹性盒子。

新增了 Web **字体**，可以显示用户电脑上没有安装的字体。

增强了**颜色**，例如： HSL 、 HSLA 、 RGBA 几种新的颜色模式，新增 opacity 属性来控制

透明度。

增加了 2D **和** 3D **变换**，例如：旋转、扭曲、缩放、位移等。

增加**动画与过渡效果**，让效果的变换更具流线性、平滑性。

……

#### **CSS3私有前缀**

**什么是私有前缀**

如下代码中的 -webkit- 就是私有前缀

```css
div {

width:400px;

height:400px;

-webkit-border-radius: 20px;

}
```

**为什么要有私有前缀**

W3C 标准所提出的某个 CSS 特性，在被浏览器正式支持之前，浏览器厂商会根据浏览器的内核，

使用私有前缀来测试该 CSS 特性，在浏览器正式支持该 CSS 特性后，就不需要私有前缀了。

举个例子：

```css
-webkit-border-radius: 20px;

-moz-border-radius: 20px;

-ms-border-radius: 20px;

-o-border-radius: 20px;

border-radius: 20px;
```

查询 CSS3 兼容性的网站：**https://caniuse.com/**

**常见浏览器私有前缀**

Chrome **浏览器：** **-**webkit-

Safari **浏览器：** **-**webkit-

Firefox **浏览器：** **-**moz-

Edge **浏览器：** **-**webkit**-**

旧 Opera 浏览器： -o-

旧 IE 浏览器： -ms-

注意：

我们在编码时，不用过于关注浏览器私有前缀，不用绞尽脑汁的去记忆，也不用每个都去查询，因

为常用的 CSS3 新特性，主流浏览器都是支持的，即便是为了老浏览器而加前缀，我们也可以借助现代的构建工具，去帮我们添加私有前缀。

#### css新增基本语法

#####  CSS3新增长度单位

1. rem 根元素字体大小的倍数，只与根元素字体大小有关。

2. vw 视口宽度的百分之多少 10vw 就是视口宽度的 10% 。

3. vh 视口高度的百分之多少 10vh 就是视口高度的 10% 。

4. vmax 视口宽高中大的那个的百分之多少。（了解即可）

5. vmin 视口宽高中小的那个的百分之多少。（了解即可）

##### CSS3 新增颜色设置方式

CSS3 新增了三种颜色设置方式，分别是： rgba 、 hsl 、 hsla ，由于之前已经详细讲解，此处略过。

**CSS3** **新增选择器**

CSS3 新增的选择器有：动态伪类、目标伪类、语言伪类、 UI 伪类、结构伪类、否定伪类、伪元素；这

些在 CSS2 中已经详细讲解，此处略过。

#### CSS新增盒模型相关属性

##### box**-**sizing **怪异盒模型**

使用 box-sizing 属性可以设置盒模型的两种类型

![img](https://upload-images.jianshu.io/upload_images/28917406-d52d421f4b1d0aa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### resize 允许用户调整盒子大小

![img](https://upload-images.jianshu.io/upload_images/28917406-913e7b50ce81a774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### box**-**shadow 设置盒子阴影

使用 box-shadow 属性为盒子添加阴影。

语法：

```css
box-shadow: h-shadow v-shadow blur spread color inset;
```

默认值： box-shadow:none 表示没有阴影

示例：

```css
/* 写两个值，含义：水平位置、垂直位置 */

box-shadow: 10px 10px;

/* 写三个值，含义：水平位置、垂直位置、颜色 */

box-shadow: 10px 10px red;

/* 写三个值，含义：水平位置、垂直位置、模糊值 */

box-shadow: 10px 10px 10px;

/* 写四个值，含义：水平位置、垂直位置、模糊值、颜色 */

box-shadow: 10px 10px 10px red;

/* 写五个值，含义：水平位置、垂直位置、模糊值、外延值、颜色 */

box-shadow: 10px 10px 10px 10px blue;

/* 写六个值，含义：水平位置、垂直位置、模糊值、外延值、颜色、内阴影 */

box-shadow: 10px 10px 20px 3px blue inset;
```

##### opacity **不透明度**

opacity 属性能为整个元素添加透明效果， 值是 0 到 1 之间的小数， 0 是完全透明， 1 表示完全不透明。

opacity 与 rgba 的区别？

opacity 是一个属性，设置的是整个元素（包括元素里的内容）的不透明度。

rgba 是颜色的设置方式，用于设置颜色，它的透明度，仅仅是调整颜色的透明度。

#### **CSS3** 新增**背景属性**

##### **background-origin**背景图原点

作用：设置背景图的原点。

语法

1. padding-box ：从 padding 区域开始显示背景图像。—— 默认值

2. border-box ： 从 border 区域开始显示背景图像。

3. content-box ： 从 content 区域开始显示背景图像。

4. text ：背景图只呈现在文字上。

   注意：若值为 text ，那么 backgroun-clip 要加上 -webkit- 前缀。

##### **background-size**背景图尺寸

作用：设置背景图的尺寸。

语法：

1. 用长度值指定背景图片大小，不允许负值。

   ```css
   background-size: 300px 200px;
   ```

2. 用百分比指定背景图片大小，不允许负值。

   ```css
   background-size: 100% 100%;
   ```

3. auto ： 背景图片的真实大小。 —— 默认值

4. contain ： 将背景图片等比缩放，使背景图片的宽或高，与容器的宽或高相等，再将完整背景图片包含在容器内，但要注意：可能会造成容器里部分区域没有背景图片。

   ```css
   background-size: contain;
   ```

5. cover ：将背景图片等比缩放，直到完全覆盖容器，图片会尽可能全的显示在元素上，但要注意：背景图片有可能显示不完整。—— 相对比较好的选择

   ```css
   background-size: cover;
   ```

**backgorund** **复合属性**

语法：background: color url repeat position / size origin clip

**注意：**

1. origin 和 clip 的值如果一样，如果只写一个值，则 origin 和 clip 都设置；如果设置了两个值，前面的是 origin ，后面的 clip 。

2. size 的值必须写在 position 值的后面，并且用 / 分开。

**多背景图**

CSS3 允许元素设置多个背景图片

```css
/* 添加多个背景图 */

background: url(../images/bg-lt.png) no-repeat,

url(../images/bg-rt.png) no-repeat right top,

url(../images/bg-lb.png) no-repeat left bottom,

url(../images/bg-rb.png) no-repeat right bottom;
```

####  CSS3新增边框属性

##### border-radius **边框圆角**

在 CSS3 中，使用 border-radius 属性可以将盒子变为圆角。

同时设置四个角的圆角：

```css
border-radius:10px;
```

分开设置每个角的圆角（几乎不用）:

![img](https://upload-images.jianshu.io/upload_images/28917406-fb4f658aa37f12f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

分开设置每个角的圆角，综合写法（几乎不用）：

border-raidus: 左上角x 右上角x 右下角x 左下角x / 左上y 右上y 右下y 左下y

##### **outline边框外轮廓（了解）**

outline-width ：外轮廓的宽度。

outline-color ：外轮廓的颜色。

outline-style ：外轮廓的风格。

none ： 无轮廓

dotted ： 点状轮廓

dashed ： 虚线轮廓

solid ： 实线轮廓

double ： 双线轮廓

outline-offset 设置外轮廓与边框的距离，正负值都可以设置。

注意： outline-offset 不是 outline 的子属性，是一个独立的属性。

outline 复合属性

outline:50px solid blue;

#### *CSS3*新增文本属性

##### text-shadow 文本阴影

在 CSS3 中，我们可以使用 text-shadow 属性给文本添加阴影

语法：

```css
text-shadow: h-shadow v-shadow blur color;
```

![img](https://upload-images.jianshu.io/upload_images/28917406-f1ff64242555fb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### white-space文本换行

在 CSS3 中，我们可以使用 white-space 属性设置文本换行方式

![img](https://upload-images.jianshu.io/upload_images/28917406-626e4be3b645543d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### text-overflow文本溢出

在 CSS3 中，我们可以使用 text-overflow 属性设置文本内容溢出时的呈现模式![img](https://upload-images.jianshu.io/upload_images/28917406-e9e326de2f18cdb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 优化text-decoration文本修饰复合语句化

![img](https://upload-images.jianshu.io/upload_images/28917406-7fef852957fab371.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### text-stroke文本描边

注意：文字描边功能仅 webkit 内核浏览器支持。

-webkit-text-stroke-width ：设置文字描边的宽度，写长度值。

-webkit-text-stroke-color ：设置文字描边的颜色，写颜色值。

-webkit-text-stroke ：复合属性，设置文字描边宽度和颜色。

#### **CSS3** **新增渐变**

##### **线性渐变**linear-gradient()

多个颜色之间的渐变， 默认**从上到下**渐变。

![img](https://upload-images.jianshu.io/upload_images/28917406-604f476dc66d51f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```css
background-image: linear-gradient(red,yellow,green)
```

使用关键词设置线性**渐变的方向**。

```css
background-image: linear-gradient(to top,red,yellow,green);

background-image: linear-gradient(to right top,red,yellow,green);
```

使用角度设置线性**渐变的方向**。

```css
background-image: linear-gradient(30deg,red,yellow,green);
```

调整开始**渐变的位置**。

```css
background-image: linear-gradient(red 50px,yellow 100px ,green 150px);
```

##### **径向渐变** radial-gradient();

多个颜色之间的渐变， 默认从圆心四散。（注意：不一定是正圆，要看容器本身宽高比）

![img](https://upload-images.jianshu.io/upload_images/28917406-2c875d8f42cae35d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```css
background-image: radial-gradient(red,yellow,green);
```

使用关键词调整渐变圆的圆心位置。

```css
background-image: radial-gradient(at right top,red,yellow,green);
```

使用像素值调整渐变圆的圆心位置。

```css
background-image: radial-gradient(at 100px 50px,red,yellow,green);
```

调整渐变形状为正圆 。

```css
background-image: radial-gradient(circle,red,yellow,green);
```

调整形状的半径 。

```css
background-image: radial-gradient(100px,red,yellow,green);

background-image: radial-gradient(50px 100px,red,yellow,green);
```

调整开始渐变的位置。

```css
background-image: radial-gradient(red 50px,yellow 100px,green 150px);
```

##### **重复渐变**repeating-gradient

无论线性渐变，还是径向渐变，在没有发生渐变的位置，继续进行渐变，就为重复渐变。

1. 使用 repeating-linear-gradient 进行重复线性渐变，具体参数同 linear-gradient 。
2. 使用 repeating-radial-gradient 进行重复径向渐变，具体参数同 radial-gradient 。

我们可以利用渐变，做出很多有意思的效果：例如：横格纸、立体球等等。

#### web字体

**基本用法**

可以通过 @font-face 指定字体的具体地址，浏览器会自动下载该字体，这样就不依赖用户电脑上的字体了。

语法：

```css
@font-face {

font-family: "情书字体";

src: url('./方正手迹.ttf');

}
```

语法（高兼容性写法）

```css
@font-face {

font-family: "atguigu";

font-display: swap;

src: url('webfont.eot'); /* IE9 */

src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */

url('webfont.woff2') format('woff2'),

url('webfont.woff') format('woff'), /* chrome、firefox */

url('webfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari,

Android*/

url('webfont.svg#webfont') format('svg'); /* iOS 4.1- */

}
```

**定制字体**

中文的字体文件很大，使用完整的字体文件不现实，通常针对某几个文字进行单独定制。

可使用阿里 Web 字体定制工具：**https://www.iconfont.cn/webfont**

**字体图标**

相比图片更加清晰。

灵活性高，更方便改变大小、颜色、风格等。

兼容性好， IE 也能支持。

字体图标的具体使用方式，每个平台不尽相同，最好参考平台使用指南，视频中我们是以使用最多的阿里图标库作为演示。

阿里图标官网地址：**https://www.iconfont.cn/**

#### CSS2D变换（transform:translate()）

2D 位移可以改变元素的位置，具体使用方式如下：

1. 先给元素添加 **转换属性** transform

2. 编写 transform 的具体值，相关可选值如下：

![img](https://upload-images.jianshu.io/upload_images/28917406-3bb322a4fae92836.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 1. 位移与相对定位很相似，都不脱离文档流，不会影响到其它元素。
>
> 2. 与相对定位的区别：相对定位的百分比值，参考的是其父元素；定位的百分比值，参考的是
>
> 其自身。
>
> 3. 浏览器针对位移有优化，与定位相比，浏览器处理位移的效率更高。
>
> 4. transform 可以链式编写，例如：
>
> 5. 位移对行内元素无效。
>
> 6. 位移配合定位，可实现元素水平垂直居中
>
>    ```css
>    .box {
>    position: absolute;
>    left: 50%;
>    top: 50%;
>    transform: translate(-50%, -50%);
>    }
>    ```

#### CSS2D缩放(transform:scale())

2D 缩放是指：让元素放大或缩小，具体使用方式如下：

1. 先给元素添加 **转换属性** transform
2. 编写 transform 的具体值，相关可选值如下：
   ![img](https://upload-images.jianshu.io/upload_images/28917406-fa2fabb90c322085.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 1. scale 的值，是支持写负数的，但几乎不用，因为容易让人产生误解。
>
> 2. 借助缩放，可实现小于 12px 的文字。

#### CSS2D旋转(transform:rotate())

2D 旋转是指：让元素在二维平面内，顺时针旋转或逆时针旋转，具体使用方式如下：

1. 先给元素添加 **转换属性** transform
2. 编写 transform 的具体值，相关可选值如下：

![img](https://upload-images.jianshu.io/upload_images/28917406-ec23982661befcf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### CSS2D扭曲(transform:skew())

2D 扭曲是指：让元素在二维平面内被“拉扯”，进而“走形”，实际开发几乎不用，了解即可，具体使用方式如下：

1. 先给元素添加 **转换属性** transform

2. 编写 transform 的具体值，相关可选值如下：

   ![img](https://upload-images.jianshu.io/upload_images/28917406-75471934e618223c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### CSS多重变换(transform)

```css
transform: translate(-50%, -50%) rotate(45deg);
```

注意点：多重变换时，建议最后旋转。

#### **变换原点**（transform-origin）

元素变换时，默认的原点是元素的中心，使用 transform-origin 可以设置变换的原点。

修改变换原点对位移没有影响， 对旋转和缩放会产生影响。

如果提供两个值，第一个用于横坐标，第二个用于纵坐标。

如果只提供一个，若是像素值，表示横坐标，纵坐标取 50% ；若是关键词，则另一个坐标取 50%

> 1. transform-origin: 50% 50% ， 变换原点在元素的中心位置，百分比是相对于自身。—— 默认值
>
> 2. transform-origin: left top ，变换原点在元素的左上角 。
>
> 3. transform-origin: 50px 50px ， 变换原点距离元素左上角 50px 50px 的位置。
>
> 4. transform-origin: 0 ，只写一个值的时候，第二个值默认为 50% 。

#### CSS3D变换

##### 基础设置

######  开启3D空间（transform-style:preserve-3d)

重要原则：元素进行 3D 变换的首要操作：**父元素**必须开启 3D 空间！

> 使用 transform-style 开启 3D 空间，可选值如下：
>
> flat ： 让子元素位于此元素的二维平面内（ 2D 空间）—— 默认值
>
> preserve-3d ： 让子元素位于此元素的三维空间内（ 3D 空间）

###### **设置景深**（perspective）

何为景深？—— 指定观察者与 z=0 平面的距离，能让发生 3D 变换的元素，产生透视效果，看来更加立体。

> 使用 perspective 设置景深，可选值如下：
>
> none ： 不指定透视 ——（默认值）
>
> 长度值 ： 指定观察者距离 z=0 平面的距离，不允许负值。
>
> 注意： perspective 设置给发生 3D 变换元素的**父元素**！

###### **透视点位置**（perspective-origin）

所谓透视点位置，就是观察者位置；默认的透视点在元素的中心。

使用 perspective-origin 设置观察者位置（透视点的位置），例如：

> ```css
> /* 相对坐标轴往右偏移400px， 往下偏移300px（相当于人蹲下300像素，然后向右移动400像素看元素）
> 
> */
> 
> perspective-origin: 400px 300px;
> ```
>
> 

注意：通常情况下，我们不需要调整透视点位置。

##### 3D位移、旋转、缩放

3D 位移是在 2D 位移的基础上，可以让元素沿 z 轴位移

![img](https://upload-images.jianshu.io/upload_images/28917406-4ec7c3f6d33282e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

3D 旋转是在 2D 旋转的基础上，可以让元素沿 x 轴和 y 轴旋转

![image-20240210223822370](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20240210223822370.png)

3D 缩放是在 2D 缩放的基础上，可以让元素沿 z 轴缩放

![img](https://upload-images.jianshu.io/upload_images/28917406-1983fbee5a3e1b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 3D多重变换

![img](https://upload-images.jianshu.io/upload_images/28917406-5fccad8deaaf630c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 背部可见性（backface-visibility）

使用 backface-visibility 指定元素背面，在面向用户时是否可见，常用值如下：

visible ： 指定元素背面可见，允许显示正面的镜像。—— 默认值

hidden ： 指定元素背面不可见

注意： backface-visibility 需要加在发生 3D 变换元素的自身上。

#### CSS过渡（transition）

过渡可以在不使用 Flash 动画，不使用 JavaScript 的情况下，让元素从一种样式，平滑过渡为另一种样式。

##### 制定过渡属性 transition-property

作用：定义哪个属性需要过渡，只有在该属性中定义的属性（比如宽、高、颜色等）才会以有过渡

效果。

常用值：

1. none ：不过渡任何属性。

2. all ：过渡所有能过渡的属性。

3. 具体某个属性名 ，例如： width 、 heigth ，若有多个以逗号分隔。

不是所有的属性都能过渡，值为数字，或者值能转为数字的属性，都支持过渡，否则不支持过渡。

常见的支持过渡的属性有：颜色、长度值、百分比、 z-index 、 opacity 、 2D 变换属性、 3D 变换属性、阴影。

##### 设置过渡时间**transition-duration**

作用：设置过渡的持续时间，即：一个状态过渡到另外一个状态耗时多久。

常用值：

1. 0 ：没有任何过渡时间 —— 默认值。

2. s 或 ms ：秒或毫秒。

3. 列表 ：

如果想让所有属性都持续一个时间，那就写一个值。

如果想让每个属性持续不同的时间那就写一个时间的列表。

##### **指定开始延迟时间transition-delay**

作用：指定开始过渡的延迟时间，单位： s 或 ms

##### 设置过度类型transition-timing-function

作用：设置过渡的类型

常用值：

1. ease ： 平滑过渡 —— 默认值

2. linear ： 线性过渡

3. ease-in ： 慢 → 快

4. ease-out ： 快 → 慢

5. ease-in-out ： 慢 → 快 → 慢

6. step-start ： 等同于 steps(1, start)

7. step-end ： 等同于 steps(1, end)

8. steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end 。

9. cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。

在线制作贝赛尔曲线：**https://cubic-bezier.com****

##### transition **复合属性**

如果设置了一个时间，表示 duration ；如果设置了两个时间，第一是 duration ，第二个是delay ；其他值没有顺序要求。

```css
transition:1s 1s linear all;
```

####  **CSS动画(animation)**

##### **什么是帧**(frame)

一段动画，就是一段时间内连续播放 n 个画面。每一张画面，我们管它叫做“帧”。一定时间内连续

快速播放若干个帧，就成了人眼中所看到的动画。同样时间内，播放的帧数越多，画面看起来越流畅。

##### **什么是关键帧**(@keyframes)

关键帧指的是，在构成一段动画的若干帧中，起到决定性作用的 2-3 帧

##### **动画的基本使用**

第一步：定义关键帧（定义动画）

1. 简单方式定义：

   ```CSS
   /*写法一*/
   
   @keyframes 动画名 {
   
   from {
   
   /*property1:value1*/
   
   /*property2:value2*/
   
   }
   
   to {
   
   /*property1:value1*/
   
   }
   
   }
   ```

2. 完整方式定义：

```CSS
@keyframes 动画名 {

0% {

/*property1:value1*/

}

20% {

/*property1:value1*/

}

40% {

/*property1:value1*/

}

60% {

/*property1:value1*/

}

80% {

/*property1:value1*/

}

100% {

/*property1:value1*/

}

}
```

第二步：给元素应用动画，用到的属性如下：

1. animation-name ：给元素指定具体的动画（具体的关键帧）

2. animation-duration ：设置动画所需时间

3. animation-delay ：设置动画延迟

   ```CSS
   .box {
   
   /* 指定动画 */
   
   animation-name: testKey;
   
   /* 设置动画所需时间 */
   
   animation-duration: 5s;
   
   /* 设置动画延迟 */
   
   animation-delay: 0.5s;
   
   }
   ```

##### **动画的其他属性**

animation-timing-function ，设置动画的类型，常用值如下：

1. ease ： 平滑动画 —— 默认值

2. linear ： 线性过渡

3. ease-in ： 慢 → 快

4. ease-out ： 快 → 慢

5. ease-in-out ： 慢 → 快 → 慢

6. step-start ： 等同于 steps(1, start)

7. step-end ： 等同于 steps(1, end)

8. steps( integer,?) ： 接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是 start 或 end ，指定每一步的值发生变化的时间点。第二个参数默认值为 end 。

9. cubic-bezie ( number, number, number, number)： 特定的贝塞尔曲线类型。

**animation-iteration-count** ，指定动画的播放次数，常用值如下：

1. number ：动画循环次数

2. infinite ： 无限循环

**animation-direction** ，指定动画方向，常用值如下：

1. normal ： 正常方向 (默认)

2. reverse ： 反方向运行

3. alternate ： 动画先正常运行再反方向运行，并持续交替运行

4. alternate-reverse ： 动画先反运行再正方向运行，并持续交替运行

**animation-fill-mode** ，设置动画之外的状态

1. forwards ： 设置对象状态为动画结束时的状态

2. backwards ： 设置对象状态为动画开始时的状态

**animation-play-state** ，设置动画的播放状态，常用值如下：

1. running ： 运动 (默认)

2. paused ： 暂停

##### **动画复合属性**

只设置一个时间表示 duration ，设置两个时间分别是： duration 和 delay ，其他属性没有数量和顺序要求。

```css
.inner {

animation: atguigu 3s 0.5s linear 2 alternate-reverse forwards;

}
```

备注： animation-play-state 一般单独使用。

#### CSS多列布局（column）

作用：专门用于实现类似于报纸的布局

**常用属性如下：**

column-count ：指定列数，值是数字。

column-width ：指定列宽，值是长度。

columns ：同时指定列宽和列数，复合属性；值没有数量和顺序要求。

column-gap ：设置列边距，值是长度。

column-rule-style ：设置列与列之间边框的风格，值与 border-style 一致。

column-rule-width ：设置列与列之间边框的宽度，值是长度。

column-rule-color ：设置列与列之间边框的颜色。

coumn-rule ：设置列边框，复合属性。

column-span 指定是否跨列；值: none 、 all 。

#### CSS弹性盒/伸缩盒模型（flex）

##### **伸缩盒模型简介**

2009 年， W3C 提出了一种新的盒子模型 —— Flexible Box （伸缩盒模型，又称：弹性盒子）。

它可以轻松的控制：元素分布方式、元素对齐方式、元素视觉顺序 .......

截止目前，除了在部分 IE 浏览器不支持，其他浏览器均已全部支持。

伸缩盒模型的出现，逐渐演变出了一套新的布局方案 —— flex 布局。

小贴士：

1. 传统布局是指：基于传统盒状模型，主要靠： display 属性 + position 属性 + float属性。

2. flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上。

##### **伸缩容器、伸缩项目**

**伸缩容器**： 开启了 flex 的元素，就是：伸缩容器。

1. 给元素设置： display:flex 或 display:inline-flex ，该元素就变为了伸缩容器。

2. display:inline-flex 很少使用，因为可以给多个伸缩容器的父容器，也设置为伸缩容器。

3. 一个元素可以同时是：伸缩容器、伸缩项目。

**伸缩项目**：伸缩容器所有**子元素**自动成为了：伸缩项目。

1. 仅伸缩容器的**子元素**成为了伸缩项目，孙子元素、重孙子元素等后代，不是伸缩项目。

2. 无论原来是哪种元素（块、行内块、行内），一旦成为了伸缩项目，全都会“块状化”。

##### **主轴与侧轴**

**主轴：** 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是：从左到右（左边是起点，右边是终点）。

**侧轴：** 与主轴垂直的就是侧轴，侧轴默认是垂直的，默认方向是：从上到下（上边是起点，下边是终点）。

##### **伸缩主轴方向**（ flex-direction）

属性名： flex-direction

常用值如下：

1. row ：主轴方向水平从左到右 —— 默认值

2. row-reverse ：主轴方向水平从右到左。

3. column ：主轴方向垂直从上到下。

4. column-reverse ：主轴方向垂直从下到上。

![img](https://upload-images.jianshu.io/upload_images/28917406-3c1322a6b1b3f4dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

注意：改变了主轴的方向，侧轴方向也随之改变。

##### 主轴换行方式（flex-wrap）

属性名： flex-wrap

常用值如下：

1. nowrap ：默认值，不换行

   ![img](https://upload-images.jianshu.io/upload_images/28917406-c6304fdba05e8fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. wrap ：自动换行，伸缩容器不够自动换行。

   ![img](https://upload-images.jianshu.io/upload_images/28917406-b1ae457c25f0e190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

   3.wrap-reverse ：反向换行。

   ![img](https://upload-images.jianshu.io/upload_images/28917406-48c8eaf9dab369ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 复合主轴换行属性（flex-flow）

```css
flex-flow: row wrap;
```

##### **主轴对齐方式(justify-content)**

属性名： justify-content

常用值如下：

1. flex-start ：主轴起点对齐。—— 默认值

2. flex-end ：主轴终点对齐。

3. center ：居中对齐

4. space-between ：均匀分布，两端对齐（最常用）。

5. space-around ：均匀分布，两端距离是中间距离的一半。

6. space-evenly ：均匀分布，两端距离与中间距离一致。

   ![img](https://upload-images.jianshu.io/upload_images/28917406-50683d16a528bdb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### **侧轴对齐方式**

######  **一行的情况**(align-items)

所需属性： align-items

常用值如下：

1. flex-start ：侧轴的起点对齐。

2. flex-end ：侧轴的终点对齐。

3. center ：侧轴的中点对齐。

4. baseline : 伸缩项目的第一行文字的基线对齐。

5. stretch ：如果伸缩项目未设置高度，将占满整个容器的高度。—— （默认值）

   ![img](https://upload-images.jianshu.io/upload_images/28917406-b0d7269f4a605a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###### **多行的情况**(align-content)

所需属性： align-content

常用值如下：

1. flex-start ：与侧轴的起点对齐。

2. flex-end ：与侧轴的终点对齐。

3. center ：与侧轴的中点对齐。

4. space-between ：与侧轴两端对齐，中间平均分布。

5. space-around ：伸缩项目间的距离相等，比距边缘大一倍。

6. space-evenly : 在侧轴上完全平分。

7. stretch ：占满整个侧轴。—— 默认值

   ![img](https://upload-images.jianshu.io/upload_images/28917406-a79ac621685c1554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### **flex** **实现水平垂直居中**

方法一：父容器开启 flex 布局，随后使用 justify-content 和 align-items 实现水平垂直居中

```css
.outer {

width: 400px;

height: 400px;

background-color: #888;

display: flex;

justify-content: center;

align-items: center;

}

.inner {

width: 100px;

height: 100px;

background-color: orange;

}
```

方法二：父容器开启 flex 布局，随后子元素 margin: auto

```css
.outer {

width: 400px;

height: 400px;

background-color: #888;

display: flex;

}

.inner {

width: 100px;

height: 100px;

background-color: orange;

margin: auto;

}
```

##### 伸缩性

###### **flex-basis**

概念： flex-basis 设置的是主轴方向的**基准长度**，会让宽度或高度失效。

备注：主轴横向：宽度失效；主轴纵向：高度失效

作用：浏览器根据这个属性设置的值，计算主轴上是否有多余空间，默认值 auto ，即：伸缩项目的宽或高。

###### **flex-grow（伸）**

概念： flex-grow 定义伸缩项目的放大比例，默认为 0 ，即：纵使主轴存在剩余空间，也不拉伸（放大）。

规则：

1. 若所有伸缩项目的 flex-grow 值都为 1 ，则：它们将等分剩余空间（如果有空间的话）。

2. 若三个伸缩项目的 flex-grow 值分别为： 1 、 2 、 3 ，则：分别瓜分到： 1/6 、 2/6 、3/6 的空间。

######  flex-shrink（缩）

概念： flex-shrink 定义了项目的压缩比例，默认为 1 ，即：如果空间不足，该项目将会缩小。

> 收缩项目的计算，略微复杂一点，我们拿一个场景举例：
>
> 例如：
>
> 三个收缩项目，宽度分别为： 200px 、 300px 、 200px ，它们的 flex-shrink 值分别为： 1 、 2 、 3
>
> 若想刚好容纳下三个项目，需要总宽度为 700px ，但目前容器只有 400px ，还差 300px
>
> 所以每个人都要收缩一下才可以放下，具体收缩的值，这样计算：
>
> 1. 计算分母： (200×1) + (300×2) + (200×3) = 1400
>
> 2. 计算比例：
>
> 项目一： (200×1) / 1400 = 比例值1
>
> 项目二： (300×2) / 1400 = 比例值2
>
> 项目三： (200×3) / 1400 = 比例值3
>
> 3. 计算最终收缩大小：
>
> 项目一需要收缩： 比例值1 × 300
>
> 项目二需要收缩： 比例值2 × 300
>
> 项目三需要收缩： 比例值3 × 300

##### flex复合属性

flex 是复合属性，复合了： flex-grow 、 flex-shrink 、 flex-basis 三个属性，默认值为 0 1 auto 。

如果写 flex:1 1 auto ，则可简写为： flex:auto

如果写 flex:1 1 0 ，则可简写为： flex:1

如果写 flex:0 0 auto ，则可简写为： flex:none

如果写 flex:0 1 auto ，则可简写为： flex:0 auto —— 即 flex 初始值

##### **项目排序**（order）

order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0 

**单独对齐**（ align-self ）

通过 align-self 属性，可以单独调整某个伸缩项目的对齐方式

**`align-self`** 会对齐当前 grid 或 flex 行中的元素，并覆盖已有的 [`align-items`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items) 的值

它的属性值与父元素的align-items相同，但只对某个伸缩项目起效

默认值为 auto ，表示继承父元素的 align-items 属性

#### CSS响应式设计布局和媒体查询（@media）

**媒体查询**（**Media queries**）非常实用，尤其是当你想要根据设备的大致类型（如打印设备与带屏幕的设备）或者特定的特征和设备参数（例如屏幕分辨率和浏览器[视窗](https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport)宽度）来修改网站或应用程序时。

媒体查询常被用于以下目的：

- 有条件的通过 [`@media`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media) 和 [`@import`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import) [at-rules](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule) 用[CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) 装饰样式。
- 用 `media=` 属性为<style><link><source>和其他[HTML](https://developer.mozilla.org/zh-CN/docs/Web/HTML)元素指定特定的媒体类型。如：

```css
<link rel="stylesheet" src="styles.css" media="screen" />
<link rel="stylesheet" src="styles.css" media="print" />
```

- 使用[`Window.matchMedia()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia) 和[`MediaQueryList.addListener()`](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaQueryList/addListener) 方法来[测试和监控媒体状态](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Testing_media_queries)。

响应式布局就是一个网站能够兼容多个终端，可以根据屏幕的大小自动调整页面的的展示方式以及布局，我们不用为每一个终端做一个特定的版本！

##### 响应式设计与自适应设计的区别？

**响应式设计**：响应式**开发一套界面**，通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。

**自适应设计**：自适应需要**开发多套界面**，通过检测视口分辨率，来判断当前访问的设备是 `PC` 端、平板还是手机，从而请求服务层，返回不同的页面。

##### 媒体类型

**all** 

检测所有设备。

**screen** 

检测电子屏幕，包括：电脑屏幕、平板屏幕、手机屏幕等。

**print** 

检测打印机。

**aural** 

已废弃，用于语音和声音合成器。

**braille** 

已废弃，应用于盲文触摸式反馈设备。

**embossed** 

已废弃， 用于打印的盲人印刷设备。

**handheld** 

已废弃， 用于掌上设备或更小的装置，如PDA和小型电话。

projection 

已废弃， 用于投影设备。

tty 

已废弃， 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备。

tv 

已废弃， 用于电视和网络电视。

##### 媒体特性

![img](https://upload-images.jianshu.io/upload_images/28917406-54f9fd7e2fa7ed40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### [语法](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#语法)

每条媒体查询语句都由一个可选的*媒体类型*和任意数量的*媒体特性*表达式构成。可以使用多种*逻辑操作符*合并多条媒体查询语句。媒体查询语句不区分大小写。

当媒体类型（如果指定）与在其上显示文档的设备匹配并且所有媒体功能表达式都计算为 true 时，媒体查询将计算为 true。涉及未知媒体类型的查询始终为 false。

##### 使用方式

- 通过 `link` 标签中判断设备的尺寸，从而引用不同的 `css` 样式文件

```html
<!-- style.css 样式被用在宽度小于或等于 480px 的手持设备上，或者被用于屏幕宽度大于或等于 960px 的设备上 -->
<link rel="stylesheet" type="text/css" href="style.css" media="handheld and (max-width:480px), screen and (min-width:960px)" />
```

- 通过 `@media` 判断设备的尺寸应用不同的 `css` 样式

```css
//屏幕大于 1024px 或小于 1440px 时应用该样式
@media screen and (min-width: 1024px) and (max-width: 1440px) {
  ...
}
```

##### [定位媒体类型](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#定位媒体类型)

媒体类型描述了给定设备的一般类别。尽管通常在设计网站时会考虑屏幕，但你可能希望创建针对特殊设备（例如打印机或基于音频的屏幕阅读器）的样式。例如，此 CSS 针对打印机：

```css
@media print { ... }
```

你还可以定位多个设备。例如，此`@media`规则使用两个媒体查询来同时定位屏幕和打印设备

```css
@media screen, print { ... }
```

有关所有媒体类型的列表，请参见[Media types](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#media_types)。由于它们仅以非常广泛的术语描述设备，因此只有少数几种可用。要定位更具体的属性，请改用*媒体功能*。

##### [定位媒体特性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#定位媒体特性)

媒体功能描述了给定的[user agent](https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent)的输出设备或环境的特定特征。例如，你可以将特定样式应用于宽屏显示器，使用鼠标的计算机，或应用于在弱光条件下使用的设备。当用户的主要输入机制（例如鼠标）可以悬停在元素上时，如下为一个示例：

```css
@media (hover: hover) { ... }
```

许多媒体功能都是*范围功能*，这意味着可以在它们前面加上“最小”或“最大”来表示“最小条件”或“最大条件”约束。例如，仅当你的浏览器的[viewport](https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport)宽度等于或小于 12450px 时，此 CSS 才会应用样式：

```css
@media (max-width: 12450px) { ... }
```

如果你在未指定值的情况下创建媒体功能查询，则该样式将全部被应用，只要该查询的值不为零（或在 Level 4 中为`none`）即可。例如，此 CSS 将适用于任何带有彩色屏幕的设备：

```css
@media (color) { ... }
```

如果某个功能不适用于运行浏览器的设备，则涉及该媒体功能的表达式始终为 false。例如，将不会使用嵌套在以下查询中的样式，因为没有语音专用设备具有屏幕长宽比：

```css
@media speech and (aspect-ratio: 11/5) { ... }
```

有关更多媒体功能[media feature](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#media_features)示例，请参阅每个特定功能的参考页。

##### [创建复杂查询](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#创建复杂查询)

有时你可能想创建一个取决于多个条件的媒体查询。这就是*逻辑运算符*使用的场景：`not`，`and`，和 `only`。此外，你可以将多个媒体查询合并到一个*逗号分隔的列表*中。这使你可以在不同情况下应用相同的样式。

在前面的示例中，我们已经看到 `and` 运算符用于将媒体类型与媒体功能分组。`and` 运算符还可以将多个媒体功能组合到单个媒体查询中。同时，`not` 运算符会否定媒体查询，从而基本上颠倒了它的正常含义。`only` 运算符可防止较早的浏览器应用样式。

**备注：** 在大多数情况下，默认情况下，如果未指定其他类型，则使用`all`媒体类型。但是，如果使用`not`或`only`运算符，则必须显式指定媒体类型。

##### [结合多种类型和特性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#结合多种类型和特性)

`and`关键字将媒体功能与媒体类型或其他媒体功能组合在一起。此示例结合了两种媒体功能，以将样式限制为宽度至少为 30 em 的横向的设备：

```css
@media (min-width: 30em) and (orientation: landscape) { ... }
```

要将样式限制为带有屏幕的设备，可以将媒体功能链接到`screen`媒体类型：

```css
@media screen and (min-width: 30em) and (orientation: landscape) { ... }
```

##### [测试多重查询](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#测试多重查询)

当用户的设备与各种媒体类型，功能或状态中的任何一种匹配时，可以使用逗号分隔的列表来应用样式。例如，如果用户设备的最小高度为 680px 或为纵向模式的屏幕设备，则以下规则将应用其样式：

```css
@media (min-height: 680px), screen and (orientation: portrait) { ... }
```

以上面的示例为例，如果用户使用的打印机的页面高度为 800 像素，则 media 语句将返回 true，因为将应用第一个查询。同样，如果用户使用的是纵向模式的智能手机，并且视口高度为 480px，则将应用第二个查询，并且 media 语句仍将返回 true。

##### [反转查询的含义](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#反转查询的含义)

`not`关键字会反转整个媒体查询的含义。它只会否定要应用的特定媒体查询。 （因此，它不会应用于以逗号分隔的媒体查询列表中的每个媒体查询。）`not`关键字不能用于否定单个功能查询，只能用于否定整个媒体查询。看看以下`not`关键字的例子：

```css
@media not all and (monochrome) { ... }
```

所以上述查询等价于：

```css
@media not (all and (monochrome)) { ... }
```

而不是：

```css
@media (not all) and (monochrome) { ... }
```

再看另一个例子，如下媒体查询：

```css
@media not screen and (color), print and (color) { ... }
```

等价于：

```css
@media (not (screen and (color))), print and (color) { ... }
```

##### [提升老版本浏览器兼容性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#提升老版本浏览器兼容性)

`only`关键字可防止不支持带有媒体功能的媒体查询的旧版浏览器应用给定的样式。*它对现代浏览器没有影响。*

```css
@media only screen and (color) { ... }
```

##### [版本 4 中的语法改进](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#版本_4_中的语法改进)

媒体查询 4 级规范对语法进行了一些改进，以使用具有“范围”类型（例如宽度或高度，减少冗余）的功能进行媒体查询。级别 4 添加了用于编写此类的查询范围上下文。例如，使用最大宽度`max-` 功能，我们可以编写以下代码：

**备注：** 媒体查询 4 级规范在现代浏览器中具有合理的支持，但某些媒体功能并未得到很好的支持。有关更多详细信息，请参见 [`@media` browser compatibility table](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#browser_compatibility)。

```css
@media (max-width: 30em) { ... }
```

在媒体查询 4 级规范可以这样写：

```css
@media (width <= 30em) { ... }
```

使用`min-`和`max-`可以测试一个在两个值之间的宽度

```css
@media (min-width: 30em) and (max-width: 50em) { ... }
```

用 4 级语法书写如下

```css
@media (30em <= width <= 50em ) { ... }
```

媒体查询 4 级规范还添加了用**and**, **not**, 和 **or**实现的完整的布尔运算来合并媒体查询的方法。

##### [使用 `not`否定一个特性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#使用_not否定一个特性)

在媒体功能周围使用`not()`会否定查询中的该特性。例如，如果设备没有悬停功能，则`not(hover)`将被匹配：

```css
@media (not(hover)) { ... }
```

##### [用 `or`测试多个特性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Using_media_queries#用_or测试多个特性)

你可以使用`or`测试多个功能之间的匹配，如果任何功能为 true，则解析为 true。例如，以下查询测试具有单色显示或悬停功能的设备：

```css
@media (not (color)) or (hover) { ... 
```

##### 响应式设计实践

1. 设置 [meta](https://juejin.cn/post/6844904083296370702#heading-11) 标签

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
```

###### viewpoint

viewpoint：屏幕上用于显示网页的一块区域（可能比浏览器的视区要宽，也可能要窄）

该meta标签为 viewport（视口）的初始大小提供指示。目前**仅用于移动设备**。

###### viewpoint理论

移动设备上的viewpoint可分为：

1）**layout viewpoint** （如显示器的宽度，大于浏览器的可视宽度）

 2）**visual viewpoint** （浏览器的可视宽度，和浏览器的大小相同）

  3）**ideal viewpoint** (移动设备的理想宽度，随移动设备的大小不同而不同)

利用<meta>元数据标签对viewpoint进行控制

```css
<meta name="viewpoint" content="width=device-width", initial-scale="1.0">
```

**content="width=device-width"** 表示viewponit的宽度采用设备宽度（即ideal viewpoint的宽度)

**initial-scale="1.0"** 表示缩放比例为1.0，也就是viewpoint的一倍，也就是和ideal viewpoint是一样的

2.使用 [@media](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FLearn%2FCSS%2FCSS_layout%2FMedia_queries) 设置样式

```css
// 屏幕大于 1024px 或小于 1440px 时应用该样式
@media screen and (min-width: 1024px) and (max-width: 1440px) { 
  ...
}
```

3.依据要求并结合屏幕尺寸设置布局分界点

```css
// 屏幕大于 1440px 时应用该样式
@media screen and (min-width: 1441px) { 
  ...
}

// 屏幕大于 1024px 或小于 1440px 时应用该样式
@media screen and (min-width: 1024px) and (max-width: 1440px) { 
  ...
}
```

**说明：**设置布局分界点时需要注意样式的先后顺序，后面的 `@media` 范围不应该包含前面的范围（满足条件时，后面的样式会覆盖前面的样式）

##### 常见的屏幕尺寸

```yaml
复制代码分辨率   比例 | 设备尺寸

1024 * 500		（8.9 寸）
1024 * 768		（4 : 3  | 10.4 寸、12.1 寸、14.1 寸、15 寸）
1280 * 800		（16 : 10  |15.4 寸）
1280 * 1024		（5：4  | 14.1寸、15.0寸）
1280 * 854		（15 : 10 | 15.2）
1366 * 768		（16：9 | 不常见）
1440 * 900		（16：10  17寸 仅苹果用）
1440 * 1050		（5：4  | 14.1寸、15.0寸）
1600 * 1024		（14：9 | 不常见）
1600 * 1200		（4：3 | 15、16.1）
1680 * 1050		（16：10 | 1
```

#### **BFC**(块格式化上下文)

##### **什么是**BFC

W3C 上对 BFC 的定义：

原文：Floats, absolutely positioned elements, block containers (such as inline-blocks, table

cells, and table-captions) that are not block boxes, and block boxes with 'overflow' other than

'visible' (except when that value has been propagated to the viewport) establish new block

formatting contexts for their contents.

译文：浮动、绝对定位元素、不是块盒子的块容器（如 inline-blocks 、 table-cells 和table-captions ），以及 overflow 属性的值除 visible 以外的块盒，将为其内容建立新的块格式化上下文。

即·`W3C`官方解释为：`BFC`它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，`Block Formatting Context`提供了一个环境，`HTML`在这个环境中按照一定的规则进行布局。

MDN 上对 BFC 的描述：

**块格式化上下文（****Block Formatting Context****，****BFC****）** 是 Web 页面的可视 CSS 渲染的一部分，

是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

更加通俗的描述：

1. BFC 是 Block Formatting Context （**块级格式上下文**），可以理解成元素的一个“特异功能”。

2. 该 “特异功能”，在默认的情况下处于关闭状态；当元素满足了某些条件后，该“特异功能”被激活。

3. 所谓激活“特异功能”，专业点说就是：该元素创建了 BFC （又称：开启了 BFC ）
4. `BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用`BFC`呢，`BFC`可以看做是一个`CSS`元素属性

##### 怎样触发BFC

这里简单列举几个触发`BFC`使用的`CSS`属性

- overflow: hidden
- display: inline-block
- position: absolute
- position: fixed
- display: table-cell
- display: flex

##### BFC的规则

- `BFC`就是一个块级元素，块级元素会在垂直方向一个接一个的排列
- `BFC`就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签
- 垂直方向的距离由margin决定， 属于同一个`BFC`的两个相邻的标签外边距会发生重叠
- 计算`BFC`的高度时，浮动元素也参与计算

##### **元素开启了**BFC能解决什么问题**

1. 元素开启 BFC 后，其子元素不会再产生 margin 塌陷问题。

2. 元素开启 BFC 后，自己不会被其他浮动元素所覆盖。

3. 元素开启 BFC 后，就算其子元素浮动，元素自身高度也不会塌陷。
4. [举例]([面试官：请说说什么是BFC？大白话讲清楚 - 掘金 (juejin.cn)](https://juejin.cn/post/6950082193632788493))

**3.** **如何开启****BFC**

- 根元素
- 浮动元素
- 绝对定位、固定定位的元素
- 行内块元素
- 表格单元格： table 、 thead 、 tbody 、 tfoot 、 th 、 td 、 tr 、 caption
- overflow 的值不为 visible 的块元素
- 伸缩项目
- 多列容器
- column-span 为 all 的元素（即使该元素没有包裹在多列容器中）
- display 的值，设置为 flow-root

## Javascript

### 什么是Javascript？

[JavaScript](https://developer.mozilla.org/zh-CN/docs/Glossary/JavaScript)（缩写：JS）是一门完备的动态编程语言。由布兰登·艾克（Brendan Eich，Mozilla 项目、Mozilla 基金会和 Mozilla 公司的联合创始人）发明。

JavaScript 是一种脚本编程语言，它可以在网页上实现复杂的功能，网页展现给你的不再是简单的静态信息，而是**实时的内容更新**——交互式的地图、2D/3D 动画、滚动播放的视频等等——JavaScript 就在其中。

**因为它是解释型语言，意味着它不像其他编程语言一样由单独的源文件产生编译后形成源代码，而是通过集成在某个大型应用程序（如浏览器，当应用于 [HTML](https://developer.mozilla.org/zh-CN/docs/Glossary/HTML) 文档时，可为网站提供动态交互特性。）内的解释器来逐条实时执行js代码。**

注意，js不需要被编译为机器码，它的原理是浏览器的解释器通过解析字符串（用正则表达式等）后执行原有的特定机器码，即直接执行

同时，JavaScript是一门动态语言，所谓的动态语言可以暂时理解为在语言中的一切内容都是不确定的。比如一个变量，这一时刻是个整型，下一时刻可能会变成字符串了。

### 和Java的区别

JS是解释型语言，java是编译型语言

JS是动态类型语言，java是静态类型语言

JS是基于对象，java是面向对象

JS可以直接在任何浏览器上运行，java需要借助于虚拟机实现跨平台

JS的安全性会更好，不会读取本地数据

高级语言都需要翻译成机器语言才能执行

解释型语言：执行时由解释器逐条翻译并执行

编译型语言：执行前先由编译器全部翻译，再执行

编译型语言执行速度更快，解释型语言最主要的是安全性

JS与其他基于类的面向对象的语言有差异，JS的对象具有动态性，在使用对象时可以为对象添加属性和方法。

面向对象和基于对象的说法在JS的不同版本中都有提到。

### JavaScript的历史

要了解JavaScript，我们首先要回顾一下JavaScript的诞生。

在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。

由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。

为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。

### ECMAScript

因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。

所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。

那为什么不直接把JavaScript定为标准呢？因为JavaScript是网景的注册商标。

不过大多数时候，我们还是用JavaScript这个词。如果你遇到ECMAScript这个词，简单把它替换为JavaScript就行了。

所以ES可以理解为是JavaScript的版本规范，ES几就是第几版的Javascript。

### JavaScript版本

JavaScript语言是在10天时间内设计出来的，虽然语言的设计者水平非常NB，但谁也架不住“时间紧，任务重”，所以，JavaScript有很多设计缺陷，我们后面会慢慢讲到。

此外，由于JavaScript的标准——ECMAScript在不断发展，最新版ECMAScript 6标准（简称ES6）已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。

由于浏览器在发布时就确定了JavaScript的版本，加上很多用户还在使用IE6这种古老的浏览器，这就导致你在写JavaScript的时候，要照顾一下老用户，不能一上来就用最新的ES6标准写，否则，老用户的浏览器是无法运行新版本的JavaScript代码的。

不过，JavaScript的核心语法并没有多大变化。

我们已经知道ECMAScript是JavaScript标准，所以一般情况下

这两个词我们认为是一个意思。

• 但是实际上JavaScript的含义却要更大一些。

• 一个完整的JavaScript实现应该由以下三个部分构成

![img](https://upload-images.jianshu.io/upload_images/28917406-c76b2a14b6f3b662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 浏览器与js

几乎所有的浏览器都带有js解释器，可以读取解析并执行相应的指令，从而可以达到操作浏览器api以及DOM文档元素的作用。

JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到`<head>`中：

```html
<html>
<head>
  <script>
    alert('Hello, world');
  </script>
</head>
<body>
  ...
</body>
</html>
```

由`<script>...</script>`包含的代码就是JavaScript代码，它将直接被浏览器执行。

第二种方法是把JavaScript代码放到一个单独的`.js`文件，然后在HTML中通过`<script src="..."></script>`引入这个文件：

```html
<html>
<head>
  <script src="/static/js/abc.js"></script>
</head>
<body>
  ...
</body>
</html>
```

这样，`/static/js/abc.js`就会被浏览器执行。

把JavaScript代码放入一个单独的`.js`文件中更利于维护代码，并且多个页面可以各自引用同一份`.js`文件。

可以在同一个页面中引入多个`.js`文件，还可以在页面中多次编写`<script> js代码... </script>`，浏览器按照顺序依次执行。

有些时候你会看到`<script>`标签还设置了一个`type`属性：

```html
<script type="text/javascript">
  ...
</script>
```

### ES basics+ES5

#### 基础语法

首先让我们了解一下js的基础语法

JavaScript的语法和Java语言类似，每个语句以`;`结束，语句块用`{...}`。但是，JavaScript并不强制要求在每个语句的结尾加`;`，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上`;`。

 让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。在本教程中，我们不会省略;，所有语句都会添加;。

例如，下面的一行代码就是一个完整的赋值语句：

```js
var x = 1;
```

下面的一行代码是一个字符串，但仍然可以视为一个完整的语句：

```js
'Hello, world';
```

下面的一行代码包含两个语句，每个语句用`;`表示语句结束：

```js
var x = 1; var y = 2; // 不建议一行写多个语句!
```

语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行`{...}`中的所有语句：

```js
if (2 > 1) {
    x = 1;
    y = 2;
    z = 3;
}
```

注意花括号`{...}`内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功能，可以帮助整理代码。

`{...}`还可以嵌套，形成层级结构：

```js
if (2 > 1) {
    x = 1;
    y = 2;
    z = 3;
    if (x < y) {
        z = 4;
    }
    if (x > y) {
        z = 5;
    }
}
```

JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。

#### 注释

以`//`开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：

```js
// 这是一行注释
alert('hello'); // 这也是注释
```

另一种块注释是用`/*...*/`把多行字符包裹起来，把一大“块”视为一个注释：

```js
/* 从这里开始是块注释
仍然是注释
仍然是注释
注释结束 */
```

#### 数据类型

计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型：

##### Number

JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：

```js
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
```

计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：`0xff00`，`0xa5b4c3d2`，等等，它们和十进制表示的数值完全一样。

Number可以直接做四则运算，规则和数学一致：

```js
1 + 2; // 3
(1 + 2) * 5 / 2; // 7.5
2 / 0; // Infinity
0 / 0; // NaN
10 % 3; // 1
10.5 % 3; // 1.5
```

注意`%`是求余运算。

要注意，JavaScript的Number不区分整数和浮点数，也就是说，`12.00 === 12`。（在大多数其他语言中，整数和浮点数不能直接比较）并且，JavaScript的整数最大范围不是±263，而是±253，因此，超过253的整数就可能无法精确表示

##### 字符串

字符串是以单引号'或双引号"括起来的任意文本，比如`'abc'`，`"xyz"`等等。请注意，`''`或`""`本身只是一种表示方式，不是字符串的一部分，因此，字符串`'abc'`只有`a`，`b`，`c`这3个字符。

##### 布尔值

布尔值和布尔代数的表示完全一致，一个布尔值只有`true`、`false`两种值，要么是`true`，要么是`false`，可以直接用`true`、`false`表示布尔值，也可以通过布尔运算计算出来：

```js
true; // 这是一个true值
false; // 这是一个false值
2 > 1; // 这是一个true值
2 >= 3; // 这是一个false值
```

`&&`运算是与运算，只有所有都为`true`，`&&`运算结果才是`true`：

```js
true && true; // 这个&&语句计算结果为true
true && false; // 这个&&语句计算结果为false
false && true && false; // 这个&&语句计算结果为false
```

`||`运算是或运算，只要其中有一个为`true`，`||`运算结果就是`true`：

```js
false || false; // 这个||语句计算结果为false
true || false; // 这个||语句计算结果为true
false || true || false; // 这个||语句计算结果为true
```

`!`运算是非运算，它是一个单目运算符，把`true`变成`false`，`false`变成`true`：

```js
! true; // 结果为false
! false; // 结果为true
! (2 > 5); // 结果为true
```

布尔值经常用在条件判断中，比如：

```js
var age = 15;
if (age >= 18) {
    alert('adult');
} else {
    alert('teenager');
}
```

##### 比较运算符

当我们对Number做比较时，可以通过比较运算符得到一个布尔值：

```js
2 > 5; // false
5 >= 2; // true
7 == 7; // true
```

实际上，JavaScript允许对任意数据类型做比较：

```js
false == 0; // true
false === 0; // false
```

要特别注意相等运算符`==`。JavaScript在设计时，有两种比较运算符：

第一种是`==`比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；

第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回`false`，如果一致，再比较。

由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。

另一个例外是`NaN`这个特殊的Number与所有其他值都不相等，包括它自己：

```js
NaN === NaN; // false
```

唯一能判断`NaN`的方法是通过`isNaN()`函数：

```js
isNaN(NaN); // true
```

最后要注意浮点数的相等比较：

```js
1 / 3 === (1 - 2 / 3); // false
```

这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：

```js
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

##### BigInt

要精确表示比253还大的整数，可以使用内置的BigInt类型，它的表示方法是在整数后加一个`n`，例如`9223372036854775808n`，也可以使用`BigInt()`把Number和字符串转换成BigInt：

```js
// 使用BigInt: 
var bi1 = 9223372036854775807n;
var bi2 = BigInt(12345);
var bi3 = BigInt("0x7fffffffffffffff");
console.log(bi1 === bi2); // false
console.log(bi1 === bi3); // true
console.log(bi1 + bi2);

```

##### null和undefined

`null`表示一个“空”的值，它和`0`以及空字符串`''`不同，`0`是一个数值，`''`表示长度为0的字符串，而`null`表示“空”。

在其他语言中，也有类似JavaScript的`null`的表示，例如Java也用`null`，Swift用`nil`，Python用`None`表示。但是，在JavaScript中，还有一个和`null`类似的`undefined`，它表示“未定义”。

JavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。

##### 数组

数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：

```js
[1, 2, 3.14, 'Hello', null, true];
```

上述数组包含6个元素。数组用`[]`表示，元素之间用`,`分隔。

另一种创建数组的方法是通过`Array()`函数实现：

```js
new Array(1, 2, 3); // 创建了数组[1, 2, 3]
```

然而，出于代码的可读性考虑，强烈建议直接使用`[]`。

数组的元素可以通过索引来访问。请注意，索引的起始值为`0`：

```js
var arr = [1, 2, 3.14, 'Hello', null, true];
arr[0]; // 返回索引为0的元素，即1
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
```

##### 对象

JavaScript的对象是一组由键-值组成的无序集合，例如：

```js
var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};
```

JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`'Bob'`，`zipcode`属性为`null`。

要获取一个对象的属性，我们用`对象变量.属性名`的方式：

```js
person.name; // 'Bob'
person.zipcode; // null
```

##### 变量

变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。

变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、`$`和`_`的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如`if`、`while`等。申明一个变量用`var`语句，比如：

```js
var a; // 申明了变量a，此时a的值为undefined
var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1
var s_007 = '007'; // s_007是一个字符串
var Answer = true; // Answer是一个布尔值true
var t = null; // t的值是null
```

变量名也可以用中文，但是，请不要给自己找麻烦。

在JavaScript中，使用等号`=`对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用`var`申明一次，例如：

```js
var a = 123; // a的值是整数123
a = 'ABC'; // a变为字符串
```

这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：

```js
int a = 123; // a是整数类型变量，类型用int申明
a = "ABC"; // 错误：不能把字符串赋给整型变量
```

和静态语言相比，动态语言更灵活，就是这个原因。

请不要把赋值语句的等号等同于数学的等号。比如下面的代码：

```js
var x = 10;
x = x + 2;
```

如果从数学上理解`x = x + 2`那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式`x + 2`，得到结果`12`，再赋给变量`x`。由于`x`之前的值是`10`，重新赋值后，`x`的值变成`12`。

要显示变量的内容，可以用`console.log(x)`，打开Chrome的控制台就可以看到结果。

```js
// 打印变量x
var x = 100;
console.log(x);
```

使用`console.log()`代替`alert()`的好处是可以避免弹出烦人的对话框。

#### strict模式

JavaScript在设计之初，为了方便初学者学习，并不强制要求用`var`申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过`var`申明就被使用，那么该变量就自动被申明为全局变量：

```js
i = 10; // i现在是全局变量
```

在同一个页面的不同的JavaScript文件中，如果都不用`var`申明，恰好都使用了变量`i`，将造成变量`i`互相影响，产生难以调试的错误结果。

使用`var`申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。

为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过`var`申明变量，未使用`var`申明变量就使用的，将导致运行错误。

启用strict模式的方法是在JavaScript代码的第一行写上：

```js
'use strict';
```

这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。

`'use strict'; // 如果浏览器支持strict模式， // 下面的代码将报ReferenceError错误: ` 

```js
abc = 'Hello, world';
console.log(abc);
```

不用`var`申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。

#### 字符串

JavaScript的字符串就是用`''`或`""`括起来的字符表示。

如果`'`本身也是一个字符，那就可以用`""`括起来，比如`"I'm OK"`包含的字符是`I`，`'`，`m`，空格，`O`，`K`这6个字符。

如果字符串内部既包含`'`又包含`"`怎么办？可以用转义字符`\`来标识，比如：

```js
'I\'m \"OK\"!';
```

表示的字符串内容是：`I'm "OK"!`

转义字符`\`可以转义很多字符，比如`\n`表示换行，`\t`表示制表符，字符`\`本身也要转义，所以`\\`表示的字符就是`\`。

ASCII字符可以以`\x##`形式的十六进制表示，例如：

```js
'\x41'; // 完全等同于 'A'
```

还可以用`\u####`表示一个Unicode字符：

```js
'\u4e2d\u6587'; // 完全等同于 '中文'
```

##### 多行字符串

由于多行字符串用`\n`写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号`...`表示：

```
`这是一个
多行
字符串`;
```

*注意*：反引号在键盘的ESC下方，数字键1的左边：

```ascii
┌─────┐ ┌─────┬─────┬─────┬─────┐
│ ESC │ │ F1  │ F2  │ F3  │ F4  │
│     │ │     │     │     │     │
└─────┘ └─────┴─────┴─────┴─────┘
┌─────┬─────┬─────┬─────┬─────┐
│  ~  │  !  │  @  │  #  │  $  │
│  `  │  1  │  2  │  3  │  4  │
├─────┴──┬──┴──┬──┴──┬──┴──┬──┘
│        │     │     │     │
│  tab   │  Q  │  W  │  E  │
├────────┴──┬──┴──┬──┴──┬──┘
│           │     │     │
│ caps lock │  A  │  S  │
└───────────┴─────┴─────┘
```

##### 模板字符串

要把多个字符串连接起来，可以用`+`号连接：

```js
let name = '小明';
let age = 20;
let message = '你好, ' + name + ', 你今年' + age + '岁了!';
alert(message);
```

如果有很多变量需要连接，用`+`号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
let name = '小明';
let age = 20;
let message = `你好, ${name}, 你今年${age}岁了!`;
alert(message);
```

##### 操作字符串

字符串常见的操作如下：

```js
var s = 'Hello, world!';
s.length; // 13
```

要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：

```js
var s = 'Hello, world!';

s[0]; // 'H'
s[6]; // ' '
s[7]; // 'w'
s[12]; // '!'
s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined
```

*需要特别注意的是*，**字符串是不可变的**，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：

```js
var s = 'Test';
s[0] = 'X';
alert(s); // s仍然为'Test'
```

JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：

##### toUpperCase

`toUpperCase()`把一个字符串全部变为大写：

```js
var s = 'Hello';
s.toUpperCase(); // 返回'HELLO'
```

##### toLowerCase

`toLowerCase()`把一个字符串全部变为小写：

```js
var s = 'Hello';
var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower
lower; // 'hello'
```

##### indexOf

`indexOf()`会搜索指定字符串出现的位置：

```js
var s = 'hello, world';
s.indexOf('world'); // 返回7
s.indexOf('World'); // 没有找到指定的子串，返回-1
```

##### substring

`substring()`返回指定索引区间的子串：

```js
var s = 'hello, world'
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

#### 数组

JavaScript的`Array`可以包含任意数据类型，并通过索引来访问每个元素。

要取得`Array`的长度，直接访问`length`属性：

```js
// Array.length: let arr = [1, 2, 3.14, 'Hello', null, true]; 
console.log(arr.length); // 6
```

数组在js语言的底层其实是被当做是对象来看待，所以具备length属性，并且元素类型和长度可以灵活调节。

*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：

```js
let arr = ['A', 'B', 'C']; console.log(arr.length); // 3
// 调整数组大小:
arr.length = 6;
console.log(arr); // arr变为['A', 'B', 'C', undefined, undefined, undefined]
// 调整数组大小:
arr.length = 2;
console.log(arr); // arr变为['A', 'B']
```

`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：

```js
// Array index: 
let arr = ['A', 'B', 'C']; 
arr[1] = 99;
console.log(arr); // arr现在变为['A', 99, 'C']
console.log(arr[1]); // 99
```

*请注意*，如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：

```js
// 索引超出范围会导致数组大小自动调整: 
let arr = ['A', 'B', 'C']; 
arr[5] = 'x';
console.log(arr); // arr变为['A', 'B', 'C', undefined, undefined, 'x']

```

大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的`Array`却不会有任何错误。在编写代码时，不建议直接修改`Array`的大小，访问索引时要确保索引不会越界。

##### indexOf

与String类似，`Array`也可以通过`indexOf()`来搜索一个指定的元素的位置：

```js
var arr = [10, 20, '30', 'xyz'];
arr.indexOf(10); // 元素10的索引为0
arr.indexOf(20); // 元素20的索引为1
arr.indexOf(30); // 元素30没有找到，返回-1
arr.indexOf('30'); // 元素'30'的索引为2
```

注意了，数字`30`和字符串`'30'`是不同的元素。

##### slice

`slice()`就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`：

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']
```

注意到`slice()`的起止参数包括开始索引，不包括结束索引。

如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个`Array`：

```js
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false
```

##### push和pop

`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：

```js
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
arr; // []
```

**注意，push和pop都只返回原数组**

##### unshift和shift

如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：

```js
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
arr; // []
```

##### sort

`sort()`可以对当前`Array`进行排序，它会直接修改当前`Array`的元素位置，直接调用时，按照默认顺序排序：

```js
var arr = ['B', 'C', 'A'];
arr.sort();
arr; // ['A', 'B', 'C']
```

能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。

##### reverse

`reverse()`把整个`Array`的元素给调个个，也就是反转：

```js
var arr = ['one', 'two', 'three'];
arr.reverse(); 
arr; // ['three', 'two', 'one']
```

##### splice

`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：

```js
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
```

##### concat

`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`：

```js
var arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
```

*请注意*，`concat()`方法并没有修改当前`Array`，而是返回了一个新的`Array`。

实际上，`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：

```js
var arr = ['A', 'B', 'C'];
arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
```

##### join

`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：

```js
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
```

如果`Array`的元素不是字符串，将自动转换为字符串后再连接。

#### 多维数组

如果数组的某个元素又是一个`Array`，则可以形成多维数组，例如：

```js
var arr = [[1, 2, 3], [400, 500, 600], '-'];
```

上述`Array`包含3个元素，其中头两个元素本身也是`Array`

上述如何取到第二个数组内的500？

```js
arr[1][1]
```

#### 对象

JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。

JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
```

JavaScript用一个`{...}`表示一个对象，键值对以`xxx: xxx`形式申明，用`,`隔开。注意，最后一个键值对不需要在末尾加`,`，如果加了，有的浏览器（如低版本的IE）将报错。

上述对象申明了一个`name`属性，值是`'小明'`，`birth`属性，值是`1990`，以及其他一些属性。最后，把这个对象赋值给变量`xiaoming`后，就可以通过变量`xiaoming`来获取小明的属性了：

```js
xiaoming.name; // '小明'
xiaoming.birth; // 1990
```

访问属性是通过`.`操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用`''`括起来：

```js
var xiaohong = {
    name: '小红',
    'middle-school': 'No.1 Middle School'
};
```

`xiaohong`的属性名`middle-school`不是一个有效的变量，就需要用`''`括起来。访问这个属性也无法使用`.`操作符，必须用`['xxx']`来访问：

```js
xiaohong['middle-school']; // 'No.1 Middle School'
xiaohong['name']; // '小红'
xiaohong.name; // '小红'
```

也可以用`xiaohong['name']`来访问`xiaohong`的`name`属性，不过`xiaohong.name`的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过`object.prop`的形式访问一个属性了。

实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。

如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回`undefined`：

`'use strict'; var xiaoming = {    name: '小明' }; ` Run

由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
```

如果我们要检测`xiaoming`是否拥有某一属性，可以用`in`操作符：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
```

不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，它可能是`xiaoming`继承得到的：

```js
'toString' in xiaoming; // true
```

因为`toString`定义在`object`对象中，而所有对象最终都会在原型链上指向`object`，所以`xiaoming`也拥有`toString`属性。

要判断一个属性是否是`xiaoming`自身拥有的，而不是继承得到的，可以用`hasOwnProperty()`方法：

```js
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false
```

#### 条件判断

JavaScript使用`if () { ... } else { ... }`来进行条件判断。例如，根据年龄显示不同内容，可以用`if`语句实现如下：

```js
var age = 20;
if (age >= 18) { // 如果age >= 18为true，则执行if语句块
    alert('adult');
} else { // 否则执行else语句块
    alert('teenager');
}
```

其中`else`语句是可选的。如果语句块只包含一条语句，那么可以省略`{}`：

```js
var age = 20;
if (age >= 18)
    alert('adult');
else
    alert('teenager');
```

省略`{}`的危险之处在于，如果后来想添加一些语句，却忘了写`{}`，就改变了`if...else...`的语义，例如：

```js
var age = 20;
if (age >= 18)
    alert('adult');
else
    console.log('age < 18'); // 添加一行日志
    alert('teenager'); // <- 这行语句已经不在else的控制范围了
```

上述代码的`else`子句实际上只负责执行`console.log('age < 18');`，原有的`alert('teenager');`已经不属于`if...else...`的控制范围了，它每次都会执行。

相反地，有`{}`的语句就不会出错：

```js
var age = 20;
if (age >= 18) {
    alert('adult');
} else {
    console.log('age < 18');
    alert('teenager');
}
```

这就是为什么我们建议永远都要写上`{}`。

#### 多行条件判断

如果还要更细致地判断条件，可以使用多个`if...else...`的组合：

```js
var age = 3;
if (age >= 18) {
    alert('adult');
} else if (age >= 6) {
    alert('teenager');
} else {
    alert('kid');
}
```

上述多个`if...else...`的组合实际上相当于两层`if...else...`：

```js
var age = 3;
if (age >= 18) {
    alert('adult');
} else {
    if (age >= 6) {
        alert('teenager');
    } else {
        alert('kid');
    }
}
```

但是我们通常把`else if`连写在一起，来增加可读性。这里的`else`略掉了`{}`是没有问题的，因为它只包含一个`if`语句。注意最后一个单独的`else`不要略掉`{}`。

*请注意*，`if...else...`语句的执行特点是二选一，在多个`if...else...`语句中，如果某个条件成立，则后续就不再继续判断了。

由于`age`的值为`20`，它实际上同时满足条件`age >= 6`和`age >= 18`，这说明条件判断的顺序非常重要。请修复后让其显示`adult`。

如果`if`的条件判断语句结果不是`true`或`false`怎么办？例如：

```js
var s = '123';
if (s.length) { // 条件计算结果为3
    //
}
```

JavaScript把`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`，因此上述代码条件判断的结果是`true`。

#### 循环

要计算1+2+3，我们可以直接写表达式：

```
1 + 2 + 3; // 6
```

要计算1+2+3+...+10，勉强也能写出来。

但是，要计算1+2+3+...+10000，直接写表达式就不可能了。

为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。

JavaScript的循环有两种，一种是`for`循环，通过初始条件、结束条件和递增条件来循环执行语句块：

```js
var x = 0;
var i;
for (i=1; i<=10000; i++) {
    x = x + i;
}
x; // 50005000
```

让我们来分析一下`for`循环的控制条件：

- i=1 这是初始条件，将变量i置为1；
- i<=10000 这是判断条件，满足时就继续循环，不满足就退出循环；
- i++ 这是每次循环后的递增条件，由于每次循环后变量i都会加1，因此它终将在若干次循环后不满足判断条件`i<=10000`而退出循环。

`for`循环最常用的地方是利用索引来遍历数组：

```js
var arr = ['Apple', 'Google', 'Microsoft'];
var i, x;
for (i=0; i<arr.length; i++) {
    x = arr[i];
    console.log(x);
}
```

`for`循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用`break`语句退出循环，否则就是死循环：

```js
var x = 0;
for (;;) { // 将无限循环下去
    if (x > 100) {
        break; // 通过if判断来退出循环
    }
    x ++;
}
```

##### for ... in

`for`循环的一个变体是`for ... in`循环，它可以把一个对象的所有属性依次循环出来：

```js
var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    console.log(key); // 'name', 'age', 'city'
}
```

要过滤掉对象继承的属性，用`hasOwnProperty()`来实现：

```js
var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    if (o.hasOwnProperty(key)) {
        console.log(key); // 'name', 'age', 'city'
    }
}
```

由于`Array`也是对象，而它的每个元素的索引被视为对象的属性，因此，`for ... in`循环可以直接循环出`Array`的索引：

```js
var a = ['A', 'B', 'C'];
for (var i in a) {
    console.log(i); // '0', '1', '2'
    console.log(a[i]); // 'A', 'B', 'C'
}
```

*请注意*，`for ... in`对`Array`的循环得到的是`String`而不是`Number`。

##### while

`for`循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的`for`循环容易让人看不清循环的逻辑，此时用`while`循环更佳。

`while`循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：

```js
var x = 0;
var n = 99;
while (n > 0) {
    x = x + n;
    n = n - 2;
}
x; // 2500
```

在循环内部变量`n`不断自减，直到变为`-1`时，不再满足`while`条件，循环退出。

##### do ... while

最后一种循环是`do { ... } while()`循环，它和`while`循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：

```js
var n = 0;
do {
    n = n + 1;
} while (n < 100);
n; // 100
```

用`do { ... } while()`循环要小心，循环体会至少执行1次，而`for`和`while`循环则可能一次都不执行。

#### 函数

##### 定义函数

在JavaScript中，定义函数的方式如下：

```js
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

上述`abs()`函数的定义如下：

- `function`指出这是一个函数定义；
- `abs`是函数的名称；
- `(x)`括号内列出函数的参数，多个参数以`,`分隔；
- `{ ... }`之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。

请注意，函数体内部的语句在执行时，一旦执行到`return`时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。

如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`undefined`。

由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。

因此，第二种定义函数的方式如下：

```js
var abs = function (x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
};
```

在这种方式下，`function (x) { ... }`是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量`abs`，所以，通过变量`abs`就可以调用该函数。

上述两种定义*完全等价*，注意第二种方式按照完整语法需要在函数体末尾加一个`;`，表示赋值语句结束。

##### 调用函数

调用函数时，按顺序传入参数即可：

```js
abs(10); // 返回10
abs(-9); // 返回9
```

由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：

```js
abs(10, 'blablabla'); // 返回10
abs(-9, 'haha', 'hehe', null); // 返回9
```

传入的参数比定义的少也没有问题：

```js
abs(); // 返回NaN
```

此时`abs(x)`函数的参数`x`将收到`undefined`，计算结果为`NaN`。

要避免收到`undefined`，可以对参数进行检查：

```js
function abs(x) {
    if (typeof x !== 'number') {
        throw 'Not a number';
    }
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
```

##### arguments

JavaScript还有一个免费赠送的关键字`arguments`，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。`arguments`类似`Array`但它不是一个`Array`：

`'use strict' `

```js
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
```

利用`arguments`，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：

```js
function abs() {
    if (arguments.length === 0) {
        return 0;
    }
    var x = arguments[0];
    return x >= 0 ? x : -x;
}

abs(); // 0
abs(10); // 10
abs(-9); // 9
```

实际上`arguments`最常用于判断传入参数的个数。你可能会看到这样的写法：

```js
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
```

要把中间的参数`b`变为“可选”参数，就只能通过`arguments`判断，然后重新调整参数并赋值。

##### rest参数

由于JavaScript函数允许接收任意个参数，于是我们就不得不用`arguments`来获取所有参数：

```js
function foo(a, b) {
    var i, rest = [];
    if (arguments.length > 2) {
        for (i = 2; i<arguments.length; i++) {
            rest.push(arguments[i]);
        }
    }
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}
```

为了获取除了已定义参数`a`、`b`之外的参数，我们不得不用`arguments`，并且循环要从索引`2`开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的`rest`参数，有没有更好的方法？

ES6标准引入了rest参数，上面的函数可以改写为：

```js
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

rest参数只能写在最后，前面用`...`标识，从运行结果可知，传入的参数先绑定`a`、`b`，多余的参数以数组形式交给变量`rest`，所以，不再需要`arguments`我们就获取了全部参数。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是`undefined`）。

因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。请用rest参数编写一个`sum()`函数，接收任意个参数并返回它们的和：

```js
'use strict'; ``// 测试: 
var i, args = []; for (i=1; i<=100; i++) {    args.push(i); } if (sum() !== 0) {    console.log('测试失败: sum() = ' + sum()); } else if (sum(1) !== 1) {    console.log('测试失败: sum(1) = ' + sum(1)); } else if (sum(2, 3) !== 5) {    console.log('测试失败: sum(2, 3) = ' + sum(2, 3)); } else if (sum.apply(null, args) !== 5050) {    console.log('测试失败: sum(1, 2, 3, ..., 100) = ' + sum.apply(null, args)); } else {    console.log('测试通过!'); }
```

##### 小心你的return语句

前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：

```js
function foo() {
    return { name: 'foo' };
}

foo(); // { name: 'foo' }
```

如果把return语句拆成两行：

```js
function foo() {
    return
        { name: 'foo' };
}

foo(); // undefined
```

*要小心了*，由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了：

```js
function foo() {
    return; // 自动添加了分号，相当于return undefined;
        { name: 'foo' }; // 这行语句已经没法执行到了
}
```

所以正确的多行写法是：

```js
function foo() {
    return { // 这里不会自动加分号，因为{表示语句尚未结束
        name: 'foo'
    };
}
```

##### 变量作用域和解构赋值

在JavaScript中，用`var`申明的变量实际上是有作用域的。

如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：

```js
'use strict';

function foo() {
    var x = 1;
    x = x + 1;
}

x = x + 2; // ReferenceError! 无法在函数体外引用变量x
```

如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：

```js
'use strict';

function foo() {
    var x = 1;
    x = x + 1;
}

function bar() {
    var x = 'A';
    x = x + 'B';
}
```

由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：

```js
'use strict';

function foo() {
    var x = 1;
    function bar() {
        var y = x + 1; // bar可以访问foo的变量x!
    }
    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
}
```

如果内部函数和外部函数的变量名重名怎么办？

JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。

###### 变量提升

JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：

```js
'use strict';

function foo() {
    var x = 'Hello, ' + y;
    console.log(x);
    var y = 'Bob';
}

foo();
```

虽然是strict模式，但语句`var x = 'Hello, ' + y;`并不报错，原因是变量`y`在稍后申明了。但是`console.log`显示`Hello, undefined`，说明变量`y`的值为`undefined`。这正是因为JavaScript引擎自动提升了变量`y`的声明，但不会提升变量`y`的赋值。

对于上述`foo()`函数，JavaScript引擎看到的代码相当于：

```js
function foo() {
    var y; // 提升变量y的申明，此时y为undefined
    var x = 'Hello, ' + y;
    console.log(x);
    y = 'Bob';
}
```

由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个`var`申明函数内部用到的所有变量：

```js
function foo() {
    var
        x = 1, // x初始化为1
        y = x + 1, // y初始化为2
        z, i; // z和i为undefined
    // 其他语句:
    for (i=0; i<100; i++) {
        ...
    }
}
```

###### 全局作用域

不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript在浏览器内默认有一个全局对象`window`，全局作用域的变量实际上被绑定到`window`的一个属性：

```js
'use strict';

var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript'
```

因此，直接访问全局变量`course`和访问`window.course`是完全一样的。

你可能猜到了，由于函数定义有两种方式，以变量方式`var foo = function () {}`定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到`window`对象：

```js
'use strict';

function foo() {
    alert('foo');
}

foo(); // 直接调用foo()
window.foo(); // 通过window.foo()调用
```

进一步大胆地猜测，我们每次直接调用的`alert()`函数其实也是`window`的一个变量：

```js
'use strict'; 
window.alert('调用window.alert()'); // 把alert保存到另一个变量: 
var old_alert = window.alert; // 给alert赋一个新函数: 
window.alert = function () {} ``// 恢复alert: 
window.alert = old_alert; 
alert('又可以用alert()了!'); 
```

这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报`ReferenceError`错误。

###### 名字空间

全局变量会绑定到`window`上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。

减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：

```js
// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = 'myapp';
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return 'foo';
};
```

把自己的代码全部放入唯一的名字空间`MYAPP`中，会大大减少全局变量冲突的可能。

许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。

###### 局部作用域

由于JavaScript的变量作用域实际上是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：

```js
'use strict';

function foo() {
    for (var i=0; i<100; i++) {
        //
    }
    i += 100; // 仍然可以引用变量i
}
```

为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量：

```js
'use strict';

function foo() {
    var sum = 0;
    for (let i=0; i<100; i++) {
        sum += i;
    }
    // SyntaxError:
    i += 1;
}
```

###### 常量

由于`var`和`let`申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：

```js
var PI = 3.14;
```

ES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：

```js
'use strict';

const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

##### 方法

------

在一个对象中绑定函数，称为这个对象的方法。

在JavaScript中，对象的定义是这样的：

```js
var xiaoming = {
    name: '小明',
    birth: 1990
};
```

但是，如果我们给`xiaoming`绑定一个函数，就可以做更多的事情。比如，写个`age()`方法，返回`xiaoming`的年龄：

```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
```

绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个`this`关键字，这个东东是什么？

在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。

让我们拆开写：

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

单独调用函数`getAge()`怎么返回了`NaN`？*请注意*，我们已经进入到了JavaScript的一个大坑里。

JavaScript的函数内部如果调用了`this`，那么这个`this`到底指向谁？

答案是，视情况而定！

如果以对象的方法形式调用，比如`xiaoming.age()`，该函数的`this`指向被调用的对象，也就是`xiaoming`，这是符合我们预期的。

如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。

坑爹啊！

更坑爹的是，如果这么写：

```js
var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
```

也是不行的！要保证`this`指向正确，必须用`obj.xxx()`的形式调用！

由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的`this`指向`undefined`，因此，在strict模式下，你会得到一个错误：

```js
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```

这个决定只是让错误及时暴露出来，并没有解决`this`应该指向的正确位置。

有些时候，喜欢重构的你把方法重构了一下：

```js
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```

结果又报错了！原因是`this`指针只在`age`方法的函数内指向`xiaoming`，在函数内部定义的函数，`this`又指向`undefined`了！（在非strict模式下，它重新指向全局对象`window`！）

修复的办法也不是没有，我们用一个`that`变量首先捕获`this`：

```js
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // 25
```

用`var that = this;`，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。

###### apply

虽然在一个独立的函数调用中，根据是否是strict模式，`this`指向`undefined`或`window`，不过，我们还是可以控制`this`的指向的！

要指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。

用`apply`修复`getAge()`调用：

```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

另一个与`apply()`类似的方法是`call()`，唯一区别是：

- `apply()`把参数打包成`Array`再传入；
- `call()`把参数按顺序传入。

比如调用`Math.max(3, 5, 4)`，分别用`apply()`和`call()`实现如下：

```js
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
```

对普通函数调用，我们通常把`this`绑定为`null`。

###### 装饰器

利用`apply()`，我们还可以动态改变函数的行为。

JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。

现在假定我们想统计一下代码一共调用了多少次`parseInt()`，可以把所有的调用都找出来，然后手动加上`count += 1`，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的`parseInt()`：

```js
'use strict'; 
var count = 0; 
var oldParseInt = parseInt; // 保存原函数 
window.parseInt = function () {    count += 1;    return oldParseInt.apply(null, arguments);  }; 
// 调用原函数
```

#####   高阶函数

高阶函数英文叫Higher-order function。那么什么是高阶函数？

JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

一个最简单的高阶函数：

```js
function add(x, y, f) {
    return f(x) + f(y);
}
```

当我们调用`add(-5, 6, Math.abs)`时，参数`x`，`y`和`f`分别接收`-5`，`6`和函数`Math.abs`，根据函数定义，我们可以推导计算过程为：

```js
x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

###### map

例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组`[1, 2, 3, 4, 5, 6, 7, 8, 9]`上，就可以用`map`实现如下：

![map](https://www.liaoxuefeng.com/files/attachments/925425803658112/0)

由于`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：

```js
'use strict';
function pow(x) {    return x * x; } 
```

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
console.log(results);
```

###### reduce

再看reduce的用法。Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

比方说对一个`Array`求和，就可以用`reduce`实现：

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25
```

如果数组元素只有1个，那么还需要提供一个额外的初始参数以便至少凑够两：

```js
var arr = [123];
arr.reduce(function (x, y) {
    return x + y;
}, 0); // 123
```

###### filter

filter也是一个常用的操作，它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。

和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。

例如，在一个`Array`中，删掉偶数，只保留奇数，可以这么写：

```JS
var arr = [1, 2, 4, 5, 6, 9, 10, 15];
var r = arr.filter(function (x) {
    return x % 2 !== 0;
});
r; // [1, 5, 9, 15]
```

把一个`Array`中的空字符串删掉，可以这么写：

```JS
var arr = ['A', '', 'B', null, undefined, 'C', '  '];
var r = arr.filter(function (s) {
    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法
});
r; // ['A', 'B', 'C']
```

可见用`filter()`这个高阶函数，关键在于正确实现一个“筛选”函数。

`filter()`接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示`Array`的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：

```js
var arr = ['A', 'B', 'C'];
var r = arr.filter(function (element, index, self) {
    console.log(element); // 依次打印'A', 'B', 'C'
    console.log(index); // 依次打印0, 1, 2
    console.log(self); // self就是变量arr
    return true;
});
```

利用`filter`，可以巧妙地去除`Array`的重复元素：

```js
'use strict'; var    r,    
    arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; 
```

###### sort

**排序算法**

排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。

JavaScript的`Array`的`sort()`方法就是用于排序的，但是排序结果可能让你大吃一惊：

```js
// 看上去正常的结果:
['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];

// apple排在了最后:
['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft", 'apple']

// 无法理解的结果:
[10, 20, 1, 2].sort(); // [1, 10, 2, 20]
```

第二个排序把`apple`排在了最后，是因为字符串根据ASCII码进行排序，而小写字母`a`的ASCII码在大写字母之后。

第三个排序结果是什么鬼？简单的数字排序都能错？

这是因为`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`'10'`排在了`'2'`的前面，因为字符`'1'`比字符`'2'`的ASCII码小。

如果不知道`sort()`方法的默认排序规则，直接对数字排序，绝对栽进坑里！

幸运的是，`sort()`方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。

要按数字大小排序，我们可以这么写：

```js
'use strict'; var arr = [10, 20, 1, 2]; 
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]
```

所传函数是一个比较函数，返回待比较两个元素的大小，参数 x 和 y 就是两个待比较的元素。

sort() 函数所做的工作可以理解成对待排序列中的元素两两进行比较，然后按比较结果进行排序

如果要倒序排序，我们可以把大的数放前面：

```js
var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x < y) {
        return 1;
    }
    if (x > y) {
        return -1;
    }
    return 0;
}); // [20, 10, 2, 1]
```

默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：

```js
var arr = ['Google', 'apple', 'Microsoft'];
arr.sort(function (s1, s2) {
    x1 = s1.toUpperCase();
    x2 = s2.toUpperCase();
    if (x1 < x2) {
        return -1;
    }
    if (x1 > x2) {
        return 1;
    }
    return 0;
}); // ['apple', 'Google', 'Microsoft']
```

忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。

从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。

最后友情提示，`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`：

```js
var a1 = ['B', 'A', 'C'];
var a2 = a1.sort();
a1; // ['A', 'B', 'C']
a2; // ['A', 'B', 'C']
a1 === a2; // true, a1和a2是同一对象
```



对于数组，除了`map()`、`reduce`、`filter()`、`sort()`这些方法可以传入一个函数外，`Array`对象还提供了很多非常实用的高阶函数。

###### every

`every()`方法可以判断数组的所有元素是否满足测试条件。

例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件：

```js
'use strict'; 
var arr = ['Apple', 'pear', 'orange'];
console.log(arr.every(function (s) {
    return s.length > 0;
})); // true, 因为每个元素都满足s.length>0

console.log(arr.every(function (s) {
    return s.toLowerCase() === s;
})); // false, 因为不是每个元素都全部是小写
```

###### find

`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`：

`'use strict'; ` 

```js
var arr = ['Apple', 'pear', 'orange'];
console.log(arr.find(function (s) {
    return s.toLowerCase() === s;
})); // 'pear', 因为pear全部是小写

console.log(arr.find(function (s) {
    return s.toUpperCase() === s;
})); // undefined, 因为没有全部是大写的元素

```

###### findIndex

`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`：

```js
var arr = ['Apple', 'pear', 'orange'];
console.log(arr.findIndex(function (s) {
    return s.toLowerCase() === s;
})); // 1, 因为'pear'的索引是1

console.log(arr.findIndex(function (s) {
    return s.toUpperCase() === s;
})); // -1
```

###### forEach

`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：

`'use strict'; ` 

```js
var arr = ['Apple', 'pear', 'orange'];
arr.forEach(console.log); // 依次打印每个元素
```

##### 闭包

**函数作为返回值**

高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。

我们来实现一个对`Array`的求和。通常情况下，求和的函数是这样定义的：

```js
function sum(arr) {
    return arr.reduce(function (x, y) {
        return x + y;
    });
}

sum([1, 2, 3, 4, 5]); // 15
```

但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！

```js
function lazy_sum(arr) {
    var sum = function () {
        return arr.reduce(function (x, y) {
            return x + y;
        });
    }
    return sum;
}
```

当我们调用`lazy_sum()`时，返回的并不是求和结果，而是求和函数：

```js
var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()
```

调用函数`f`时，才真正计算求和的结果：

```js
f(); // 15
```

在这个例子中，我们在函数`lazy_sum`中又定义了函数`sum`，并且，内部函数`sum`可以引用外部函数`lazy_sum`的参数和局部变量，当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。

请再注意一点，当我们调用`lazy_sum()`时，每次调用都会返回一个新的函数，即使传入相同的参数：

```js
var f1 = lazy_sum([1, 2, 3, 4, 5]);
var f2 = lazy_sum([1, 2, 3, 4, 5]);
f1 === f2; // false
```

`f1()`和`f2()`的调用结果互不影响。

**闭包**

注意到返回的函数在其定义内部引用了局部变量`arr`，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。

另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了`f()`才执行。我们来看一个例子：

```js
function count() {
    var arr = [];
    for (var i=1; i<=3; i++) {
        arr.push(function () {
            return i * i;
        });
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];
```

在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个`Array`中返回了。

你可能认为调用`f1()`，`f2()`和`f3()`结果应该是`1`，`4`，`9`，但实际结果是：

```js
f1(); // 16
f2(); // 16
f3(); // 16
```

全部都是`16`！原因就在于返回的函数引用了变量`i`，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量`i`已经变成了`4`，因此最终结果为`16`。

返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：

```js
function count() {
    var arr = [];
    for (var i=1; i<=3; i++) {
        arr.push((function (n) {
            return function () {
                return n * n;
            }
        })(i));
    }
    return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];

f1(); // 1
f2(); // 4
f3(); // 9
```

注意这里用了一个“创建一个匿名函数并立刻执行”的语法：

```js
(function (x) {
    return x * x;
})(3); // 9
```

理论上讲，创建一个匿名函数并立刻执行可以这么写：

```js
function (x) { return x * x } (3);
```

但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：

```js
(function (x) { return x * x }) (3);
```

通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：

```js
(function (x) {
    return x * x;
})(3);
```

说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？

当然不是！闭包有非常强大的功能。举个栗子：

在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。

在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：

```js
'use strict';

function create_counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
```

它用起来像这样：

```js
var c1 = create_counter();
c1.inc(); // 1
c1.inc(); // 2
c1.inc(); // 3

var c2 = create_counter(10);
c2.inc(); // 11
c2.inc(); // 12
c2.inc(); // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。

闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用`Math.pow(x, y)`函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数`pow2`和`pow3`：

```js
'use strict'; 
function make_pow(n) {    return function (x) {        return Math.pow(x, n);    } } 
```

##### 箭头函数

ES6标准新增了一种新的函数：Arrow Function（箭头函数）。

为什么叫Arrow Function？因为它的定义用的就是一个箭头：

```js
x => x * x
```

上面的箭头函数相当于：

```js
function (x) {
    return x * x;
}
```

箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连`{ ... }`和`return`都省略掉了。还有一种可以包含多条语句，这时候就不能省略`{ ... }`和`return`：

```js
x => {
    if (x > 0) {
        return x * x;
    }
    else {
        return - x * x;
    }
}
```

如果参数不是一个，就需要用括号`()`括起来：

```js
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：

```js
// SyntaxError:
x => { foo: x }
```

因为和函数体的`{ ... }`有语法冲突，所以要改为：

```js
// ok:
x => ({ foo: x })
```

**this**

箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的`this`是词法作用域，由上下文确定。

回顾前面的例子，由于JavaScript函数对`this`绑定的错误处理，下面的例子无法得到预期结果：

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
        return fn();
    }
};
```

现在，箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`：

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
```

如果使用箭头函数，以前的那种hack写法：

```js
var that = this;
```

就不再需要了。

由于`this`在箭头函数中已经按照词法作用域绑定了，所以，用`call()`或者`apply()`调用箭头函数时，无法对`this`进行绑定，即传入的第一个参数被忽略：

```js
var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) => y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25
```

##### 模板函数

前面我们介绍了[模板字符串](https://www.liaoxuefeng.com/wiki/1022910821149312/1023020952022784)，它可以非常方便地引用变量，并合并出最终的字符串：

`'use strict'; let name = '小明'; let age = 20; ` Run

对于模板字符串，除了方便引用变量构造字符串外，还有一种更强大的功能，即可以使用标签函数。

什么是标签函数？让我们看一个例子：

```js
'use strict';

const email = "test@example.com";
const password = 'hello123';

function sql(strings, ...exps) {
    console.log(`SQL: ${strings.join('?')}`);
    console.log(`SQL parameters: ${JSON.stringify(exps)}`);
    return {
        name: '小明',
        age: 20
    };
}

const result = sql`SELECT * FROM users WHERE email=${email} AND password=${password}`;

console.log(JSON.stringify(result));
```

这里出现了一个奇怪的语法：

```js
sql`SELECT * FROM users WHERE email=${email} AND password=${password}`
```

模板字符串前面以`sql`开头，实际上这是一个标签函数，上述语法会自动转换为对`sql()`函数的调用。我们关注的是，传入`sql()`函数的参数是什么。

`sql()`函数实际上接收两个参数：

第一个参数`strings`是一个字符串数组，它是`["SELECT * FROM users WHERE email=", " AND password=", ""]`，即除去`${xxx}`剩下的字符组成的数组；

第二个参数`...exps`是一个可变参数，它接收的也是一个数组，但数组的内容是由模板字符串里所有的`${xxx}`的实际值组成，即`["test@example.com", "hello123"]`，因为解析`${email}`得到`"test@example.com"`，解析`${password}`得到`"hello123"`。

标签函数`sql()`实际上是一个普通函数，我们在内部把`strings`拼接成一个SQL字符串，把`...exps`作为参数，就可以实现一个安全的SQL查询，并返回查询结果。此处并没有真正的数据库连接，因此返回一个固定的Object。

标签函数和普通函数的定义区别仅仅在于参数，如果我们想对数据库进行修改，完全可以定义一个标签函数如下：

```js
function update(strings, ...exps) {
    let sql = strings.join('?');
    // 执行数据库更新
    // TODO:
}
```

函数调用可以简化为带标签的模板字符串：

```js
let id = 123;
let age = 21;
let score = 'A';

update`UPDATE users SET age=${age}, score=${score} WHERE id=${id}`;
```

#### 标准对象

在JavaScript的世界里，一切都是对象。

但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用`typeof`操作符获取对象的类型，它总是返回一个字符串：

```js
typeof 123; // 'number'
typeof NaN; // 'number'
typeof 'str'; // 'string'
typeof true; // 'boolean'
typeof undefined; // 'undefined'
typeof Math.abs; // 'function'
typeof null; // 'object'
typeof []; // 'object'
typeof {}; // 'object'
```

可见，`number`、`string`、`boolean`、`function`和`undefined`有别于其他类型。特别注意`null`的类型是`object`，`Array`的类型也是`object`，如果我们用`typeof`将无法区分出`null`、`Array`和通常意义上的object——`{}`。

##### **包装对象**

除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚`int`和`Integer`这种暧昧关系。

`number`、`boolean`和`string`都有包装对象。没错，在JavaScript中，字符串也区分`string`类型和它的包装类型。包装对象用`new`创建：

```js
var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String('str'); // 'str',生成了新的包装类型
```

虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为`object`了！所以，包装对象和原始值用`===`比较会返回`false`：

```js
typeof new Number(123); // 'object'
new Number(123) === 123; // false

typeof new Boolean(true); // 'object'
new Boolean(true) === true; // false

typeof new String('str'); // 'object'
new String('str') === 'str'; // false
```

所以*闲的蛋疼也不要使用包装对象*！尤其是针对`string`类型！！！

如果我们在使用`Number`、`Boolean`和`String`时，没有写`new`会发生什么情况？

此时，`Number()`、`Boolean`和`String()`被当做普通函数，把任何类型的数据转换为`number`、`boolean`和`string`类型（注意不是其包装类型）：

```js
var n = Number('123'); // 123，相当于parseInt()或parseFloat()
typeof n; // 'number'

var b = Boolean('true'); // true
typeof b; // 'boolean'

var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！
var b3 = Boolean(''); // false

var s = String(123.45); // '123.45'
typeof s; // 'string'
```

是不是感觉头大了？这就是JavaScript特有的催眠魅力！

总结一下，有这么几条规则需要遵守：

- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；
- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；
- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；
- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；
- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；
- 判断`Array`要使用`Array.isArray(arr)`；
- 判断`null`请使用`myVar === null`；
- 判断某个全局变量是否存在用`typeof window.myVar === 'undefined'`；
- 函数内部判断某个变量是否存在用`typeof myVar === 'undefined'`。

最后有细心的同学指出，任何对象都有`toString()`方法吗？`null`和`undefined`就没有！确实如此，这两个特殊值要除外，虽然`null`还伪装成了`object`类型。

更细心的同学指出，`number`对象调用`toString()`报SyntaxError：

```js
123.toString(); // SyntaxError
```

遇到这种情况，要特殊处理一下：

```js
123..toString(); // '123', 注意是两个点！
(123).toString(); // '123'
```

不要问为什么，这就是JavaScript代码的乐趣！

##### Date

在JavaScript中，`Date`对象用来表示日期和时间。

要获取系统当前时间，用：

```js
var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。

如果要创建一个指定日期和时间的`Date`对象，可以用：

```js
var d = new Date(2015, 5, 19, 20, 15, 30, 123);
d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)
```

你可能观察到了一个*非常非常坑爹*的地方，就是JavaScript的月份范围用整数表示是0~11，`0`表示一月，`1`表示二月……，所以要表示6月，我们传入的是`5`！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。

 JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。

第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：

```js
var d = Date.parse('2015-06-24T19:49:22.875+08:00');
d; // 1435146562875
```

但它返回的不是`Date`对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个`Date`：

```js
var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
d.getMonth(); // 5
```

 使用Date.parse()时传入的字符串使用实际月份01~12，转换为Date对象后getMonth()获取的月份值为0~11。

###### 时区

`Date`对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间：

```js
var d = new Date(1435146562875);
d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
```

那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个`number`类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。

时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。

所以，我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。

要获取当前时间戳，可以用：

```js
if (Date.now) {
    console.log(Date.now()); // 老版本IE没有now()方法
} else {
    console.log(new Date().getTime());
}

```

##### RegExp

字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取`@`前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。

正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。

所以我们判断一个字符串是否是合法的Email的方法是：

1. 创建一个匹配Email的正则表达式；
2. 用该正则表达式去匹配用户的输入来判断是否合法。

因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。

在正则表达式中，如果直接给出字符，就是精确匹配。**用`\d`可以匹配一个数字，`\w`可以匹配一个字母或数字**，所以：

- `'00\d'`可以匹配`'007'`，但无法匹配`'00A'`；
- `'\d\d\d'`可以匹配`'010'`；
- `'\w\w'`可以匹配`'js'`；

`.`可以匹配任意字符，所以：

- `'js.'`可以匹配`'jsp'`、`'jss'`、`'js!'`等等。

要匹配变长的字符，在正则表达式中，用`*`表示任意个字符（包括0个），用`+`表示至少一个字符，用`?`表示0个或1个字符，用`{n}`表示n个字符，用`{n,m}`表示n-m个字符：

来看一个复杂的例子：`\d{3}\s+\d{3,8}`。

我们来从左到右解读一下：

1. `\d{3}`表示匹配3个数字，例如`'010'`；
2. `\s`可以匹配一个空格（也包括Tab等空白符），所以`\s+`表示至少有一个空格，例如匹配`' '`，`'\t\t'`等；
3. `\d{3,8}`表示3-8个数字，例如`'1234567'`。

综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。

如果要匹配`'010-12345'`这样的号码呢？由于`'-'`是特殊字符，在正则表达式中，要用`'\'`转义，所以，上面的正则是`\d{3}\-\d{3,8}`。

但是，仍然无法匹配`'010 - 12345'`，因为带有空格。所以我们需要更复杂的匹配方式。

###### 进阶

要做更精确地匹配，可以用`[]`表示范围，比如：

- `[0-9a-zA-Z\_]`可以匹配一个数字、字母或者下划线；
- `[0-9a-zA-Z\_]+`可以匹配至少由一个数字、字母或者下划线组成的字符串，比如`'a100'`，`'0_Z'`，`'js2015'`等等；
- `[a-zA-Z\_\$][0-9a-zA-Z\_\$]*`可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；
- `[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}`更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。

`A|B`可以匹配A或B，所以`(J|j)ava(S|s)cript`可以匹配`'JavaScript'`、`'Javascript'`、`'javaScript'`或者`'javascript'`。

`^`表示行的开头，`^\d`表示必须以数字开头。

`$`表示行的结束，`\d$`表示必须以数字结束。

你可能注意到了，`js`也可以匹配`'jsp'`，但是加上`^js$`就变成了整行匹配，就只能匹配`'js'`了。

###### RegExp

有了准备知识，我们就可以在JavaScript中使用正则表达式了。

JavaScript有两种方式创建一个正则表达式：

第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。

两种写法是一样的：

```js
var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

re1; // /ABC\-001/
re2; // /ABC\-001/
```

注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个`\\`实际上是一个`\`。

先看看如何判断正则表达式是否匹配：

```js
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
re.test('010 12345'); // false
```

RegExp对象的`test()`方法用于测试给定的字符串是否符合条件。

###### 切分字符串

用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c']
```

嗯，无法识别连续的空格，用正则表达式试试：

```js
'a b   c'.split(/\s+/); // ['a', 'b', 'c']
```

无论多少个空格都可以正常分割。加入`,`试试：

```js
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
```

再加入`;`试试：

```js
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。

###### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。比如：

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

如果正则表达式中定义了组，就可以在`RegExp`对象上用`exec()`方法提取出子串来。

`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

`exec()`方法在匹配失败时返回`null`。

提取子串非常有用。来看一个更凶残的例子：

```js
var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']
```

这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：

```js
var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
```

对于`'2-30'`，`'4-31'`这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。

###### 贪婪匹配

需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的`0`：

```js
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
```

由于`\d+`采用贪婪匹配，直接把后面的`0`全部匹配了，结果`0*`只能匹配空字符串了。

必须让`\d+`采用非贪婪匹配（也就是尽可能少匹配），才能把后面的`0`匹配出来，加个`?`就可以让`\d+`采用非贪婪匹配：

```js
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
```

###### 

JavaScript的正则表达式还有几个特殊的标志，最常用的是`g`，表示全局匹配：

```js
var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

全局匹配类似搜索，因此不能使用`/^...$/`，那样只会最多匹配一次。

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

##### JSON

JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。

在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。

终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。

道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

以及上面的任意组合。

并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号`""`，Object的键也必须用双引号`""`。

由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。

把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。

如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。

###### 序列化

让我们先把小明这个对象序列化成JSON格式的字符串：

```js
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp']
};
```

要输出得好看一些，可以加上参数，按缩进输出：

```js
JSON.stringify(xiaoming, null, '  ');
```

结果：

```json
{
  "name": "小明",
  "age": 14,
  "gender": true,
  "height": 1.65,
  "grade": null,
  "middle-school": "\"W3C\" Middle School",
  "skills": [
    "JavaScript",
    "Java",
    "Python",
    "Lisp"
  ]
}
```

第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入`Array`：

```js
JSON.stringify(xiaoming, ['name', 'skills'], '  ');
```

结果：

```js
{
  "name": "小明",
  "skills": [
    "JavaScript",
    "Java",
    "Python",
    "Lisp"
  ]
}
```

还可以传入一个函数，这样对象的每个键值对都会被函数先处理：

```js
function convert(key, value) {
    if (typeof value === 'string') {
        return value.toUpperCase();
    }
    return value;
}

JSON.stringify(xiaoming, convert, '  ');
```

上面的代码把所有属性值都变成大写：

```js
{
  "name": "小明",
  "age": 14,
  "gender": true,
  "height": 1.65,
  "grade": null,
  "middle-school": "\"W3C\" MIDDLE SCHOOL",
  "skills": [
    "JAVASCRIPT",
    "JAVA",
    "PYTHON",
    "LISP"
  ]
}
```

如果我们还想要精确控制如何序列化小明，可以给`xiaoming`定义一个`toJSON()`的方法，直接返回JSON应该序列化的数据：

```js
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            'Name': this.name,
            'Age': this.age
        };
    }
};

JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
```

###### 反序列化

拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：

```js
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

`JSON.parse()`还可以接收一个函数，用来转换解析出的属性：

`'use strict'; ` 

```js
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp']
};
```

在JavaScript中使用JSON，就是这么简单！

#### 面向对象编程

JavaScript的所有数据都可以看成对象，那是不是我们已经在使用面向对象编程了呢？

当然不是。如果我们只使用`Number`、`Array`、`string`以及基本的`{...}`定义的对象，还无法发挥出面向对象编程的威力。

JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。如果你熟悉Java或C#，很好，你一定明白面向对象的两个基本概念：

1. 类：类是对象的类型模板，例如，定义`Student`类来表示学生，类本身是一种类型，`Student`表示学生类型，但不表示任何具体的某个学生；
2. 实例：实例是根据类创建的对象，例如，根据`Student`类可以创建出`xiaoming`、`xiaohong`、`xiaojun`等多个实例，每个实例表示一个具体的学生，他们全都属于`Student`类型。

所以，类和实例是大多数面向对象编程语言的基本概念。

不过，在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。

原型是指当我们想要创建`xiaoming`这个具体的学生时，我们并没有一个`Student`类型可用。那怎么办？恰好有这么一个现成的对象：

```js
var robot = {
    name: 'Robot',
    height: 1.6,
    run: function () {
        console.log(this.name + ' is running...');
    }
};
```

我们看这个`robot`对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！

于是我们把它改名为`Student`，然后创建出`xiaoming`：

```js
var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
        console.log(this.name + ' is running...');
    }
};

var xiaoming = {
    name: '小明'
};

xiaoming.__proto__ = Student;
```

注意最后一行代码把`xiaoming`的原型指向了对象`Student`，看上去`xiaoming`仿佛是从`Student`继承下来的：

```js
xiaoming.name; // '小明'
xiaoming.run(); // 小明 is running...
```

`xiaoming`有自己的`name`属性，但并没有定义`run()`方法。不过，由于小明是从`Student`继承而来，只要`Student`有`run()`方法，`xiaoming`也可以调用：

![xiaoming-prototype](https://www.liaoxuefeng.com/files/attachments/1024674367146144/l)

JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。

如果你把`xiaoming`的原型指向其他对象：

```js
var Bird = {
    fly: function () {
        console.log(this.name + ' is flying...');
    }
};

xiaoming.__proto__ = Bird;
```

现在`xiaoming`已经无法`run()`了，他已经变成了一只鸟：

```js
xiaoming.fly(); // 小明 is flying...
```

在JavaScrip代码运行时期，你可以把`xiaoming`从`Student`变成`Bird`，或者变成任何对象。

*请注意*，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用`obj.__proto__`去改变一个对象的原型，并且，低版本的IE也无法使用`__proto__`。`Object.create()`方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建`xiaoming`：

```js
// 原型对象:
var Student = {
    name: 'Robot',
    height: 1.2,
    run: function () {
        console.log(this.name + ' is running...');
    }
};

function createStudent(name) {
    // 基于Student原型创建一个新对象:
    var s = Object.create(Student);
    // 初始化新对象:
    s.name = name;
    return s;
}

var xiaoming = createStudent('小明');
xiaoming.run(); // 小明 is running...
xiaoming.__proto__ === Student; // true
```

这是创建原型继承的一种方法，JavaScript还有其他方法来创建对象，我们在后面会一一讲到。

##### 创建对象

JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。

当我们用`obj.xxx`访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到`Object.prototype`对象，最后，如果还没有找到，就只能返回`undefined`。

例如，创建一个`Array`对象：

```js
var arr = [1, 2, 3];
```

其原型链是：

```
arr ----> Array.prototype ----> Object.prototype ----> null
```

`Array.prototype`定义了`indexOf()`、`shift()`等方法，因此你可以在所有的`Array`对象上直接调用这些方法。

当我们创建一个函数时：

```js
function foo() {
    return 0;
}
```

函数也是一个对象，它的原型链是：

```
foo ----> Function.prototype ----> Object.prototype ----> null
```

由于`Function.prototype`定义了`apply()`等方法，因此，所有函数都可以调用`apply()`方法。

很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。

###### 构造函数

除了直接用`{ ... }`创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：

```js
function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}
```

你会问，咦，这不是一个普通函数吗？

这确实是一个普通函数，但是在JavaScript中，可以用关键字`new`来调用这个函数，并返回一个对象：

```js
var xiaoming = new Student('小明');
xiaoming.name; // '小明'
xiaoming.hello(); // Hello, 小明!
```

*注意*，如果不写`new`，这就是一个普通函数，它返回`undefined`。但是，如果写了`new`，它就变成了一个构造函数，它绑定的`this`指向新创建的对象，并默认返回`this`，也就是说，不需要在最后写`return this;`。

新创建的`xiaoming`的原型链是：

```
xiaoming ----> Student.prototype ----> Object.prototype ----> null
```

也就是说，`xiaoming`的原型指向函数`Student`的原型。如果你又创建了`xiaohong`、`xiaojun`，那么这些对象的原型与`xiaoming`是一样的：

```
xiaoming ↘
xiaohong -→ Student.prototype ----> Object.prototype ----> null
xiaojun  ↗
```

用`new Student()`创建的对象还从原型上获得了一个`constructor`属性，它指向函数`Student`本身：

```js
xiaoming.constructor === Student.prototype.constructor; // true
Student.prototype.constructor === Student; // true

Object.getPrototypeOf(xiaoming) === Student.prototype; // true

xiaoming instanceof Student; // true
```

看晕了吧？用一张图来表示这些乱七八糟的关系就是：

![protos](https://www.liaoxuefeng.com/files/attachments/1024698721053600/l)

红色箭头是原型链。注意，`Student.prototype`指向的对象就是`xiaoming`、`xiaohong`的原型对象，这个原型对象自己还有个属性`constructor`，指向`Student`函数本身。

另外，函数`Student`恰好有个属性`prototype`指向`xiaoming`、`xiaohong`的原型对象，但是`xiaoming`、`xiaohong`这些对象可没有`prototype`这个属性，不过可以用`__proto__`这个非标准用法来查看。

现在我们就认为`xiaoming`、`xiaohong`这些对象“继承”自`Student`。

不过还有一个小问题，注意观察：

```js
xiaoming.name; // '小明'
xiaohong.name; // '小红'
xiaoming.hello; // function: Student.hello()
xiaohong.hello; // function: Student.hello()
xiaoming.hello === xiaohong.hello; // false
```

`xiaoming`和`xiaohong`各自的`name`不同，这是对的，否则我们无法区分谁是谁了。

`xiaoming`和`xiaohong`各自的`hello`是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！

如果我们通过`new Student()`创建了很多对象，这些对象的`hello`函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。

要让创建的对象共享一个`hello`函数，根据对象的属性查找原则，我们只要把`hello`函数移动到`xiaoming`、`xiaohong`这些对象共同的原型上就可以了，也就是`Student.prototype`：

![protos2](https://www.liaoxuefeng.com/files/attachments/1024700039819712/l)

修改代码如下：

```js
function Student(name) {
    this.name = name;
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};
```

用`new`创建基于原型的JavaScript的对象就是这么简单！

###### 忘记写new怎么办

如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写`new`怎么办？

在strict模式下，`this.name = name`将报错，因为`this`绑定为`undefined`，在非strict模式下，`this.name = name`不报错，因为`this`绑定为`window`，于是无意间创建了全局变量`name`，并且返回`undefined`，这个结果更糟糕。

所以，调用构造函数千万不要忘记写`new`。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如[jslint](http://www.jslint.com/)将可以帮你检测到漏写的`new`。

最后，我们还可以编写一个`createStudent()`函数，在内部封装所有的`new`操作。一个常用的编程模式像这样：

```js
function Student(props) {
    this.name = props.name || '匿名'; // 默认值为'匿名'
    this.grade = props.grade || 1; // 默认值为1
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
};

function createStudent(props) {
    return new Student(props || {})
}
```

这个`createStudent()`函数有几个巨大的优点：一是不需要`new`来调用，二是参数非常灵活，可以不传，也可以这么传：

```js
var xiaoming = createStudent({
    name: '小明'
});

xiaoming.grade; // 1
```

如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从`JSON`拿到了一个对象，就可以直接创建出`xiaoming`。

##### 原型继承

在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。

由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。

但是办法还是有的。我们先回顾`Student`构造函数：

```js
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}
```

以及`Student`的原型链：

![js-proto](https://www.liaoxuefeng.com/files/attachments/1034288810160288/l)

现在，我们要基于`Student`扩展出`PrimaryStudent`，可以先定义出`PrimaryStudent`：

```js
function PrimaryStudent(props) {
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
}
```

但是，调用了`Student`构造函数不等于继承了`Student`，`PrimaryStudent`创建的对象的原型是：

```
new PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null
```

必须想办法把原型链修改为：

```
new PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null
```

这样，原型链对了，继承关系就对了。新的基于`PrimaryStudent`创建的对象不但能调用`PrimaryStudent.prototype`定义的方法，也可以调用`Student.prototype`定义的方法。

如果你想用最简单粗暴的方法这么干：

```js
PrimaryStudent.prototype = Student.prototype;
```

是不行的！如果这样的话，`PrimaryStudent`和`Student`共享一个原型对象，那还要定义`PrimaryStudent`干啥？

我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向`Student.prototype`。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数`F`来实现：

```js
// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: '小明',
    grade: 2
});
xiaoming.name; // '小明'
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
```

用一张图来表示新的原型链：

![js-proto-extend](https://www.liaoxuefeng.com/files/attachments/1034288859918112/l)

注意，函数`F`仅用于桥接，我们仅创建了一个`new F()`实例，而且，没有改变原有的`Student`定义的原型链。

如果把继承这个动作用一个`inherits()`函数封装起来，还可以隐藏`F`的定义，并简化代码：

```js
function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
```

这个`inherits()`函数可以复用：

```js
function Student(props) {
    this.name = props.name || 'Unnamed';
}

Student.prototype.hello = function () {
    alert('Hello, ' + this.name + '!');
}

function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};
```

#### 浏览器

由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注的。

目前主流的浏览器分这么几种：

- IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；
- Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；
- Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Capitan自带的Safari版本是9.x，早已支持ES6；
- Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；
- 移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。

其他浏览器如Opera等由于市场份额太小就被自动忽略了。

另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。

不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。

在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。

JavaScript可以获取浏览器提供的很多对象，并进行操作。

##### window

`window`对象不但充当全局作用域，而且表示浏览器窗口。

`window`对象有`innerWidth`和`innerHeight`属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。

兼容性：IE<=8不支持。

```js
// 可以调整浏览器窗口大小试试:
console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight);
```

对应的，还有一个`outerWidth`和`outerHeight`属性，可以获取浏览器窗口的整个宽高。

##### navigator

`navigator`对象表示浏览器的信息，最常用的属性包括：

- navigator.appName：浏览器名称；
- navigator.appVersion：浏览器版本；
- navigator.language：浏览器设置的语言；
- navigator.platform：操作系统类型；
- navigator.userAgent：浏览器设定的`User-Agent`字符串。

```js
console.log('appName = ' + navigator.appName);
console.log('appVersion = ' + navigator.appVersion);
console.log('language = ' + navigator.language);
console.log('platform = ' + navigator.platform);
console.log('userAgent = ' + navigator.userAgent);
```

*请注意*，`navigator`的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用`if`判断浏览器版本，例如：

```js
var width;
if (getIEVersion(navigator.userAgent) < 9) {
    width = document.body.clientWidth;
} else {
    width = window.innerWidth;
}
```

但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回`undefined`的特性，直接用短路运算符`||`计算：

```js
var width = window.innerWidth || document.body.clientWidth;
```

##### screen

`screen`对象表示屏幕的信息，常用的属性有：

- screen.width：屏幕宽度，以像素为单位；
- screen.height：屏幕高度，以像素为单位；
- screen.colorDepth：返回颜色位数，如8、16、24。

##### location

`location`对象表示当前页面的URL信息。例如，一个完整的URL：

```
http://www.example.com:8080/path/index.html?a=1&b=2#TOP
```

可以用`location.href`获取。要获得URL各个部分的值，可以这么写：

```
location.protocol; // 'http'
location.host; // 'www.example.com'
location.port; // '8080'
location.pathname; // '/path/index.html'
location.search; // '?a=1&b=2'
location.hash; // 'TOP'
```

要加载一个新页面，可以调用`location.assign()`。如果要重新加载当前页面，调用`location.reload()`方法非常方便。

##### document

`document`对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，`document`对象就是整个DOM树的根节点。

`document`的`title`属性是从HTML文档中的`<title>xxx</title>`读取的，但是可以动态改变

要查找DOM树的某个节点，需要从`document`对象开始查找。最常用的查找是根据ID和Tag Name。

我们先准备HTML数据：

```html
<dl id="drink-menu" style="border:solid 1px #ccc;padding:6px;">
    <dt>摩卡</dt>
    <dd>热摩卡咖啡</dd>
    <dt>酸奶</dt>
    <dd>北京老酸奶</dd>
    <dt>果汁</dt>
    <dd>鲜榨苹果汁</dd>
</dl>
```

用`document`对象提供的`getElementById()`和`getElementsByTagName()`可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：

```js
var menu = document.getElementById('drink-menu');
var drinks = document.getElementsByTagName('dt');
var i, s;

s = '提供的饮料有:';
for (i=0; i<drinks.length; i++) {
    s = s + drinks[i].innerHTML + ',';
}
console.log(s);
```



- 摩卡

  热摩卡咖啡

- 酸奶

  北京老酸奶

- 果汁

  鲜榨苹果汁

`document`对象还有一个`cookie`属性，可以获取当前页面的Cookie。

Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如`user=ABC123XYZ(加密的字符串)...`，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。

Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。

JavaScript可以通过`document.cookie`读取到当前页面的Cookie：

```js
document.cookie; // 'v=123; remember=true; prefer=zh'
```

由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：

```html
<!-- 当前页面在wwwexample.com -->
<html>
    <head>
        <script src="http://www.foo.com/jquery.js"></script>
    </head>
    ...
</html>
```

如果引入的第三方的JavaScript中存在恶意代码，则`www.foo.com`网站将直接获取到`www.example.com`网站的用户登录信息。

为了解决这个问题，服务器在设置Cookie时可以使用`httpOnly`，设定了`httpOnly`的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持`httpOnly`选项，IE从IE6 SP1开始支持。

为了确保安全，服务器端在设置Cookie时，应该始终坚持使用`httpOnly`。

##### history

`history`对象保存了浏览器的历史记录，JavaScript可以调用`history`对象的`back()`或`forward ()`，相当于用户点击了浏览器的“后退”或“前进”按钮。

这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用`history.back()`可能会让用户感到非常愤怒。

新手开始设计Web页面时喜欢在登录页登录成功时调用`history.back()`，试图回到登录前的页面。这是一种错误的方法。

任何情况，你都不应该使用`history`这个对象了。

##### 操作DOM

由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。

始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：

- 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；
- 遍历：遍历该DOM节点下的子节点，以便进行进一步操作；
- 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；
- 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。

在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是`document.getElementById()`和`document.getElementsByTagName()`，以及CSS选择器`document.getElementsByClassName()`。

由于ID在HTML文档中是唯一的，所以`document.getElementById()`可以直接定位唯一的一个DOM节点。`document.getElementsByTagName()`和`document.getElementsByClassName()`总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。

例如：

```js
// 返回ID为'test'的节点：
var test = document.getElementById('test');

// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：
var trs = document.getElementById('test-table').getElementsByTagName('tr');

// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：
var reds = document.getElementById('test-div').getElementsByClassName('red');

// 获取节点test下的所有直属子节点:
var cs = test.children;

// 获取节点test下第一个、最后一个子节点：
var first = test.firstElementChild;
var last = test.lastElementChild;
```

第二种方法是使用`querySelector()`和`querySelectorAll()`，需要了解selector语法，然后使用条件来获取节点，更加方便：

```js
// 通过querySelector获取ID为q1的节点：
var q1 = document.querySelector('#q1');

// 通过querySelectorAll获取q1节点内的符合条件的所有节点：
var ps = q1.querySelectorAll('div.highlighted > p');
```

注意：低版本的IE<8不支持`querySelector`和`querySelectorAll`。IE8仅有限支持。

严格地讲，我们这里的DOM节点是指`Element`，但是DOM节点实际上是`Node`，在HTML中，`Node`包括`Element`、`Comment`、`CDATA_SECTION`等很多种，以及根节点`Document`类型，但是，绝大多数时候我们只关心`Element`，也就是实际控制页面结构的`Node`，其他类型的`Node`忽略即可。根节点`Document`已经自动绑定为全局变量`document`。

##### 更新DOM

拿到一个DOM节点后，我们可以对它进行更新。

可以直接修改节点的文本，方法有两种：

一种是修改`innerHTML`属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：

```js
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本为abc:
p.innerHTML = 'ABC'; // <p id="p-id">ABC</p>
// 设置HTML:
p.innerHTML = 'ABC <span style="color:red">RED</span> XYZ';
// <p>...</p>的内部结构已修改
```

用`innerHTML`时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到的，要注意对字符编码来避免XSS攻击。

第二种是修改`innerText`或`textContent`属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：

```js
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置文本:
p.innerText = '<script>alert("Hi")</script>';
// HTML被自动编码，无法设置一个<script>节点:
// <p id="p-id">&lt;script&gt;alert("Hi")&lt;/script&gt;</p>
```

两者的区别在于读取属性时，`innerText`不返回隐藏元素的文本，而`textContent`返回所有文本。另外注意IE<9不支持`textContent`。

修改CSS也是经常需要的操作。DOM节点的`style`属性对应所有的CSS，可以直接获取或设置。因为CSS允许`font-size`这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名`fontSize`：

```js
// 获取<p id="p-id">...</p>
var p = document.getElementById('p-id');
// 设置CSS:
p.style.color = '#ff0000';
p.style.fontSize = '20px';
p.style.paddingTop = '2em';
```

##### 插入DOM

当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？

如果这个DOM节点是空的，例如，`<div></div>`，那么，直接使用`innerHTML = '<span>child</span>'`就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。

如果这个DOM节点不是空的，那就不能这么做，因为`innerHTML`会直接替换掉原来的所有子节点。

有两个办法可以插入新的节点。一个是使用`appendChild`，把一个子节点添加到父节点的最后一个子节点。例如：

```html
<!-- HTML结构 -->
<p id="js">JavaScript</p>
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
</div>
```

把`<p id="js">JavaScript</p>`添加到`<div id="list">`的最后一项：

```js
var
    js = document.getElementById('js'),
    list = document.getElementById('list');
list.appendChild(js);
```

现在，HTML结构变成了这样：

```html
<!-- HTML结构 -->
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
    <p id="js">JavaScript</p>
</div>
```

因为我们插入的`js`节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。

更多的时候我们会从零创建一个新的节点，然后插入到指定位置：

```js
var
    list = document.getElementById('list'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.appendChild(haskell);
```

这样我们就动态添加了一个新的节点：

```html
<!-- HTML结构 -->
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
    <p id="haskell">Haskell</p>
</div>
```

动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个`<style>`节点，然后把它添加到`<head>`节点的末尾，这样就动态地给文档添加了新的CSS定义：

```js
var d = document.createElement('style');
d.setAttribute('type', 'text/css');
d.innerHTML = 'p { color: red }';
document.getElementsByTagName('head')[0].appendChild(d);
```

可以在Chrome的控制台执行上述代码，观察页面样式的变化。

**insertBefore**

如果我们要把子节点插入到指定的位置怎么办？可以使用`parentElement.insertBefore(newElement, referenceElement);`，子节点会插入到`referenceElement`之前。

还是以上面的HTML为例，假定我们要把`Haskell`插入到`Python`之前：

```html
<!-- HTML结构 -->
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
</div>
```

可以这么写：

```js
var
    list = document.getElementById('list'),
    ref = document.getElementById('python'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.insertBefore(haskell, ref);
```

新的HTML结构如下：

```html
<!-- HTML结构 -->
<div id="list">
    <p id="java">Java</p>
    <p id="haskell">Haskell</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
</div>
```

可见，使用`insertBefore`重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代`children`属性实现：

```js
var
    i, c,
    list = document.getElementById('list');
for (i = 0; i < list.children.length; i++) {
    c = list.children[i]; // 拿到第i个子节点
}
```

#####  删除DOM

删除一个DOM节点就比插入要容易得多。

要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的`removeChild`把自己删掉：

```js
// 拿到待删除节点:
var self = document.getElementById('to-be-removed');
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
removed === self; // true
```

注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。

当你遍历一个父节点的子节点并进行删除操作时，要注意，`children`属性是一个只读属性，并且它在子节点变化时会实时更新。

例如，对于如下HTML结构：

```html
<div id="parent">
    <p>First</p>
    <p>Second</p>
</div>
```

当我们用如下代码删除子节点时：

```js
var parent = document.getElementById('parent');
parent.removeChild(parent.children[0]);
parent.removeChild(parent.children[1]); // <-- 浏览器报错
```

浏览器报错：`parent.children[1]`不是一个有效的节点。原因就在于，当`<p>First</p>`节点被删除后，`parent.children`的节点数量已经从2变为了1，索引`[1]`已经不存在了。

因此，删除多个节点时，要注意`children`属性时刻都在变化。

##### DOMBOM补充总结

移步[[javascript之BOM和DOM操作 - Mr江 - 博客园 (cnblogs.com)](https://www.cnblogs.com/jiangxianseng/p/12135952.html)]

[[JavaScript的DOM详细讲解(推荐必看) - 掘金 (juejin.cn)](https://juejin.cn/post/6888886996765573128?searchId=2024022723150855DE6303EE1FF11BADD8)]

##### 操作表单

用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。

不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。

HTML表单的输入控件主要有以下几种：

- 文本框，对应的`<input type="text">`，用于输入文本；
- 口令框，对应的`<input type="password">`，用于输入口令；
- 单选框，对应的`<input type="radio">`，用于选择一项；
- 复选框，对应的`<input type="checkbox">`，用于选择多项；
- 下拉框，对应的`<select>`，用于选择一项；
- 隐藏文本，对应的`<input type="hidden">`，用户不可见，但表单提交时会把隐藏文本发送到服务器。

获取值

如果我们获得了一个`<input>`节点的引用，就可以直接调用`value`获得对应的用户输入值：

```js
// <input type="text" id="email">
var input = document.getElementById('email');
input.value; // '用户输入的值'
```

这种方式可以应用于`text`、`password`、`hidden`以及`select`。但是，对于单选框和复选框，`value`属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用`checked`判断：

```html
// <label><input type="radio" name="weekday" id="monday" value="1"> Monday</label>
// <label><input type="radio" name="weekday" id="tuesday" value="2"> Tuesday</label>
var mon = document.getElementById('monday');
var tue = document.getElementById('tuesday');
mon.value; // '1'
tue.value; // '2'
mon.checked; // true或者false
tue.checked; // true或者false
```

**设置值**

设置值和获取值类似，对于`text`、`password`、`hidden`以及`select`，直接设置`value`就可以：

```js
// <input type="text" id="email">
var input = document.getElementById('email');
input.value = 'test@example.com'; // 文本框的内容已更新
```

对于单选框和复选框，设置`checked`为`true`或`false`即可。

**HTML5控件**

HTML5新增了大量标准控件，常用的包括`date`、`datetime`、`datetime-local`、`color`等，它们都使用`<input>`标签：

```
<input type="date" value="2021-12-02">
```



```
<input type="datetime-local" value="2021-12-02T20:21:12">
```



```
<input type="color" value="#ff0000">
```



不支持HTML5的浏览器无法识别新的控件，会把它们当做`type="text"`来显示。支持HTML5的浏览器将获得格式化的字符串。例如，`type="date"`类型的`input`的`value`将保证是一个有效的`YYYY-MM-DD`格式的日期，或者空字符串。

**提交表单**

最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。

方式一是通过`<form>`元素的`submit()`方法提交一个表单，例如，响应一个`<button>`的`click`事件，在JavaScript代码中提交表单：

```html
<!-- HTML -->
<form id="test-form">
    <input type="text" name="test">
    <button type="button" onclick="doSubmitForm()">Submit</button>
</form>

<script>
function doSubmitForm() {
    var form = document.getElementById('test-form');
    // 可以在此修改form的input...
    // 提交form:
    form.submit();
}
</script>
```

这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击`<button type="submit">`时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应`<form>`本身的`onsubmit`事件，在提交form时作修改：

```html
<!-- HTML -->
<form id="test-form" onsubmit="return checkForm()">
    <input type="text" name="test">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var form = document.getElementById('test-form');
    // 可以在此修改form的input...
    // 继续下一步:
    return true;
}
</script>
```

注意要`return true`来告诉浏览器继续提交，如果`return false`，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。

在检查和修改`<input>`时，要充分利用`<input type="hidden">`来传递数据。

例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改`<input>`：

```html
<!-- HTML -->
<form id="login-form" method="post" onsubmit="return checkForm()">
    <input type="text" id="username" name="username">
    <input type="password" id="password" name="password">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var pwd = document.getElementById('password');
    // 把用户输入的明文变为MD5:
    pwd.value = toMD5(pwd.value);
    // 继续下一步:
    return true;
}
</script>
```

这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个`*`变成32个`*`（因为MD5有32个字符）。

要想不改变用户的输入，可以利用`<input type="hidden">`实现：

```html
<!-- HTML -->
<form id="login-form" method="post" onsubmit="return checkForm()">
    <input type="text" id="username" name="username">
    <input type="password" id="input-password">
    <input type="hidden" id="md5-password" name="password">
    <button type="submit">Submit</button>
</form>

<script>
function checkForm() {
    var input_pwd = document.getElementById('input-password');
    var md5_pwd = document.getElementById('md5-password');
    // 把用户输入的明文变为MD5:
    md5_pwd.value = toMD5(input_pwd.value);
    // 继续下一步:
    return true;
}
</script>
```

注意到`id`为`md5-password`的`<input>`标记了`name="password"`，而用户输入的`id`为`input-password`的`<input>`没有`name`属性。没有`name`属性的`<input>`的数据不会被提交。

##### 操作文件

在HTML表单中，可以上传文件的唯一控件就是`<input type="file">`。

*注意*：当一个表单包含`<input type="file">`时，表单的`enctype`必须指定为`multipart/form-data`，`method`必须指定为`post`，浏览器才能正确编码并以`multipart/form-data`格式发送表单的数据。

出于安全考虑，浏览器只允许用户点击`<input type="file">`来选择本地文件，用JavaScript对`<input type="file">`的`value`赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径。

通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：

```js
var f = document.getElementById('test-file-upload');
var filename = f.value; // 'C:\fakepath\test.png'
if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) {
    alert('Can only upload image file.');
    return false;
}
```

**File API**

由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。

随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。

HTML5的File API提供了`File`和`FileReader`两个主要对象，可以获得文件信息并读取文件。

下面的例子演示了如何读取用户选取的图片文件，并在一个`<div>`中预览图像：



```js
var
    fileInput = document.getElementById('test-image-file'),
    info = document.getElementById('test-file-info'),
    preview = document.getElementById('test-image-preview');
// 监听change事件:
fileInput.addEventListener('change', function () {
    // 清除背景图片:
    preview.style.backgroundImage = '';
    // 检查文件是否选择:
    if (!fileInput.value) {
        info.innerHTML = '没有选择文件';
        return;
    }
    // 获取File引用:
    var file = fileInput.files[0];
    // 获取File信息:
    info.innerHTML = '文件: ' + file.name + '<br>' +
                     '大小: ' + file.size + '<br>' +
                     '修改: ' + file.lastModified;
    if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') {
        alert('不是有效的图片文件!');
        return;
    }
    // 读取文件:
    var reader = new FileReader();
    reader.onload = function(es) {
        var
            data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            
        preview.style.backgroundImage = 'url(' + data + ')';
    };
    // 以DataURL的形式读取文件:
    reader.readAsDataURL(file);
});
```

上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于`data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...`，常用于设置图像。如果需要服务器端处理，把字符串`base64,`后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。

**回调**

上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。

你可能会问，单线程模式执行的JavaScript，如何处理多任务？

在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：

```
reader.readAsDataURL(file);
```

就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：

```js
reader.onload = function(e) {
    // 当文件读取完成后，自动调用此函数:
};
```

当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。

##### Canvas

### [ES6](https://www.bookstack.cn/read/es6-3rd/sidebar.md)

## Typescript

### 为什么要用TypeScript

`TypeScript`可以让我们开发中避免一些`类型`或者`一些不是我们预期希望的代码结果`错误。xxx is not defined 我们都知道`JavaScript`错误是在运行中才抛出的，但是`TypeScript`错误直接是在编辑器里告知我们的，这极大的提升了开发效率，也不用花大量的时间去写单测，同时也避免了大量的时间排查`Bug`。

### TypeScript优缺点

#### 优点

- 一般我们在前后端联调时，都要去看接口文档上的字段类型，而`TypeScript`会自动帮我们识别当前的类型。节省了我们去看`文档`或者`network`时间。这叫做类型推导(待会我们会讲到)
- 友好地在编辑器里提示错误，避免代码在运行时类型隐式转换踩坑。

#### 缺点

- 有一定的学习成本，`TypeScript`中有几种类型概念，`interface接口`、`class类`、`enum枚举`、`generics泛型`等这些需要我们花时间学习。
- 可能和一些插件库结合的不是很完美

### TypeScript运行流程及JavaScript代码运行流程

**1. JavaScript运行流程如下，依赖NodeJs环境和浏览器环境**

- 将`JavaScript`代码转换为`JavaScript-AST`
- 将`AST`代码转换为字节码
- 运算时计算字节码

**2. TypeScript运行流程，以下操作均为TSC操作，三步执行完继续同上操作，让浏览器解析**

- 将`TypeScript`代码编译为 `TypeScript-AST`
- 检查`AST`代码上类型检查
- 类型检查后，编译为`JavaScript`代码
- `JavaScript`代码转换为`JavaScript-AST`
- 将`AST`代码转换为字节码
- 运算时计算字节码

### TypeScript和JavaScript区别

只有搞懂了二者的区别，我们才可以更好的理解`TypeScript`

| 类型系统特性           | JavaScript | TypeScript |
| :--------------------- | :--------- | :--------- |
| 类型是如何绑定？       | 动态       | 静态       |
| 是否存在类型隐式转换？ | 是         | 否         |
| 何时检查类型？         | 运行时     | 编译时     |
| 何时报告错误           | 运行时     | 编译时     |



## Node.js

Node.js是一个开源的，跨平台的JavaScript运行环境，它可以支持和理解JavaScript语言，并作为一个整体的程序运行解释过后的JavaScript指令

它集成了JavaScript的解释器，可以将JavaScript解释为机器指令

一句话，学习node.js的原因：使用js语言集成在node.js这个软件中运行，利用js的语法编写程序代码，让node.js的进程能够执行相应的任务（如作为服务器），也就是可以使用js进行有效的的后端开发

### 不同环境下的JavaScript

#### 浏览器

![image-20230808214901840](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230808214901840.png)

##### **为什么JavaScript可以在浏览器中执行？**

> 浏览器中具有针对JavaScript的解析引擎，也叫解释器，他们负责将js解析为机器指令并执行
>
> 每个浏览器具备不同的解析引擎（实现的代码内核不同）

![image-20230808215714086](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230808215714086.png)

##### **为什么JavaScript可以在浏览器中操作DOM和BOM？**

> 因为浏览器本身提供了已经编写完成的Web Api
>
> 它们本身也是用js的语法规范写的，在浏览器的内存中以字符串形式存在，会随程序员写的代码一并交给解析引擎解析

![image-20230808215917647](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230808215917647.png)

##### 浏览器的运行环境

![image-20230808220922590](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230808220922590.png)

综上我们可知，js作为一门编程语言，只要在它的运行环境内（即集成了能够将用js编写的字符串变成机器语言执行的解释器的软件平台），就能够在它的环境下运行js。

#### Node

##### node怎么学？

![image-20230809153010976](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230809153010976.png)

##### 在Node.js中执行js代码

![image-20230810114035703](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230810114035703.png)

### fs文件系统模块

![image-20230810114248019](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230810114248019.png)

#### 读取指定文件的内容

![image-20230810114600075](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230810114600075.png)

![image-20230810114718530](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230810114718530.png)

实际编写：

![image-20230811170944901](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811170944901.png)

![image-20230811170101599](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811170101599.png)

#### 向指定的文件中写入内容

![image-20230811171152958](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811171152958.png)

![image-20230811171309745](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811171309745.png)

实际编写：

![image-20230811220017534](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811220017534.png)

![image-20230811220118999](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811220118999.png)

##### 练习：考试整理

![image-20230811222530035](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811222530035.png)

![image-20230811224037665](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811224037665.png)

##### 处理路径问题

![image-20230811224224247](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811224224247.png)

问题演示：

![image-20230811225847647](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811225847647.png)

解决方案：

1.补全路径，将相对路径更改为绝对路径

![image-20230811230320265](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230811230320265.png)

缺点：移植性差，不利于维护

2.获取当前文件所处的目录

### path路径模块

引入：

```javascript
const path=require('path')
```

![image-20230812102149118](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230812102149118.png)

#### 1.使用path.join()拼接路径字符串

![image-20230812102334259](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230812102334259.png)

![image-20230813110821562](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230813110821562.png)

注意：'../'会抵消一层路径

**实际代码：**

![image-20230813110941843](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230813110941843.png)

![image-20230813112036795](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230813112036795.png)

![image-20230813112216173](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230813112216173.png)

![image-20230813113808530](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230813113808530.png)

![image-20230813113939154](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230813113939154.png)

### http模块和服务器

#### ip地址

![image-20230814224200815](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230814224200815.png)

#### 域名

![image-20230814224801747](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230814224801747.png)

![image-20230814224839032](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230814224839032.png)

### 端口号

![image-20230814225155365](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230814225155365.png)

### 搭建最基本的服务器

![image-20230814225551975](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230814225551975.png)

![image-20230814225623627](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230814225623627.png)

![image-20230814225653166](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230814225653166.png)

![image-20230815102325408](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815102325408.png)

![image-20230815102925037](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815102925037.png)

 ![image-20230815105243942](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815105243942.png)

![image-20230815105500786](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815105500786.png)

![image-20230815105652844](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815105652844.png)

![image-20230815111226865](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815111226865.png)

![image-20230815111434554](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815111434554.png)

![image-20230815111515961](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815111515961.png)

![image-20230815112949332](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815112949332.png)

![image-20230815113142305](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815113142305.png)

![image-20230815113157176](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815113157176.png)

![image-20230815113411670](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815113411670.png)

![image-20230815113825894](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815113825894.png)

![image-20230815114113997](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815114113997.png)

![image-20230815153124567](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815153124567.png)

![image-20230815154325403](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815154325403.png)

![image-20230815154815487](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815154815487.png)

![image-20230815155651711](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815155651711.png)

![image-20230815162230021](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815162230021.png)

![image-20230815162425715](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815162425715.png)

![image-20230815163909218](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815163909218.png)

![image-20230815165847552](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815165847552.png)

![image-20230815170416952](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815170416952.png)

![image-20230815170525763](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815170525763.png)

![image-20230815170558310](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815170558310.png)

![image-20230815170705540](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815170705540.png)

![image-20230815171321702](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815171321702.png)

![image-20230815175747761](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815175747761.png)

![image-20230815180504009](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815180504009.png)

![image-20230815180738807](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815180738807.png)

![image-20230815180913199](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815180913199.png)

![image-20230815181115664](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815181115664.png)

![image-20230815181218385](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815181218385.png)

![image-20230815181419079](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815181419079.png)

![image-20230815211154887](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20230815211154887.png)****

## Vue

Vue (发音为 /vjuː/，类似 **view**) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。

Vue.js全部使用JavaScript编写而成，主要在浏览器上运行，而它的文件组件则需要在node.js上运行。

[Vue中updated()和nextTick()的区别](https://www.cnblogs.com/Angelnvestor/articles/17839197.html)

### 安装

### 组合式API（vue3）

#### 创建第一个应用

每个 Vue 应用都是通过 [`createApp`](https://cn.vuejs.org/api/application.html#createapp) 函数创建一个新的 **应用实例**：

```js
import { createApp } from 'vue' 
const app = createApp({  /* 根组件选项 */ })
```

##### 根组件[](https://cn.vuejs.org/guide/essentials/application.html#the-root-component)

我们传入 `createApp` 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。

如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。

```js
import { createApp } from 'vue'
// 从一个单文件组件中导入根组件
import App from './App.vue'

const app = createApp(App)
```

虽然本指南中的许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，一个待办事项 (Todos) 应用的组件树可能是这样的：

```
App (root component)
├─ TodoList
│  └─ TodoItem
│     ├─ TodoDeleteButton
│     └─ TodoEditButton
└─ TodoFooter
   ├─ TodoClearButton
   └─ TodoStatistics
```

我们会在指南的后续章节中讨论如何定义和组合多个组件。在那之前，我们得先关注一个组件内到底发生了什么。

##### 挂载应用[](https://cn.vuejs.org/guide/essentials/application.html#mounting-the-app)

应用实例必须在调用了 `.mount()` 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：

```html
<div id="app"></div>
```

```js
app.mount('#app')
```

应用根组件的内容将会被渲染在容器元素里面。容器元素自己将**不会**被视为应用的一部分。

`.mount()` 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。

##### DOM 中的根组件模板[](https://cn.vuejs.org/guide/essentials/application.html#in-dom-root-component-template)

根组件的模板通常是组件本身的一部分，但也可以直接通过在挂载容器内编写模板来单独提供：

```html
<div id="app">
  <button @click="count++">{{ count }}</button>
</div>
```

```js
import { createApp } from 'vue'

const app = createApp({
  data() {
    return {
      count: 0
    }
  }
})

app.mount('#app')
```

当根组件没有设置 `template` 选项时，Vue 将自动使用容器的 `innerHTML` 作为模板。

DOM 内模板通常用于[无构建步骤](https://cn.vuejs.org/guide/quick-start.html#using-vue-from-cdn)的 Vue 应用程序。它们也可以与服务器端框架一起使用，其中根模板可能是由服务器动态生成的。

##### 应用配置[](https://cn.vuejs.org/guide/essentials/application.html#app-configurations)

应用实例会暴露一个 `.config` 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，用来捕获所有子组件上的错误：

js

```js
app.config.errorHandler = (err) => {
  /* 处理错误 */
}
```

应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件：

```js
app.component('TodoDeleteButton', TodoDeleteButton)
```

这使得 `TodoDeleteButton` 在应用的任何地方都是可用的。我们会在指南的后续章节中讨论关于组件和其他资源的注册。你也可以在 [API 参考](https://cn.vuejs.org/api/application.html)中浏览应用实例 API 的完整列表。

确保在挂载应用实例之前完成所有应用配置！

##### 多个应用实例[](https://cn.vuejs.org/guide/essentials/application.html#multiple-application-instances)

应用实例并不只限于一个。`createApp` API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。

```js
const app1 = createApp({
  /* ... */
})
app1.mount('#container-1')

const app2 = createApp({
  /* ... */
})
app2.mount('#container-2')
```

如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。

#### 模板语法

Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。

在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。

如果你对虚拟 DOM 的概念比较熟悉，并且偏好直接使用 JavaScript，你也可以结合可选的 JSX 支持[直接手写渲染函数](https://cn.vuejs.org/guide/extras/render-function.html)而不采用模板。但请注意，这将不会享受到和模板同等级别的编译时优化。

##### 文本插值[](https://cn.vuejs.org/guide/essentials/template-syntax.html#text-interpolation)

最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：

```html
<span>Message: {{ msg }}</span>
```

双大括号标签会被替换为[相应组件实例中](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#declaring-reactive-state) `msg` 属性的值。同时每次 `msg` 属性更改时它也会同步更新。

##### 原始 HTML[](https://cn.vuejs.org/guide/essentials/template-syntax.html#raw-html)

双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 [`v-html` 指令](https://cn.vuejs.org/api/built-in-directives.html#v-html)：

```html
<p>Using text interpolation: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```



Using text interpolation: <span style="color: red">This should be red.</span>

Using v-html directive: This should be red.



这里我们遇到了一个新的概念。这里看到的 `v-html` attribute 被称为一个**指令**。指令由 `v-` 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 `rawHtml` 属性保持同步。

`span` 的内容将会被替换为 `rawHtml` 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 `v-html` 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。

安全警告

在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 [XSS 漏洞](https://zh.wikipedia.org/wiki/跨網站指令碼)。请仅在内容安全可信时再使用 `v-html`，并且**永远不要**使用用户提供的 HTML 内容。

##### Attribute 绑定[](https://cn.vuejs.org/guide/essentials/template-syntax.html#attribute-bindings)

双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 [`v-bind` 指令](https://cn.vuejs.org/api/built-in-directives.html#v-bind)：

```html
<div v-bind:id="dynamicId"></div>
```

`v-bind` 指令指示 Vue 将元素的 `id` attribute 与组件的 `dynamicId` 属性保持一致。如果绑定的值是 `null` 或者 `undefined`，那么该 attribute 将会从渲染的元素上移除。

##### 简写[](https://cn.vuejs.org/guide/essentials/template-syntax.html#shorthand)

因为 `v-bind` 非常常用，我们提供了特定的简写语法：

template

```vue
<div :id="dynamicId"></div>
```

开头为 `:` 的 attribute 可能和一般的 HTML attribute 看起来不太一样，但它的确是合法的 attribute 名称字符，并且所有支持 Vue 的浏览器都能正确解析它。此外，他们不会出现在最终渲染的 DOM 中。简写语法是可选的，但相信在你了解了它更多的用处后，你应该会更喜欢它。

> 接下来的指引中，我们都将在示例中使用简写语法，因为这是在实际开发中更常见的用法。

##### 同名简写 [](https://cn.vuejs.org/guide/essentials/template-syntax.html#same-name-shorthand)

如果 attribute 的名称与绑定的 JavaScript 值的名称相同，那么可以进一步简化语法，省略 attribute 值：

template

```vue
<!-- 与 :id="id" 相同 -->
<div :id></div>

<!-- 这也同样有效 -->
<div v-bind:id></div>
```

这与在 JavaScript 中声明对象时使用的属性简写语法类似。请注意，这是一个只在 Vue 3.4 及以上版本中可用的特性。

##### 布尔型 Attribute[](https://cn.vuejs.org/guide/essentials/template-syntax.html#boolean-attributes)

[布尔型 attribute](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes#布尔值属性) 依据 true / false 值来决定 attribute 是否应该存在于该元素上。[`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled) 就是最常见的例子之一。

`v-bind` 在这种场景下的行为略有不同：

```vue
<button :disabled="isButtonDisabled">Button</button>
```

当 `isButtonDisabled` 为[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)或一个空字符串 (即 `<button disabled="">`) 时，元素会包含这个 `disabled` attribute。而当其为其他[假值](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)时 attribute 将被忽略。

##### 动态绑定多个值[](https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes)

如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：

```js
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper'
}
```

通过不带参数的 `v-bind`，你可以将它们绑定到单个元素上：

```vue
<div v-bind="objectOfAttrs"></div>
```

##### 使用 JavaScript 表达式[](https://cn.vuejs.org/guide/essentials/template-syntax.html#using-javascript-expressions)

至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：

```html
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div :id="`list-${id}`"></div>
```

这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。

在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：

- 在文本插值中 (双大括号)
- 在任何 Vue 指令 (以 `v-` 开头的特殊 attribute) attribute 的值中

##### 仅支持表达式[](https://cn.vuejs.org/guide/essentials/template-syntax.html#expressions-only)

每个绑定仅支持**单一表达式**，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 `return` 后面。

因此，下面的例子都是**无效**的：

```
<!-- 这是一个语句，而非表达式 -->
{{ var a = 1 }}

<!-- 条件控制也不支持，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

##### 调用函数[](https://cn.vuejs.org/guide/essentials/template-syntax.html#calling-functions)

可以在绑定的表达式中使用一个组件暴露的方法：

```vue
<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>
```

绑定在表达式中的方法在组件每次更新时都会被重新调用，因此**不**应该产生任何副作用，比如改变数据或触发异步操作。

##### 受限的全局访问[](https://cn.vuejs.org/guide/essentials/template-syntax.html#restricted-globals-access)

模板中的表达式将被沙盒化，仅能够访问到[有限的全局对象列表](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3)。该列表中会暴露常用的内置全局对象，比如 `Math` 和 `Date`。

没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 `window` 上的属性。然而，你也可以自行在 [`app.config.globalProperties`](https://cn.vuejs.org/api/application.html#app-config-globalproperties) 上显式地添加它们，供所有的 Vue 表达式使用。

##### 指令 Directives[](https://cn.vuejs.org/guide/essentials/template-syntax.html#directives)

指令是带有 `v-` 前缀的特殊 attribute。Vue 提供了许多[内置指令](https://cn.vuejs.org/api/built-in-directives.html)，包括上面我们所介绍的 `v-bind` 和 `v-html`。

指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 `v-for`、`v-on` 和 `v-slot`)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 [`v-if`](https://cn.vuejs.org/api/built-in-directives.html#v-if) 为例：

```html
<p v-if="seen">Now you see me</p>
```

这里，`v-if` 指令会基于表达式 `seen` 的值的真假来移除/插入该 `<p>` 元素。

##### 参数 Arguments[](https://cn.vuejs.org/guide/essentials/template-syntax.html#arguments)

某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 `v-bind` 指令来响应式地更新一个 HTML attribute：

```html
<a v-bind:href="url"> ... </a>

<!-- 简写 -->
<a :href="url"> ... </a>
```

这里 `href` 就是一个参数，它告诉 `v-bind` 指令将表达式 `url` 的值绑定到元素的 `href` attribute 上。在简写中，参数前的一切 (例如 `v-bind:`) 都会被缩略为一个 `:` 字符。

另一个例子是 `v-on` 指令，它将监听 DOM 事件：

```html
<a v-on:click="doSomething"> ... </a>

<!-- 简写 -->
<a @click="doSomething"> ... </a>
```

这里的参数是要监听的事件名称：`click`。`v-on` 有一个相应的缩写，即 `@` 字符。我们之后也会讨论关于事件处理的更多细节。

##### 动态参数[](https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamic-arguments)

同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：

```html
<!--
注意，参数表达式有一些约束，
参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释
-->
<a v-bind:[attributeName]="url"> ... </a>

<!-- 简写 -->
<a :[attributeName]="url"> ... </a>
```

这里的 `attributeName` 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 `attributeName`，其值为 `"href"`，那么这个绑定就等价于 `v-bind:href`。

相似地，你还可以将一个函数绑定到动态的事件名称上：

```html
<a v-on:[eventName]="doSomething"> ... </a>

<!-- 简写 -->
<a @[eventName]="doSomething"> ... </a>
```

在此示例中，当 `eventName` 的值是 `"focus"` 时，`v-on:[eventName]` 就等价于 `v-on:focus`。

##### 动态参数值的限制[](https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamic-argument-value-constraints)

动态参数中表达式的值应当是一个字符串，或者是 `null`。特殊值 `null` 意为显式移除该绑定。其他非字符串的值会触发警告。

##### 动态参数语法的限制[](https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamic-argument-syntax-constraints)

动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：

template

```vue
<!-- 这会触发一个编译器警告 -->
<a :['foo' + bar]="value"> ... </a>
```

如果你需要传入一个复杂的动态参数，我们推荐使用[计算属性](https://cn.vuejs.org/guide/essentials/computed.html)替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。

当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：

```vue
<a :[someAttr]="value"> ... </a>
```

上面的例子将会在 DOM 内嵌模板中被转换为 `:[someattr]`。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板**不**受此限制。

##### 修饰符 Modifiers[](https://cn.vuejs.org/guide/essentials/template-syntax.html#modifiers)

修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 `.prevent` 修饰符会告知 `v-on` 指令对触发的事件调用 `event.preventDefault()`：

```vue
<form @submit.prevent="onSubmit">...</form>
```

之后在讲到 [`v-on`](https://cn.vuejs.org/guide/essentials/event-handling.html#event-modifiers) 和 [`v-model`](https://cn.vuejs.org/guide/essentials/forms.html#modifiers) 的功能时，你将会看到其他修饰符的例子。

最后，在这里你可以直观地看到完整的指令语法：

![指令语法图](https://cn.vuejs.org/assets/directive.7WSr6AKH.png)

#### 响应式基础

## 声明响应式状态[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#declaring-reactive-state-1)

### `ref()`[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#ref)

在组合式 API 中，推荐使用 [`ref()`](https://cn.vuejs.org/api/reactivity-core.html#ref) 函数来声明响应式状态：

```js
import { ref } from 'vue'

const count = ref(0)
```

`ref()` 接收参数，并将其包裹在一个带有 `.value` 属性的 ref 对象中返回：

```js
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

要在组件模板中访问 ref，请从组件的 `setup()` 函数中声明并返回它们：

```js
import { ref } from 'vue'

export default {
  // `setup` 是一个特殊的钩子，专门用于组合式 API。
  setup() {
    const count = ref(0)

    // 将 ref 暴露给模板
    return {
      count
    }
  }
}
```

```vue
<div>{{ count }}</div>
```

注意，在模板中使用 ref 时，我们**不**需要附加 `.value`。为了方便起见，当在模板中使用时，ref 会自动解包 (有一些[注意事项](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#caveat-when-unwrapping-in-templates))。

你也可以直接在事件监听器中改变一个 ref：

```vue
<button @click="count++">
  {{ count }}
</button>
```

对于更复杂的逻辑，我们可以在同一作用域内声明更改 ref 的函数，并将它们作为方法与状态一起公开：

```js
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)

    function increment() {
      // 在 JavaScript 中需要 .value
      count.value++
    }

    // 不要忘记同时暴露 increment 函数
    return {
      count,
      increment
    }
  }
}
```

然后，暴露的方法可以被用作事件监听器：

template

```vue
<button @click="increment">
  {{ count }}
</button>
```

这里是 [Codepen](https://codepen.io/vuejs-examples/pen/WNYbaqo) 上的例子，没有使用任何构建工具。

### `<script setup>`[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#script-setup)

在 `setup()` 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用[单文件组件 (SFC)](https://cn.vuejs.org/guide/scaling-up/sfc.html) 来避免这种情况。我们可以使用 `<script setup>` 来大幅度地简化代码：

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}
</script>

<template>
  <button @click="increment">
    {{ count }}
  </button>
</template>
```

[在演练场中尝试一下](https://play.vuejs.org/#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi)

<script setup> 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。

TIP

在指南的后续章节中，我们基本上都会在组合式 API 示例中使用单文件组件 + `<script setup>` 的语法，因为大多数 Vue 开发者都会这样使用。

如果你没有使用单文件组件，你仍然可以在 [`setup()`](https://cn.vuejs.org/api/composition-api-setup.html) 选项中使用组合式 API。

### 为什么要使用 ref？[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#why-refs)

你可能会好奇：为什么我们需要使用带有 `.value` 的 ref，而不是普通的变量？为了解释这一点，我们需要简单地讨论一下 Vue 的响应式系统是如何工作的。

当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会**追踪**在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会**触发**追踪它的组件的一次重新渲染。

在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。

该 `.value` 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：

js

```
// 伪代码，不是真正的实现
const myRef = {
  _value: 0,
  get value() {
    track()
    return this._value
  },
  set value(newValue) {
    this._value = newValue
    trigger()
  }
}
```

另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。

该响应性系统在[深入响应式原理](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html)章节中有更详细的讨论。

### 深层响应性[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#deep-reactivity)

Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 `Map`。

Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：

js

```
import { ref } from 'vue'

const obj = ref({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // 以下都会按照期望工作
  obj.value.nested.count++
  obj.value.arr.push('baz')
}
```

非原始值将通过 [`reactive()`](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactive) 转换为响应式代理，该函数将在后面讨论。

也可以通过 [shallow ref](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref) 来放弃深层响应性。对于浅层 ref，只有 `.value` 的访问会被追踪。浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。

阅读更多：

- [减少大型不可变数据的响应性开销](https://cn.vuejs.org/guide/best-practices/performance.html#reduce-reactivity-overhead-for-large-immutable-structures)
- [与外部状态系统集成](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#integration-with-external-state-systems)

### DOM 更新时机[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#dom-update-timing)

当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。

要等待 DOM 更新完成后再执行额外的代码，可以使用 [nextTick()](https://cn.vuejs.org/api/general.html#nexttick) 全局 API：

js

```
import { nextTick } from 'vue'

async function increment() {
  count.value++
  await nextTick()
  // 现在 DOM 已经更新了
}
```

## `reactive()`[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactive)

还有另一种声明响应式状态的方式，即使用 `reactive()` API。与将内部值包装在特殊对象中的 ref 不同，`reactive()` 将使对象本身具有响应性：

js

```
import { reactive } from 'vue'

const state = reactive({ count: 0 })
```

> 参考：[为 `reactive()` 标注类型](https://cn.vuejs.org/guide/typescript/composition-api.html#typing-reactive) 

在模板中使用：

template

```
<button @click="state.count++">
  {{ state.count }}
</button>
```

响应式对象是 [JavaScript 代理](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，其行为就和普通对象一样。不同的是，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。

`reactive()` 将深层地转换对象：当访问嵌套对象时，它们也会被 `reactive()` 包装。当 ref 的值是一个对象时，`ref()` 也会在内部调用它。与浅层 ref 类似，这里也有一个 [`shallowReactive()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) API 可以选择退出深层响应性。

### Reactive Proxy vs. Original[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactive-proxy-vs-original-1)

值得注意的是，`reactive()` 返回的是一个原始对象的 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，它和原始对象是不相等的：

js

```
const raw = {}
const proxy = reactive(raw)

// 代理对象和原始对象不是全等的
console.log(proxy === raw) // false
```

只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是 **仅使用你声明对象的代理版本**。

为保证访问代理的一致性，对同一个原始对象调用 `reactive()` 会总是返回同样的代理对象，而对一个已存在的代理对象调用 `reactive()` 会返回其本身：

js

```
// 在同一个对象上调用 reactive() 会返回相同的代理
console.log(reactive(raw) === proxy) // true

// 在一个代理上调用 reactive() 会返回它自己
console.log(reactive(proxy) === proxy) // true
```

这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理：

js

```
const proxy = reactive({})

const raw = {}
proxy.nested = raw

console.log(proxy.nested === raw) // false
```

### `reactive()` 的局限性[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#limitations-of-reactive)

`reactive()` API 有一些局限性：

1. **有限的值类型**：它只能用于对象类型 (对象、数组和如 `Map`、`Set` 这样的[集合类型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections))。它不能持有如 `string`、`number` 或 `boolean` 这样的[原始类型](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)。

2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：

   js

   ```
   let state = reactive({ count: 0 })
   
   // 上面的 ({ count: 0 }) 引用将不再被追踪
   // (响应性连接已丢失！)
   state = reactive({ count: 1 })
   ```

3. **对解构操作不友好**：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：

   js

   ```
   const state = reactive({ count: 0 })
   
   // 当解构时，count 已经与 state.count 断开连接
   let { count } = state
   // 不会影响原始的 state
   count++
   
   // 该函数接收到的是一个普通的数字
   // 并且无法追踪 state.count 的变化
   // 我们必须传入整个对象以保持响应性
   callSomeFunction(state.count)
   ```

由于这些限制，我们建议使用 `ref()` 作为声明响应式状态的主要 API。

## 额外的 ref 解包细节[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#additional-ref-unwrapping-details)

### 作为 reactive 对象的属性[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#ref-unwrapping-as-reactive-object-property)

一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性：

js

```
const count = ref(0)
const state = reactive({
  count
})

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
```

如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：

js

```
const otherCount = ref(2)

state.count = otherCount
console.log(state.count) // 2
// 原始 ref 现在已经和 state.count 失去联系
console.log(count.value) // 1
```

只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为[浅层响应式对象](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive)的属性被访问时不会解包。

### 数组和集合的注意事项[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#caveat-in-arrays-and-collections)

与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型(如 `Map`) 中的元素被访问时，它**不会**被解包：

js

```
const books = reactive([ref('Vue 3 Guide')])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// 这里需要 .value
console.log(map.get('count').value)
```

### 在模板中解包的注意事项[](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#caveat-when-unwrapping-in-templates)

在模板渲染上下文中，只有顶级的 ref 属性才会被解包。

在下面的例子中，`count` 和 `object` 是顶级属性，但 `object.id` 不是：

js

```
const count = ref(0)
const object = { id: ref(1) }
```

因此，这个表达式按预期工作：

template

```
{{ count + 1 }}
```

...但这个**不会**：

template

```
{{ object.id + 1 }}
```

渲染的结果将是 `[object Object]1`，因为在计算表达式时 `object.id` 没有被解包，仍然是一个 ref 对象。为了解决这个问题，我们可以将 `id` 解构为一个顶级属性：

js

```
const { id } = object
```

template

```
{{ id + 1 }}
```

现在渲染的结果将是 `2`。

另一个需要注意的点是，如果 ref 是文本插值的最终计算值 (即 `{{ }}` 标签)，那么它将被解包，因此以下内容将渲染为 `1`：

template

```
{{ object.id }}
```

该特性仅仅是文本插值的一个便利特性，等价于 `{{ object.id.value }}`。

## 包管理工具

### npm

### yarn

[yarn.lock 文件介绍-CSDN博客](https://blog.csdn.net/wan212000/article/details/125302217)

## 工程化