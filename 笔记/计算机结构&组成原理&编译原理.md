# 计算机结构&组成原理

## CPU

### 基本组成

CPU（Central Processing Unit，中央处理器）是计算机的核心部件，它主要负责执行计算机指令，控制计算机的操作和运行。

CPU的核心组成部分由ALU（逻辑运算单元）、寄存器、控制器、缓存、总线构成。

1. 控制单元（Control Unit，CU）：负责控制CPU内部的操作和指令的执行。它从内存中读取指令，解码指令，确定指令的操作类型和操作数，然后控制CPU内部的寄存器和运算器执行指令。
2. 运算器（Arithmetic Logic Unit，ALU）：负责执行算术和逻辑运算。它从寄存器中读取操作数，并根据指令执行相应的运算，然后将运算结果存储回寄存器。
3. 寄存器（Register）：用于暂存指令和数据。CPU内部包含多个寄存器，每个寄存器可以存储一定量的数据。常见的寄存器包括通用寄存器、段寄存器、标志寄存器等。
4. 缓存（Cache）：用于存储常用的指令和数据，提高CPU的访问速度。缓存可以分为多级，常见的有一级缓存（L1 Cache）、二级缓存（L2 Cache）等。
5. 总线（Bus）：用于CPU和其他计算机组件之间的通信。总线分为数据总线、地址总线和控制总线，分别用于传输数据、地址和控制信息。

这些部分协同工作，实现了CPU的功能。当计算机执行一条指令时，控制单元从内存中读取指令，解码指令后，将操作数传递给运算器进行运算，最终将运算结果存储回寄存器中。这样就完成了一次CPU的运算过程。

### 总线与地址

#### 是什么？

CPU通过外部地址总线和各个硬件进行连接

CPU和内存（RAM）直接相连，和各硬件（键盘、鼠标）等通过硬件控制器相连接

系统总线是一组电子线路，它将不同部件之间传递的数据、地址和控制信号绑定在一起，从而使得CPU、内存、硬盘、显卡等各个部件之间可以相互通信和协作。

当CPU需要访问内存或者其他硬件设备时，它会向总线发送一些控制信号和地址，然后等待响应。

总线会将这些信号和地址传递给对应的硬件设备，然后从设备中读取或者写入数据，并将结果返回给CPU。CPU通过识别总线上的不同信号和地址，以及接收到的响应数据，就能够实现与其他硬件设备的通信和交互。

硬件在总线中，会被标记为特定的物理地址

硬件的物理地址由一串十六进制数组成。

当CPU发送一个地址时，硬件设备（如内存或硬盘控制器）会检查地址的一些特定位来判断这个地址是否属于自己的地址空间。

硬件设备的地址空间通常是通过一组地址线来定义的，地址线的数量决定了硬件设备可以寻址的内存或IO端口的大小。

例如，一个设备可能定义了一个32位的地址空间，这意味着它可以寻址的内存或IO端口的大小为2^32个字节。当CPU发送一个地址时，硬件设备会检查地址的高位，看它是否匹配该设备的地址空间范围。如果地址匹配，则设备会响应CPU的请求，如果不匹配，则设备会忽略CPU的请求，从而避免对其他设备的干扰

因此，硬件本身会根据连接到它们的地址线的地址，把地址的表示数（十六进制数）保存在寄存器中，当CPU发送信号时，硬件本身会根据保存在寄存器中的数据进行比较和检查，从而响应和回答CPU发送过来的信号。

### 寄存器

#### 是什么?

- 寄存器是CPU的重要组成部分，CPU对指令、数据、地址的提取均离不开寄存器的暂存作用。
- 寄存器是CPU内部的高速存储器件，用于存储指令、数据、地址等信息。CPU通过寄存器来暂存数据、中间结果等，以完成各种计算、判断、转移等操作。寄存器的访问速度非常快，比内存等其他存储器件要快得多，因此寄存器的使用可以大大提高CPU的运行效率。

#### 分类（以x86架构、32位为例）

##### 通用寄存器

###### 累加寄存器(EAX)d/&

通常用于存储函数返回值或运算结果。运算完毕后会根据需要进入到相应的其它寄存器内部。

###### 基址寄存器(EBP)&

通常用于存储内存地址，作为数据访问的基址，存储的地址为段内存地址的偏移量。在运行某个应用程序时，通常会将段寄存器存储的地址加上基址寄存器的地址，从内存中读取数据时，会将段寄存器存储的地址加上基址寄存器的地址的结果复制一份到索引寄存器中。

###### 程序计数器(PC/ECX)&

用于存储指令的（提取）地址，执行完指令后，内部地址会被控制器默认加一。

###### 数据寄存器(EDX)d/&/OP

万能寄存器，可存储临时指令、地址和操作数，为控制器执行指令、操作各寄存器的中间寄存器

###### 栈顶指针寄存器（ESP）&

用于存储栈顶地址，通常和段栈内存寄存器组合存储栈顶偏移量地址

###### 基址指针寄存器（EBP）&

用于存储栈底地址，通常作为函数的栈帧基址,通常和段栈内存寄存器组合存储栈顶偏移量地址。

###### 源索引寄存器(ESI)&

源索引寄存器，通常用于存储源数据的地址。即内存赋值等相关操作中cpu通过地址总线想要读取到数据寄存器内的数据的物理地址位置

###### 目的索引寄存器&

通常用于存储目标数据的地址。即内存赋值等相关操作中cpu通过地址总线想要从数据寄存器内转移到硬件寄存器中的目标物理地址位置

##### 段寄存器

段寄存器内部一般存储的是内存段区域的地址

段寄存器是在x86架构的计算机中用于管理内存分段的寄存器。以下是所有涉及到段寄存器操作的指令：

1. MOV：将数据从一个寄存器或内存位置传送到段寄存器。
2. PUSH：将段寄存器中的值压入堆栈中。
3. POP：将堆栈顶部的值弹出到段寄存器中。
4. LDS：将指定内存地址中的数据加载到段寄存器和通用寄存器中。
5. LES：将指定内存地址中的数据加载到段寄存器和通用寄存器中。
6. LSS：将指定内存地址中的数据加载到段寄存器和通用寄存器中。
7. LFS：将指定内存地址中的数据加载到段寄存器和通用寄存器中。
8. LGS：将指定内存地址中的数据加载到段寄存器和通用寄存器中。
9. CALL：将当前指令的下一条指令的地址压入堆栈中，并将段寄存器设置为新的代码段选择器。
10. RET：将堆栈顶部的值弹出到指令指针寄存器中，并将段寄存器设置为相应的返回地址。
11. JMP：跳转到指定地址，并将段寄存器设置为新的代码段选择器。
12. INT：执行中断指令，并将段寄存器设置为中断处理程序所在的段选择器。

以上是x86架构计算机中涉及到段寄存器操作的指令，这些指令可以用于对内存分段进行操作和管理。

###### CS（Code Segment）代码段寄存器

代码段寄存器，用于存储代码段的描述符，指向当前正在执行的指令所在的代码段。

###### DS（Data Segment）数据段寄存器

用于存储数据段的描述符，指向程序中存储数据的内存区域。

###### SS（Stack Segment）堆栈段寄存器

用于存储堆栈段的描述符，指向程序中存储堆栈的内存区域。

###### ES（Extra Segment）附加段寄存器

通常用于存储程序中需要额外的数据段描述符，可以用于存储程序中其它数据段的描述符。

###### FS（F Segment）F段寄存器

用于存储附加的系统段描述符。

###### GS（G Segment）G段寄存器

用于存储附加的系统段描述符。

在实模式下，这些段寄存器的作用是直接计算物理地址。在保护模式下，段寄存器的作用是存储段选择子，然后通过段选择子找到段描述符，再使用段描述符中的基地址、限长等信息计算出线性地址，最终转换为物理地址。

需要注意的是，在64位模式下，段寄存器的作用不再是直接计算地址，而是用于选择描述符表中的描述符，描述符表中的描述符再用于计算地址。64位模式下，CPU引入了一种新的机制，称为“段选择子缓存（Segment Selector Cache）”，简称“段缓存（Segment Cache）”，用于加速段选择子到段描述符的转换，提高系统性能。

##### 其它寄存器

1. 标志寄存器：EFLAGS。这个寄存器存储了各种处理器状态信息，例如进位标志、零标志、符号标志和溢出标志。

   标志寄存器（Flags Register）是一种特殊的CPU寄存器，用于存储某些CPU运算的状态信息，通常被称为标志位（Flags）。这些标志位用于表示最近一次运算的结果，例如比较结果、溢出状态、进位状态等。

   标志寄存器通常是一个8位或16位的二进制寄存器，由多个位组成，每个位都对应着一个特定的标志位。不同的CPU架构具有不同的标志位，但一般都包括以下几个标志位：

   - 零标志位（ZF）：用于指示上一次运算结果是否为0。
   - 符号标志位（SF）：用于指示上一次运算结果的符号。
   - 进位标志位（CF）：用于指示上一次运算是否发生了进位或借位。
   - 溢出标志位（OF）：用于指示上一次运算是否发生了溢出。

   除了上述标志位之外，不同的CPU架构还可能包括其他标志位，例如调试标志位、中断标志位等。

   标志寄存器可以通过特定的指令读取或修改，例如条件跳转指令可以根据标志寄存器的值来进行跳转。在程序执行过程中，CPU会根据运算的结果自动更新标志寄存器的值，以便于后续指令的执行和程序的运行。

2. 控制寄存器：CR0、CR2、CR3、CR4。这些寄存器用于控制处理器的运行状态和系统内存管理。

3. 调试寄存器：DR0、DR1、DR2、DR3、DR6、DR7。这些寄存器用于处理器调试和跟踪功能。

4. 浮点数寄存器：ST0-ST7。这些寄存器用于浮点数运算，例如浮点数加减乘除和浮点数取整。

5. SIMD寄存器：XMM0-XMM15、YMM0-YMM15、ZMM0-ZMM31。这些寄存器用于向量化数据处理，例如SIMD指令集中的加法、乘法、平均值和最大值等运算。

### 控制器

CPU控制器（也称为控制单元）是计算机+处理器的一个关键组成部分。它的作用是控制计算机的操作，确保处理器能够按照指令顺序执行程序。在CPU的工作过程中，由它从待取寄存器中读取指令并和保存在CPU内的指令集比较并解析，指导CPU内的程序进一步操作。

具体来说，CPU控制器的主要作用有：

1. 指令解码：将计算机内存中的指令读入CPU，并将其解码成处理器能够理解的格式。控制器将指令中的操作码和操作数分离出来，以便于CPU执行指令。
2. 操作控制：控制器负责将处理器的各个部件协调起来，以确保指令被正确地执行。例如，控制器会将算术运算器和寄存器组合起来，以实现对数据的加、减、乘、除等运算。
3. 分支控制：控制器还负责检测分支指令，并根据指令中给出的条件决定程序的执行路径。如果条件为真，则程序将跳转到指定的位置继续执行，否则将继续执行下一条指令。

控制器是CPU内部的重要控制部件，会发送多种类型的电信号，其中一些包括：

1. 时钟信号：会发送时钟信号来同步各个部件的操作，确保它们按照正确的时序执行指令。
2. 地址信号：会发送地址信号来指示它需要访问哪个存储器单元或者I/O设备。
3. 数据信号：会发送数据信号，将指令或数据传送到内存或I/O设备，或者从内存或I/O设备读取数据。
4. 控制信号：会发送控制信号来控制各个部件的操作，例如使指令寄存器(IR)将指令读入到解码器中进行解码，或者使算术逻辑单元(ALU)执行某种算术或逻辑操作。
5. 中断信号：会接收来自其他设备的中断信号，以通知它们需要CPU执行某些操作，例如读取数据或响应某些事件。

实际上，任何被总线连接的硬件都具备处理基本信号的能力。包括CPU内部的寄存器、ALU和计算机外部的组成硬件等。

这些信号一起协调CPU的操作，确保它能够执行正确的指令序列，读写正确的数据，以及响应其他设备的请求。

### 指令集

CPU的指令集就储存在控制器中。

在现代计算机中，指令集被储存在CPU的只读存储器中，即ROM（Read-Only Memory）。ROM中的内容不能被改写，因此指令集也无法被修改。这样做的好处是保证指令集的稳定性和可靠性，使得程序可以在不同的计算机上运行。

不过，现代CPU的设计通常采用了一些高级技术，如缓存、预取、分支预测等，以提高CPU的性能。这些技术会对指令的执行顺序和方式进行优化，以便更快地完成指令的执行。因此，实际上CPU的执行顺序和指令集所描述的执行顺序并不完全一致。但是，这些技术都是基于指令集的基础之上进行的，而指令集依然是CPU的基本运行机制。

#### 指令

指令是由计算机程序编译器将高级语言代码转换成机器语言代码的过程中生成的。计算机程序编译器是一种特殊的软件，它可以将高级语言代码（如C、C++、Java等）翻译成机器语言代码，使得计算机可以直接执行这些指令。

具体地，编译器将高级语言代码分为多个语句，并通过语法分析、语义分析等技术对语句进行处理，生成对应的机器语言代码。编译器通常包括以下步骤：

1. 词法分析：将高级语言代码分解成词法单元，如关键字、标识符、运算符等。
2. 语法分析：根据语法规则，将词法单元组成语法结构，如表达式、语句、函数等。
3. 语义分析：对语法结构进行分析，检查语义的正确性，并生成中间代码。
4. 优化：对中间代码进行优化，使得生成的机器代码更加高效。
5. 代码生成：将优化后的中间代码转换为机器语言代码，生成可执行文件。

在代码生成的过程中，编译器会将高级语言代码转换成汇编语言代码，然后再将汇编语言代码转换为机器语言代码。汇编语言代码是一种更接近于机器语言的低级语言，它使用简单的助记符来表示机器语言指令，方便程序员进行编写和调试。

最终生成的机器语言代码是一种二进制形式的指令序列，可以直接被计算机硬件执行。这些指令被存储在计算机的内存中，并由处理器按照指令序列依次执行，完成计算机程序的运行。

#### 操作数

在计算机中，操作数是指要参与运算的数据。操作数可以分为以下几类：

1. 立即数（Immediate）：立即数是直接出现在指令中的数据，不需要从内存中获取。立即数通常被用于存储常量、偏移量等。例如，在x86架构中，可以使用`MOV AX, 1234h`将立即数1234h存储到寄存器AX中。

2. 寄存器（Register）：寄存器是位于CPU内部的存储器，可以直接用于存储和操作数据。CPU通常具有多个通用寄存器，例如x86架构中的AX、BX、CX、DX等寄存器。寄存器在汇编语言中，直接用寄存器的名称表示该操作数。**实际上，寄存器的名称代表的是寄存器的物理操作地址。**

3. 内存（Memory）（地址）：内存是指位于CPU外部的存储器，需要通过地址访问。内存中存储的数据可以被加载到寄存器中进行操作。在汇编语言中，内存操作通常需要指定操作的地址和寻址方式，例如`MOV AX, [BX+SI]`表示将BX和SI指向的地址中的数据读取到AX寄存器中。

4. 标志（Flag）：标志是指CPU内部的一些标志位，用于记录运算过程中的一些状态。例如，ZF标志位表示最近一次运算结果是否为0，CF标志位表示最近一次运算是否产生了进位等等。标志位通常不能直接被操作，但是它们可以影响运算结果和流程。

5. 标号（Label）：标号是在汇编语言中用来表示代码地址的符号，类似于变量名。标号可以用于跳转指令中，例如`JMP Label1`表示跳转到Label1处执行代码。**标号在正式的机器码中只会被汇编器编译成相对地址**。

   在 x86 架构中，标号通常被用作跳转指令的目标地址，例如 JMP 指令和 CALL 指令。当指令包含标号作为目标地址时，汇编器会把标号转换成相应的内存地址，并把地址保存在指定的寄存器中。具体来说，对于 JMP 和 CALL 指令，汇编器会把标号对应的内存地址保存在指令中的相对偏移量字段中，然后通过基址寄存器（如 EIP、ESP、EBP 等）加上该偏移量来计算目标地址。而对于寻址方式为间接寻址的指令，汇编器也可
   
   
   
   以使用标号来指定目标内存地址。
   
   需要注意的是，标号不会直接保存在基址寄存器中，而是会被转换成相应的内存地址，并把地址保存在指令中或者寄存器中，然后通过基址寄存器来计算目标地址。

x86 CPU 的指令集可以分为以下几类：

##### 数据传输指令

这类指令用于在寄存器和内存之间传输数据，包括MOV、PUSH、POP、LEA等指令。

###### MOV

MOV指令是x86汇编语言中的一条指令，它的全称是"Move"，中文意思是"移动"。MOV指令的功能是将数据从一个位置（通常是内存或寄存器）移动到另一个位置（通常是寄存器或内存）。

MOV指令的语法如下：

```assembly
MOV dest, src
```

其中，

`dest`是指定的目标操作数只能为地址或寄存器

`src`是指定的源操作数，可以是内存地址、寄存器或立即数。

MOV指令的操作过程如下：

1. 控制器读取指令后，将操作数分离，保存在控制器内部的缓存中（两个操作数），然后针对源操作数，若为直接数或者指令，则复制一份到控制器内的第一位；若为地址操作数，先通过总线向控制器外部发送READ和这个地址信号，读取外部保存的数据，再复制到控制器内寄存器第一位。若读取的数据仍是一个地址（将源操作数`src`中的数据加载到CPU缓存中），若无，则会报错，此时考虑用LEA替换。

2. 将加载的数据移动到目标操作数`dest`所指定的位置中。dest的数据只能为地址。控制器根据dest的地址，依次向总线发送WRITE和该地址信号。

   例如，对于指令 `MOV EAX, [ebx]`，CPU 需要执行以下步骤：

   1. 解析指令：CPU控制器 解析出 `MOV` 指令，并确定源操作数为 `[ebx]`，目的操作数为 `EAX`，在指令计算前，先提取基本操作数ebx和EAX，对ebx进行取值地址运算。
   2. 计算源操作数的地址：CPU 根据指令中的地址计算公式，计算出 `[ebx]` 的内存地址，覆盖原有的ebx操作数为[ebx]
   3. 读取源操作数的值：CPU 从内存中读取 `[ebx]` 的值。
   4. 计算目的操作数的地址：由于目的操作数是 `EAX` 寄存器，CPU 不需要计算地址。
   5. 写入目的操作数的值：CPU 将 `[ebx]` 的值写入到 `EAX` 寄存器中。


需要注意的是，MOV指令不是简单地进行数据拷贝，而是将数据从一个位置移动到另一个位置。这意味着，在MOV指令执行后，源操作数中的数据通常会被清空或被修改，而目标操作数中会被存储新的数据。

MOV指令是x86汇编语言中最常用的指令之一，它在程序中被广泛用于数据的读取、存储和操作等方面。由于数据在内存和寄存器之间的移动是程序中最常见的操作之一，因此MOV指令也是最常见的指令之一。

> C语言中的赋值语句`=`就是对应了汇编语言中的MOV指令，例如：

```c
int b;// 相当于 LEA b对应基址寄存器地址, b分配的偏移量地址
b = 10; // 相当于 MOV [堆栈段寄存器/数据段寄存器+b对应的基址寄存器], 10
```

> Java语言中的赋值语句也是对应了汇编语言中的MOV指令，例如：

```java
int a = 10;
int b;
b = a; // 相当于 MOV 堆栈段寄存器/数据段寄存器+b对应的基址寄存器, [堆栈段寄存器/数据段寄存器+a对应的基址寄存器]
```

需要注意的是，高级编程语言中的赋值语句通常包含了更多的语法和语义元素，例如类型检查、指针引用等等。然而，它们的基本功能都是将数据从一个位置移动到另一个位置。

###### LEA

**LEA指令（Load Effective Address）是一条汇编指令，用于将某个地址计算结果存储到指定寄存器中，而不是将该地址所指向的内容读取到寄存器中。**

LEA指令的功能是取偏移地址， 指令形式是从存储器读数据到寄存器, 效果是将存储器的有效地址写入到目的操作数, 类似, C语言中的”&”.
它的指令形式是从存储器读数据到寄存器，但实际上它根本就没有引用存储器。 他只是取地址但是并没有取地址对应的值。

它和MOV指令最大的区别就是，它的第二个操作数只能为地址。同时，在操作数于控制器内部计算完毕后，控制器不会发送READ信号并且把这个地址发出去，它是直接把地址视为MOV指令中的直接数来看待，即复制到控制器寄存的第二位。

LEA指令的语法通常为：

```assembly
LEA destination, source
```

其中，destination表示要存储结果的目标寄存器，source则表示用于计算的源地址。

LEA指令常用于计算数组、结构体等数据结构中元素的地址。由于LEA指令只是将地址计算结果存储到寄存器中，而不是读取该地址所指向的数据，因此可以节省读取数据的时间和内存开销。

例如，在x86架构的汇编语言中，可以使用LEA指令计算数组元素的地址，如下所示：

```assembly
EBX, 0      ; 初始化数组下标
LEA EAX, [Array + EBX * 4]   ;计算Array[EBX]的地址，存储到EAX中
```

在上面的例子中，假设Array是一个长度为N的数组，每个元素占4个字节。通过将数组首地址加上EBX乘以4，可以计算出Array[EBX]的地址，然后使用LEA指令将该地址存储到EAX寄存器中。

具体过程是，控制器读取和解析指令后，分离出EAX,Array（代表段寄存器+基址寄存器）,EBX,4四个基本操作数，加减乘除运算后，运算结果复制到第二个操作数缓存，（此时”[]"是由于array符号的存在）经过地址计算后，将源操作数复制到第一个控制器寄存中

复制完毕后，操作器操作第一个操作数，发送WRITE和这个操作数的地址，将第一个控制器寄存的内容发送到对应的地址

需要注意的是，LEA指令只能用于计算地址，不能用于计算数值或执行其他操作。因此，在使用LEA指令时应该确保使用正确的源地址和寄存器，以避免出现错误的计算结果。

常见的操作是取地址操作，C语言内取址“&”编译后就对应这个指令，将索引寄存器内存储的地址转移到数据寄存器中

```c
int p=12;
int* a=&p;//相当于 LEA 数据段寄存器+a对应的基址寄存器，数据段寄存器+p对应的基址寄存器
```

> MOV与LEA的区别：
>
> mov是将数据从源操作传到目的操作数中
>lea是将源操作数的地址传到目的操作数中
> 一个是数据，一个是地址
> LEA指令的功能是取偏移地址，MOV指令的功能是传送数据 

##### 算术指令

这类指令用于进行数值运算，包括ADD、SUB、MUL、DIV等指令。

CPU的基本指令之一，用于进行基本运算。地址（二进制形式十六进制数）、基本数（二进制数）、字符（Ascii表示二进制数），只要是二进制数表示的数据都可以进行运算。指令是极为复杂的二进制数组成，对指令作算术运算没有意义。

**指令执行的区域在ALU中，临时的数据均保存        在累加器中**

在编程语言中，对应的指令为

ADD:相加，如a+b=>1+2=>00000001+00000010

SUB:相减

MUL:相乘

DIV:相除

##### 逻辑指令

这类指令用于进行逻辑运算，包括AND、OR、XOR、NOT等指令。

**指令执行的区域在ALU中，临时的数据均保存在数据寄存器中**

这类指令对应逻辑运算，如java编程语言中的bool运算、以及if语句的条件块等等

##### 条件跳转指令

这类指令用于根据条件来跳转到指定的代码块，包括JZ、JNZ、JE、JNE、JG、JL、JGE、JLE等指令。

条件跳转指令通常有两个操作数：一个是跳转目标的标号，另一个是用于判断跳转条件的条件码。

标号即相对地址，条件码是寄存器

这个指令会固定检查标志寄存器里的上一次运算值，然后会固定修改程序计数器PC的值（跳转），使CPU执行相应的代码块

**指令执行的区域在ALU中，临时的数据均保存在标志/数据寄存器中**

这类指令对应各种编程语句中的if/else条件语句

##### 无条件跳转指令

这类指令用于无条件跳转到指定的代码块，包括JMP指令。

##### 循环指令

这类指令用于实现循环，包括LOOP、LOOPE、LOOPNE等指令。

##### 程序调用指令

这类指令用于调用子程序或函数，包括CALL、RET等指令。

程序调用指令的基本过程如下：

1. 在调用指令之前，将调用函数的参数按照约定的方式压入堆栈中，以便函数调用时能够获取这些参数。
2. 执行调用指令（比如CALL指令），将当前指令的下一条指令的地址（也就是返回地址）压入堆栈中，并将程序计数器（PC）设置为被调用函数的起始地址。
3. 被调用函数开始执行，并从堆栈中读取传递的参数值。
4. 函数执行完成后，使用RET指令返回到调用函数的下一条指令，这时会从堆栈中弹出返回地址，并将程序计数器设置为该地址，继续执行调用函数后面的指令。
5. 调用函数从返回地址处继续执行，取出被调用函数返回的结果并继续执行后续指令。

在这个过程中，堆栈扮演了重要的角色，它用于存储参数、返回地址和临时变量等数据，保证程序能够正确地返回到调用函数，并恢复现场。此外，为了避免堆栈溢出，需要注意调用函数时参数和局部变量的空间分配以及返回值的传递方式等问题。

CALL指令是一种程序调用指令，它的作用是跳转到一个指定的函数或子程序，并将当前指令的下一条指令地址（也就是返回地址）压入堆栈中。CALL指令通常与RET指令配合使用，实现函数调用和返回的过程。

CALL指令的语法如下：

```assembly
CALL target
```

其中，target是要调用的函数或子程序的地址，可以是直接的地址，也可以是通过寄存器、内存地址等方式获取的地址。

**注意 操作数targert的值只能为地址**

CALL指令的执行过程如下：

1. 将当前指令的下一条指令地址（也就是返回地址）压入堆栈中。
2. 修改程序寄存器（PC）内的地址，跳转到目标函数或子程序的起始地址。
3. 执行目标函数或子程序的代码。

当目标函数或子程序执行完成后，通常会使用RET指令返回到CALL指令的下一条指令，此时会从堆栈中弹出返回地址并将程序计数器设置为该地址，继续执行CALL指令后面的指令。通过这种方式，程序可以实现函数调用和返回的过程。

##### 程序中断指令(陷入指令)

这类指令用于进行系统调用、中断和异常处理，包括INT、IRET、INTO等指令。

汇编语言中，中断指令的写法与所使用的处理器有关。以下是常见的两种处理器的中断指令写法：

1. Intel 8086 处理器

在 Intel 8086 处理器中，中断指令的写法为：

```
INT n
```

其中，n 为中断号，范围为 0~255。执行该指令会触发一个中断，并跳转到中断处理程序。

##### 字符串指令

这类指令用于对字符串进行操作，包括MOVSB、MOVSW、REP等指令。

##### 浮点数指令

这类指令用于进行浮点数运算，包括FADD、FSUB、FMUL、FDIV等指令。

##### SIMD指令

这类指令用于进行向量化计算，包括SSE、AVX等指令。

##### 特权指令

这类指令用于进行特权级别的操作，包括LGDT、LIDT、LDT等指令。

#### 寻址方式

##### 相对地址和绝对地址

### 架构

## 硬件系统

## 操作系统（OS）与软件体系

### 软件的本质

软件本身就是一串指令的集合

从操作系统的层面上来看，它们通常以.exe文件的形式储存在硬盘中

### BIOS与操作系统

操作系统本身也是应用程序，它也是一连串指令的合集，它也需要在计算机启动的时候由另一个程序加载进计算机内存中。

这个程序就是BIOS引导的固有硬件指令。

它是一种固化在计算机主板上的程序，它负责在计算机启动时进行硬件检测和初始化，并为操作系统提供接口和服务。BIOS是计算机系统的基本固件，也是操作系统与硬件之间的接口。

BIOS包含了计算机系统的基本设置和配置信息，例如系统时间、启动顺序、硬盘驱动器参数等。这些设置可以通过BIOS设置程序进行修改。BIOS还包含了一些内置的自诊功能，可以检测并报告硬件故障。

在计算机启动时，BIOS是第一个运行的程序。它从计算机的ROM芯片中加载到内存中，并进行自检、初始化、检测并加载引导扇区中的启动程序，然后将控制权转交给启动程序。一旦操作系统启动，BIOS就会停止运行，直到下一次系统重启。

虽然BIOS已经存在了很多年，但现代计算机已经开始逐步采用UEFI（Unified Extensible Firmware Interface）替代BIOS。UEFI提供了更先进的启动和管理功能，而且更加灵活和可扩展。

#### 常见的所有内核函数（以Windows为例）

1. 进程和线程管理函数：用于创建、销毁、调度和管理进程和线程，例如CreateProcess()、CreateThread()、WaitForSingleObject()、ExitProcess()、TerminateThread()等。

2. 内存管理函数：用于管理系统的物理和虚拟内存，例如VirtualAlloc()、VirtualFree()、MapViewOfFile()、UnmapViewOfFile()等。

3. 文件系统函数：用于管理文件和目录，例如CreateFile()、CloseHandle()、ReadFile()、WriteFile()、CreateDirectory()、RemoveDirectory()、MoveFile()、GetFileSize()等。

4. 设备驱动函数：用于管理硬件设备，例如打开、关闭、读写设备、配置和控制设备等，Windows提供了一种通用的设备驱动框架，包括字符设备、块设备、网络设备、USB设备等，相应的设备驱动函数也不同。

5. 网络函数：用于实现网络协议和通信，例如socket()、bind()、listen()、accept()、connect()、send()、recv()等。

6. 时间和日期函数：用于获取系统时间和日期，例如GetSystemTime()、GetLocalTime()等。

7. 系统配置函数：用于配置和管理系统参数，例如GetEnvironmentVariable()、SetEnvironmentVariable()、GetSystemInfo()、SetThreadPriority()等。

8. 中断和异常处理函数：用于响应系统中的中断和异常，例如SetUnhandledExceptionFilter()、RaiseException()等。

9. 进程间通信函数：用于实现进程间通信，例如管道、消息队列、信号量、共享内存等，相应的函数包括CreatePipe()、CreateSemaphore()、CreateMutex()、CreateEvent()、MapViewOfFile()、UnmapViewOfFile()等。

   > .exe文件的执行过程：
   >
   > 1.一个可执行的exe文件通常以二进制指令的形式保存在计算机硬盘中
   >
   > 2.当我们要执行文件时，实际上经过了以下流程：
   >
   > PCB保存数据、堆栈段寄存器的信息
   >
   > TCB保存堆栈基址、栈顶、代码段、PC寄存器的信息
   >
   > 3.程序中断的方式：硬中断（被动）、软中断（主动，包括轮询）
   >
   > 用户操作鼠标在桌面上移动——>鼠标接入计算机，并通过控制器和总线连接。用户操作鼠标移动时，鼠标内的芯片感受到光感应器产生的变化产生脉冲电流信号，信号产生输入数据，信号流入控制器，控制器发送硬件中断信号。cpu接收到硬件中断信号，cpu内控制器终止正在运行的指令，执行**中断指令**（将段寄存器和PC寄存器内的值保存在堆栈中，然后修改代码段寄存器为全局内存起始地址0x0000，将PC寄存器内的地址更改为相对偏移量对应的系统调用号），然后执行结束指令（将段寄存器+PC内的数据视为操作数，将操作数对应的值加载到执行区域），控制器执行**中断向量表对应的指令**（操作数为两个地址，将代码段寄存器更改为操作系统内核的代码段地址，再将PC更改为中断处理子程序入口地址对应偏移量），执行结束指令，执行**中断处理入口子程序**的指令；入口子程序首先将正在运行的进程和线程挂起（将目前的堆栈段、数据段、基址寄存器的值执行状态分别保存到PCB和TCB中，重新分配优先级），切换到内核自己的堆栈段和数据段（进入内核态，加载自己固定堆栈段和数据段），新建新堆栈专门执行中断处理线程（新建TCB新线程），根据注册表，再调用驱动程序（将寄存器更改为驱动程序的相关地址），将鼠标控制器的地址传递给驱动程序的子程序，驱动程序获取到鼠标控制器内的信号，使用接口指令转化为对应的数字信号量，返回到中断处理程序，中断处理程序再将其转化为鼠标的坐标、点击参数等，然后再根据鼠标数据对屏幕进行更新，完毕后，操作系统使用调度算法，继续执行任意应用程序的线程，这个内核堆栈线程也销毁（无返回值）返回执行其它应用程序。
   >
   > 注意，这个子程序处理的线程在硬中断完毕后就销毁了，子程序也没有任何返回值，因为在返回之前操作系统已经重新跳转到用户态了
   
10. 当一个进程需要通过系统调用来访问硬盘上的某块空间时，通常会经历以下过程：

    1. 进程发起系统调用：进程通过操作系统提供的系统调用接口（例如Unix-like系统的`read`或`write`）向操作系统发起请求，指示需要进行硬盘访问操作。
    2. 上下文切换：操作系统接收到系统调用请求后，会进行上下文切换，将控制权从用户态切换到内核态。这是因为系统调用需要在内核中执行，而进程通常运行在用户态。
    3. 参数传递：进程将需要访问的硬盘块的相关信息传递给操作系统。这些信息通常包括文件描述符（用于标识打开的文件）、缓冲区地址（指向进程的内存中的数据缓冲区）、要读取或写入的字节数等。
    4. 查找文件系统：操作系统根据文件描述符等信息，定位到相应的文件系统和硬盘驱动程序。文件系统是操作系统用于管理磁盘上文件和目录的一种组织结构，而硬盘驱动程序则负责与硬盘进行通信。
    5. 硬盘调度：在确定了文件系统和硬盘驱动程序之后，操作系统可能需要进行硬盘调度，以确定最佳的访问顺序和时间。硬盘调度算法的目标是尽量减少磁盘头的移动和减少等待时间，以提高访问效率。
    6. 数据传输：一旦硬盘调度完成，硬盘驱动程序开始向硬盘发送读取或写入命令，并等待硬盘执行操作。对于读取操作，硬盘将相应的数据块从磁盘读取到缓冲区中；对于写入操作，硬盘将缓冲区中的数据写入到磁盘的相应位置。
    7. 中断处理：在硬盘执行操作期间，操作系统可能会继续执行其他任务，而不必等待硬盘操作完成。一旦硬盘完成操作，它会发送一个中断信号给操作系统，表示数据已经准备好。
    8. 内核处理：操作系统接收到硬盘的中断信号后，会进行相应的中断处理。这可能包括将数据从内核缓冲区复制到进程的内存缓冲区（对于读取操作），或将进程的数据写入内核缓冲区，并将其传输到硬盘（对于写入操作）。
    9. 返回用户态：在数据传输和中断处理完成后，操作系统将控制权从内核态切换回用户态，并将结果返回给进程。

### 驱动程序

驱动程序本身也是“程序”，这意味着它们本身也由指令构成。
