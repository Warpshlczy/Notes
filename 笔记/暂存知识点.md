### （*）文件和文件类型

其实所有的文件类型最初都是由可被编码的字符串组成，加上文件后缀名后，表示这个文件可被某个软件读取，某个软件会按照文件的语法规则读取和编译该文件

- 如.java文件，被java的编译器读取时，编译器会按照规则将.java文件里的所有的字符串代码编译为二进制机器码，还会生成.exe文件，供处理器分配内存创建新进程
- 一般来说，固定后缀名的文件只能被特定软件打开，如md文件只能被支持markdown编译的软件打开，但编辑器支持读取大多数文件的后缀名，被编辑器打开时，编辑器只会读取文件内部的字符串内容，通过系统调用经过IO线展示在用户的显示器上，便于用户修改和编辑内部的字符串（将文件以字符流的形式加载进软件进程）
- 文件和可执行程序一样，会通过操作系统（0S）的系统调用实现从硬盘加载到内存中的某个进程（或打开）中，某个进程的接口api接收到操作系统传来的文件时，在进程中执行相应的代码
- html文件被浏览器读取和解析后，会以dom元素形式展现在页面上

### （*）操作系统保存的信息

操作系统内部（用户态）储存驱动程序、进程信息，硬件、ROM的信息由驱动程序提供

操作系统自身的函数储存在于内核态，又称内核态函数

内核态函数主要是操作驱动程序和通过让cpu发送IO指令与硬件层互动

（内核态）系统调用，是操作系统执行内核态函数，与硬件层互动的过程

### （*）打开.exe文件的硬件、操作系统、软件工作全过程

1.用户控制鼠标移动和点击，鼠标内的芯片感受到光感应器产生的变化产生脉冲电流信号，信号产生输入数据

2.输入数据通过usb流入设备控制器接口，设备控制器中的输入寄存器保存输入信息

3.CPU执行操作系统主线程，根据驱动程序记录的IO地址信息，操作系统再调用鼠标驱动程序的内核态函数，向IO总线发送两条IO指令，一条是读取，另一条询问地址信息，鼠标寄存器检查自身地址回应，并通过IO线输入信息返回数据给CPU

4.CPU拿到数据后，找到驱动程序的内存地址，将PC置于那个地址，先将数据放在寄存器，然后通过高速数据流或者IO线将数据放入PC所指向的内存地址

5.驱动程序获得数据后，对数据进行编译和解释，又变成二进制指令，交给操作系统的主线程，cpu执行，cpu根据函数处理得到鼠标投射到显示器上的位置和点击按键等信息，使用IO流对屏幕光标的位置和状态进行更新投射

（*）C语言编译后生成的二进制（.bin）文件，操作系统读取后，直接交给CPU执行

（*）操作系统提供的命令行窗口是基于BIOS的软件，操作系统通过它一次直接读取一行用户输入的指令，保存为一行字符串，然后将指令编译为机器码，交给CPU执行，这样操作系统就无需通过图形化界面匹配信息了

（*）cpu的工作：

在访问对象成员变量时，程序需要通过对象指针加上成员变量偏移量来计算出成员变量的地址。

BIOS（Basic Input/Output System）是一种固化在计算机主板上的程序，它负责在计算机启动时进行硬件检测和初始化，并为操作系统提供接口和服务。BIOS是计算机系统的基本固件，也是操作系统与硬件之间的接口。

BIOS包含了计算机系统的基本设置和配置信息，例如系统时间、启动顺序、硬盘驱动器参数等。这些设置可以通过BIOS设置程序进行修改。BIOS还包含了一些内置的自诊功能，可以检测并报告硬件故障。

在计算机启动时，BIOS是第一个运行的程序。它从计算机的ROM芯片中加载到内存中，并进行自检、初始化、检测并加载引导扇区中的启动程序，然后将控制权转交给启动程序。一旦操作系统启动，BIOS就会停止运行，直到下一次系统重启。

虽然BIOS已经存在了很多年，但现代计算机已经开始逐步采用UEFI（Unified Extensible Firmware Interface）替代BIOS。UEFI提供了更先进的启动和管理功能，而且更加灵活和可扩展。

### （*）wait和notify

在Java中，wait()和notify()是用于实现线程同步的方法，它们都是Object类的方法，因此所有Java对象都可以调用它们。

wait()方法会使当前线程进入等待状态，直到其他线程调用notify()或notifyAll()方法来唤醒它。wait()方法必须在synchronized代码块中调用，否则会抛出IllegalMonitorStateException异常。当线程调用wait()方法后，它会释放对象锁，以便其他线程可以访问对象。

notify()方法用于唤醒一个在等待状态的线程。notifyAll()方法会唤醒所有在等待状态中的线程。当调用notify()或notifyAll()方法时，系统会从等待队列中选择一个线程唤醒，并将它移动到就绪队列中，以便与其他就绪线程竞争CPU时间。

wait()和notify()方法通常用于多个线程之间的协调和通信，以确保它们按照一定的顺序运行。例如，一个线程可能会等待另一个线程完成某个任务，然后再继续执行自己的任务。在这种情况下，第一个线程可以调用wait()方法等待另一个线程完成任务，而第二个线程完成任务后可以调用notify()方法来唤醒等待的线程。

是的，你理解得很准确。

在系统调用的过程中，内核会为每个用户态进程创建一个专用的内核堆栈，这个堆栈是为了存储内核执行所需的上下文信息和临时数据而创建的。这个堆栈是内核为特定进程创建的，属于该用户态进程在内核中的上下文。

这个内核堆栈与内核线程的堆栈是不同的，内核线程有自己的堆栈用于执行内核代码。内核线程的堆栈与用户态进程的内核堆栈是分开的，它们分别用于不同的目的。

当进程执行系统调用时，它会切换到内核态，内核会使用该进程的内核堆栈来保存进程的上下文信息，并在内核态执行相关的内核代码。在系统调用完成后，进程会切换回用户态，并恢复使用自己的用户态堆栈来继续执行。

因此，可以理解为这个堆栈是内核为该用户态进程创建的堆栈，用于处理进程在内核态执行系统调用时的上下文信息和临时数据，而不属于内核线程的堆栈。